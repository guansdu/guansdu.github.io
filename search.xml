<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机网络基础复习</title>
    <url>/2017/08/01/computer-networks-review/</url>
    <content><![CDATA[<p>本文用来记录一些计算机网络相关的知识点。<a id="more"></a></p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>下面列出每一层以及该层使用的的协议：</p>
<ul>
<li>物理层：RJ45, CLOCK, IEEE802.3</li>
<li>数据链路层： PPP, FR, HDLC, VLAN, MAC</li>
<li>网络层：IP, ICMP, ARP, RARP, OSPF, IPX, RIP, IGRP. 路径选择、路由及逻辑寻址</li>
<li>传输层：TCP, UDP, SPX</li>
<li>会话层：NFS, SQL, NETBIOS RPC</li>
<li>表示层：JPEG, MPEG, ASII</li>
<li>应用层：FTP, DNS, HTTP, WWW, NFS, TELNET, SMTP</li>
</ul>
<h2 id="ARP工作原理"><a href="#ARP工作原理" class="headerlink" title="ARP工作原理"></a>ARP工作原理</h2><ol>
<li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li>
<li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</li>
<li>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li>
<li>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ol>
<p>广播发送ARP请求，单播发送ARP响应。</p>
<h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><ul>
<li>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。</li>
<li>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</li>
<li>TCP支持的应用协议主要有：Telnet、FTP、SMTP、HTTP等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。</li>
</ul>
<ol>
<li>TCP面向连接的运输层协议，UDP无连接 </li>
<li>TCP是可靠交付，UDP是尽最大努力交付 </li>
<li>TCP面向字节流，UDP面向数据报</li>
<li>TCP是点对点连接的，UDP一对一，一对多，多对多都可以 </li>
<li>TCP适合用于网页，邮件等，UDP适合用于视频，语音广播等</li>
</ol>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><ul>
<li>A类地址：以0开头，第一个字节范围：1~126（1.0.0.0 - 126.0.0.0）；</li>
<li>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</li>
<li>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</li>
<li>D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）</li>
<li>E类地址：保留；</li>
</ul>
<p>其中A、B、C是基本类，D、E类作为多播和保留使用。</p>
<p>以下是留用的内部私有地址：</p>
<ul>
<li>A类 10.0.0.0–10.255.255.255</li>
<li>B类 172.16.0.0–172.31.255.255</li>
<li>C类 192.168.0.0–192.168.255.255</li>
</ul>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码与IP地址做与操作得到网络地址。</p>
<p>A类网络缺省子网掩码：255.0.0.0<br>B类网络缺省子网掩码：255.255.0.0<br>C类网络缺省子网掩码：255.255.255.0</p>
<p>子网划分：</p>
<p>如果使用了自定义子网掩码，则就是做了子网划分。</p>
<p>未做子网划分的ip地址：网络号＋主机号<br>做子网划分后的ip地址：网络号＋子网号＋子网主机号</p>
<p><strong>如何确定子网数量？</strong></p>
<p>从子网掩码入手：</p>
<ol>
<li><p>观察子网掩码的二进制形式，确定作为子网号的位数n； </p>
</li>
<li><p>子网数量为2的n次方－2。（为什么减2？往下看）</p>
</li>
</ol>
<p>举个例子来说，比如有这样一个子网掩码：255.255.255.224其二进制为：<br>11111111.11111111.11111111.11100000可见n=3，2的3次方为8，说明子网地址可能有<br>如下8种情况： </p>
<p>000<br>001<br>010<br>011<br>100<br>101<br>110<br>111 </p>
<p>但其中代表网络自身的000；代表广播地址的111是被保留的，所以要减2。</p>
<p><strong>如何计算总主机数量，子网内主机数量？</strong></p>
<p>总主机数量＝子网数量×子网内主机数量 </p>
<p>对于子网掩码为255.255.255.224，上面的讨论知道它最多可以划分6个子网，那么每个子网内最多有多少个主机呢？由于网络被划分为6个子网，占用了主机号的前3位，且是C类地址，则主机号只能用5位来表示主机号，因此子网内的主机数量＝（2的5次方）－2＝30. 因此通过这个子网掩码我们可以算出这个网络最多可以标识6*30=180个主机。</p>
<h2 id="集线器-网桥等"><a href="#集线器-网桥等" class="headerlink" title="集线器 网桥等"></a>集线器 网桥等</h2><ul>
<li>物理层：中继器（Repeater）和集线器（Hub）。用于连接物理特性相同的网段，这些网段，只是位置不同而已。Hub 的端口没有物理和逻辑地址。</li>
<li>数据链路层：网桥（Bridge）和交换机（Switch）。用于连接同一逻辑网络中、物理层规范不同的网段，这些网段的拓扑结构和其上的数据帧格式，都可以不同。Bridge和Switch的端口具有物理地址，但没有逻辑地址。</li>
<li>网络层：路由器（Router）。用于连接不同的逻辑网络。Router的每一个端口都有唯一的物理地址和逻辑地址。</li>
<li>应用层：网关（Gateway）。用于互连网络上，使用不同协议的应用程序之间的数据通信，目前尚无硬件产品。</li>
</ul>
<h2 id="http-https"><a href="#http-https" class="headerlink" title="http https"></a>http https</h2><p>https（端口号443）和http的区别主要如下：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<p>虽然说https有很大的优势，但其相对来说，还是存在不足之处的：</p>
<ol>
<li>https协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li>
<li>https连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li>
<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li>
<li>https协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>
</ol>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>200 OK：请求已成功，请求所希望的响应头或数据体将随此响应返回。</p>
<p>301 Moved Permanently：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</p>
<p>302 Move temporarily：请求的资源临时从不同的 URI响应请求。</p>
<p>403 Forbidden：服务器已经理解请求，但是拒绝执行它。</p>
<p>404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。</p>
<p>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<p>503 Service Unavailable：由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</p>
<p>504 Gateway Timeout：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p>
<h2 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h2><p>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。而cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
<p>cookie数据存放在客户的浏览器上，session数据放在服务器上。cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<p>思考一下服务端如何识别特定的客户？每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。</p>
<h2 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET POST"></a>GET POST</h2><p>GET：从指定的资源请求数据。<br>POST：向指定的资源提交要被处理的数据。</p>
<p>参考资料：<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/html_ref_httpmethods.asp</a></p>
]]></content>
      <categories>
        <category>Networks</category>
      </categories>
      <tags>
        <tag>Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题deploy后大片空白解决办法</title>
    <url>/2016/11/07/a-next-theme-issue/</url>
    <content><![CDATA[<p>今天上传博客时发现在本地启动服务<a id="more"></a>时显示正常，然后deploy到GitHub后页面全是空白，在网上搜了下找到了以下解决方案：</p>
<ul>
<li><p>修改<code>...\themes\next\source\vendors</code>为<code>...\sourece\lib</code>，修改主题配置文件<code>_config.yml</code>中的<code>_internal: vendors</code>为<code>_internal: lib</code>。重新执行<code>hexo clean, hexo g,hexo d</code>即可。（已验证可行）</p>
</li>
<li><p>更新NexT<code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code>（未验证，据说更新后部分插件会失效）</p>
</li>
</ul>
<p>详细请参考：</p>
<p><a href="https://github.com/iissnan/hexo-theme-next/issues/1214" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/issues/1214</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C++中的引用传递</title>
    <url>/2016/09/11/about-pass-by-ref/</url>
    <content><![CDATA[<p>周末的时候翻了翻《Effective C++》这本书，看到条款28：<a id="more"></a>Avoid returning “handles” to object internals（不要返回handles指向对象内部的成分）。就想着自己写写代码实践一下，在书中有一段是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ul; &#125;</span><br><span class="line">  <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lr; &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rectangle用左上upperleft和右下lowerRight两个点Point表示，这里返回的references指向private的成员变量，使得可以调用这些函数来修改成员变量的值，然而这样的结果明显不是我们想要的（编写这两个函数的目的只是想返回这两个Point的值，并不想借此来修改它们）。</p>
<p>既然这里说到了引用传递，借用条款20：Prefer pass-by-reference-to-const to pass-by-value内容，我就再讨论下。</p>
<p>就用刚才的例子进行说明，首先我们扩充下Point类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point();</span><br><span class="line">	Point(<span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">const</span> <span class="keyword">int</span> y);</span><br><span class="line">	Point(<span class="keyword">const</span> Point&amp; p);</span><br><span class="line">	Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp; p);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> newVal)</span> </span>&#123; <span class="keyword">this</span>-&gt;x = newVal; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> newVal)</span> </span>&#123; <span class="keyword">this</span>-&gt;y = newVal; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造函数，拷贝构造函数和重载的赋值操作符定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point::Point():x(<span class="number">0</span>),y(<span class="number">0</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y):x(x), y(y)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point&amp; p):x(p.x), y(p.y)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">Point&amp; Point::<span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;x = p.x;</span><br><span class="line">	<span class="keyword">this</span>-&gt;y = p.y;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"operator="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//return this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rectangle类如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Rectangle(tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt; p);</span><br><span class="line">	Rectangle(<span class="keyword">const</span> Point&amp; ul, <span class="keyword">const</span> Point&amp; lr);</span><br><span class="line"></span><br><span class="line">	<span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ul; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rectangle::Rectangle(tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt; p) : pData(p)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">Rectangle::Rectangle(<span class="keyword">const</span> Point&amp; ul, <span class="keyword">const</span> Point&amp; lr)</span><br><span class="line">&#123;</span><br><span class="line">	pData = tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt;(<span class="keyword">new</span> RectData);</span><br><span class="line">	pData-&gt;lr = lr;</span><br><span class="line">	pData-&gt;ul = ul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RectData是一个结构体，包含了两个Point：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Point ul;</span><br><span class="line">	Point lr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在Rectangle的第二个构造函数中我们使用了const引用传递，我们如下定义一个Rectangle对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Rectangle <span class="title">rec1</span><span class="params">(p1, p2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们看看输出是什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor</span><br><span class="line">constructor</span><br><span class="line">default constructor</span><br><span class="line">default constructor</span><br><span class="line">operator=</span><br><span class="line">operator=</span><br></pre></td></tr></table></figure>

<p>接下来我们修改一下Rectangle类的第二个构造函数，使用值传递：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Rectangle(Point ul, Point lr);</span><br></pre></td></tr></table></figure>

<p>这次输出就变成了如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor</span><br><span class="line">constructor</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line">default constructor</span><br><span class="line">default constructor</span><br><span class="line">operator=</span><br><span class="line">operator=</span><br></pre></td></tr></table></figure>

<p>接下来解释一下各个输出的来由：首先定义的两个Point对象，调用了Point的第二个构造函数，会输出两个<code>constructor</code>，在使用const引用传递时，没有新的对象生成，输出的两个<code>default constructor</code>是因为使用了<code>new RectData</code>调用了Point的无参构造函数，而使用值传递时，需要生成两个Point的副本，所以就输出了两个<code>copy constructor</code>，后面的<code>operator=</code>就很好理解了，因为Rectangle的构造函数里调用了Point的赋值操作。</p>
<p>在这里我们可以看到，使用const引用传递还是很有优势的，因为没有任何构造函数和析构函数被调用，所以在对象比较大的时候，能比较明显的节约时间和空间。</p>
<p>注：在引用传递中，形参实际上是实参的别名，因为传递的是实参的地址，所以说在函数中对形参修改，会影响到实参。看一个简单的<code>swap</code>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ref</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"_swap bu val:"</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">","</span> &lt;&lt; &amp;y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> temp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">","</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap_ref(a, b);</span><br></pre></td></tr></table></figure>

<p>我们可以发现，在函数内x的地址和a是一样的，y的地址也等于b的地址。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Ref</tag>
      </tags>
  </entry>
  <entry>
    <title>2020的书单以及一些杂感</title>
    <url>/2020/06/03/books-in-2020/</url>
    <content><![CDATA[<p>距离上一次更新博客以及有2、3年之久了。<a id="more"></a>说来惭愧，当初建立这个博客的目的也有点功利心，只是想记录校招面试的一些准备工作。后来校招结束了，也就“理所应当”的停更了博客。</p>
<p>六月二十号开始计算的话，刚好毕业两年了。回顾这两年的经历，也算不上充实，摸爬滚打，自己算不上是很勤奋的人，自认为技术上也没有特别的精进，都说两年是一个结点，最近开始思考一下未来的打算，好像不是特别清晰，又迷茫起来了，就想写点东西。</p>
<p>去年到今年技术上没有特别上心，业余书籍倒是看了不少（经济、历史），可能也和当前整个氛围有关吧。现罗列如下：</p>
<ul>
<li>《复活》</li>
<li>《月亮与六便士》</li>
<li>《1984》</li>
<li>《人间失格》</li>
<li>《红与黑》</li>
<li>《君主论》</li>
<li>《社会契约论》</li>
<li>《呐喊》、《朝花夕拾》：是的，又读了鲁迅。</li>
<li>《动物庄园》</li>
<li>《杀死一只知更鸟》</li>
<li>《论人类不公平的起源和基础》</li>
<li>《娱乐至死》</li>
<li>《巴黎圣母院》</li>
<li>《去依附》、《告别百年激进》：温铁军的，有段时间在B站看了很多讲座视频，就买了些书拜读。</li>
<li>《毛选》</li>
</ul>
<p>现在的社会太浮躁，大家都忙碌着搞小钱钱，精神世界荒芜空虚。我也不例外，现在变成了自己讨厌的人，或许这就是成年人的世界，一边内心厌恶，一边还不得不做。不过对于我这种从农村里面出来的孩子，想在大城市立足并没有那么简单，但是回到小城市又有所不甘心，所以只能对自己说加油吧骚年！</p>
<p>读书只是为了找寻答案，也是为了给内心找到栖息之处。当然目前的我还是一无所获。</p>
<p>毕业参加工作，稀里糊涂的就干上了Unreal Engine，突然想到当初拒绝了网易游戏的Offer就是不太想做游戏，没想到摇摇晃晃仿佛又回到了原点，虽然现在的工作内容并不是游戏相关，不过看来还是离不开游戏行业了，UE4的方向也就是游戏吃香了。</p>
<p>现在的工作算不上忙碌，内容算不上喜欢，收入马马虎虎。最近有猎头开出了诱人的薪水，所以就很纠结要不要换个环境。其实不太想谈工作，因为只是雇佣关系，给钱办事，简单粗暴。但我这个人就是这样，忍不住说几句，去年组内有能力的大佬都选择了离开，当时对我的打击还是挺大的，因为觉得难得遇到一群好的同事，转眼距离他们离开已经过了一年，虽然现在又来来回回进来了一些新同事，但是早已经没有了那种感觉，大家的关系淡了很多，我想我或许应该要离开了，或许这就是工作上的成长吧。。。</p>
<p>“胜地不常，盛筵难再；兰亭已矣，梓泽丘墟”</p>
<p>希望我们都有美好的未来！</p>
]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法backtracking的一些总结</title>
    <url>/2017/07/08/backtracking/</url>
    <content><![CDATA[<p>回溯法（backtracking）是我们在寻找某个算法问题（特别是有条件约束的情况下）<a id="more"></a>所有可能解的一个重要工具，也是我们必须要掌握的核心内容之一。</p>
<p>怎么解释backtracking呢？其实它类似于“穷举法”，利用一些约束条件，来去掉不符合要求的的解，只留下满足要求的解，也有点类似于DFS，一步一步走到叶子结点，满足要求就保存这个解，不满足要求就退回到上一层的结点，直到所有可能的路径都被访问过。在实际写代码中，通常都是用递归来完成。</p>
<p>我这里用伪代码来描述一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Si is a possible solution</span></span><br><span class="line"> backtracking(Si)</span><br><span class="line">    <span class="keyword">if</span> (Si is legal)</span><br><span class="line">        savs Si, <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> all S (S1, S2, ... , Sn)</span><br><span class="line">        backtracking(S)</span><br></pre></td></tr></table></figure>

<p>下面借用LeetCode里面的几道题来具体阐述一下：</p>
<h2 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h2><p>原题在这里：<a href="https://leetcode.com/problems/permutations/#/description" target="_blank" rel="noopener">46. Permutations</a>，题目的要求是给定一组不包含重复的数字集合，求它们所有的全排列。</p>
<p>解题思路就是每次固定其中的一个位置，然后与后面的数字进行交换，下面看下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        getPer(ans, nums, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 每次固定其中的一个位置，然后与后面的交换</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPer</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[i], nums[start]);</span><br><span class="line">            getPer(ans, nums, start + <span class="number">1</span>);</span><br><span class="line">            swap(nums[i], nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果给定的集合中包含重复的数字：<a href="https://leetcode.com/problems/permutations-ii/#/description" target="_blank" rel="noopener">47. Permutations II</a>，那么我们又该如何求出所有的全排列呢（不包含重复的）？其实基本思路和上面也是一样的，只是每次只和不同的值进行交换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        getPer(ans, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPer</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.size() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; nums[i] == nums[start])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(nums[i], nums[start]);</span><br><span class="line">            getPer(ans, nums, start + <span class="number">1</span>);</span><br><span class="line">            swap(nums[i], nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了大家能更加深刻的理解backtracking，我用<code>nums=[1,2,3]</code>为例，画出了每一个递归调用的过程：<br>（注意括号里面的是<code>start</code>的值）</p>
<p>getPer(0)：</p>
<ul>
<li>i = 0, getPer(1)</li>
<li>i = 1, getPer(1)</li>
<li>i = 2, getPer(1)</li>
</ul>
<p>getPer(1)：</p>
<ul>
<li>i = 1, getPer(2)</li>
<li>i = 2, getPer(2)</li>
</ul>
<p>getPer(2):</p>
<ul>
<li>i = 2, getPer(3)</li>
</ul>
<p>接下来我只详细分析第一层的递归调用：</p>
<ol>
<li>首先调用函数getPer(ans, nums, 0)，i = 0，执行swap(nums[0],nums[0])；</li>
<li>调用getPer(ans, nums, 1)，i = 1，执行swap(nums[1],nums[1])；</li>
<li>调用getPer(ans, nums, 2)，i = 2，执行swap(nums[2],nums[2])；</li>
<li>调用getPer(ans, nums, 3)，把nums=[1,2,3]存储到ans中，返回第3步中；</li>
<li>执行swap(nums[2],nums[2])，返回第2步中；</li>
<li>执行swap(nums[1],nums[1])，i = 2，执行swap(nums[2],nums[1])，nums=[1,3,2]，调用getPer(ans, nums, 2)；</li>
<li>i = 2，执行swap(nums[2],nums[2])，调用getPer(ans, nums, 3)，把nums=[1,3,2]存储到ans，返回；</li>
<li>执行swap(nums[2],nums[2])，返回上一步，执行swap(nums[2],nums[1])，nums=[1,2,3]，返回到第1步中；</li>
<li>也就是说，至此，getPer(0)中i = 0的情况已经执行完毕；ans中存放了两个结果[1,2,3]和[1,3,2]。</li>
<li>接下来执行i = 1，以此类推…</li>
</ol>
<h2 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h2><p>题目来自<a href="https://leetcode.com/problems/subsets/#/description" target="_blank" rel="noopener">78. Subsets</a>，就是给定一组没有重复数字的集合，求出所有可能的组合。</p>
<p>用backtracking来解决是比较直观的，下面直接给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        bk(ans, nums, vec, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bk</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.push_back(vec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            bk(ans, nums, vec, i + <span class="number">1</span>);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么如果给定的集合包含重复数字：<a href="https://leetcode.com/problems/subsets-ii/#/description" target="_blank" rel="noopener">90. Subsets II</a>，我们的解决办法就是先对其进行排序，然后在选择的时候跳过相同的数即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        getSubsetdsWithDup(ans, sub, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSubsetdsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.push_back(sub);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sub.push_back(nums[i]);</span><br><span class="line">            getSubsetdsWithDup(ans, sub, nums, i + <span class="number">1</span>);</span><br><span class="line">            sub.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h2><p>给定一组数的集合（没有重复元素），找出里面所有相加起来等于<code>T</code>的元素组合，某一个元素可以被多次使用，来自<a href="https://leetcode.com/problems/combination-sum/#/description" target="_blank" rel="noopener">39. Combination Sum</a>。</p>
<p>解题思路也是利用backtracking，每次选择一个数nums[i]，在下一个递归中重复选择这个nums[i]，如果它的和最终能等于<code>T</code>，那么就保存这一组数，退回的上一个结果，选择另外一个数nums[i+1]，如此往复，直至所有的可能组合都被遍历过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        getCom(ans, nums, vec, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getCom</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> start, <span class="keyword">int</span> remain)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remain &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remain == <span class="number">0</span>)</span><br><span class="line">            ans.push_back(vec);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                getCom(ans, nums, vec, i, remain - nums[i]);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面对要求稍作改动，如果每个元素只能被选择一次，假定给定的集合中所有的数都是正数，题目来自<a href="https://leetcode.com/problems/combination-sum-ii/#/description" target="_blank" rel="noopener">40. Combination Sum II</a>。</p>
<p>我们的思路通上面类似，只是递归调用时选择下一个数，不在继续选用当前的数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        </span><br><span class="line">        getCom(ans, nums, vec, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getCom</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> start, <span class="keyword">int</span> remain)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remain &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remain == <span class="number">0</span>)</span><br><span class="line">            ans.push_back(vec);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                getCom(ans, nums, vec, i + <span class="number">1</span>, remain - nums[i]);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继续思考，现在我们给定1-9这9个数，已知<code>k</code>和<code>n</code>，我们的目的是求出所有可能的组合使得k个数（只能从1-9里面选）加起来的和等于n，不能重复选择某个数，来自<a href="https://leetcode.com/problems/combination-sum-iii/#/description" target="_blank" rel="noopener">216. Combination Sum III</a>。</p>
<p>解决思路同上，只不过增加判定条件，选的元素个数为k且和为n，才能认为是正确的组合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        getCom(ans, vec, <span class="number">1</span>, k , n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getCom</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> start, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == vec.size() &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line">            ans.push_back(vec);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; vec.size())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                vec.push_back(i);</span><br><span class="line">                getCom(ans, vec, i + <span class="number">1</span>, k, n - i);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相信到了这里，大家基本上都对backtracking的解题套路有了了解，细心地同学可能会发现，每次递归调用后我们都要进行reset，就是撤回到上次调用前的状态，这是因为我们在调用函数使用的是引用传递，所以每次对nums进行<code>push_back</code>后，都要进行<code>pop_back</code>，来回到上一状态。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Backtracking</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>模板元编程之std::enable_if</title>
    <url>/2020/06/01/about-enable-if/</url>
    <content><![CDATA[<p>常见的情况就是编译期的条件判断，标准C++ 11里面就提供了<code>std::enable_if</code>。<a id="more"></a></p>
<p>可作为函数的参数或者返回值，根据enable_if是否有定义来进行模板特化。</p>
<p><code>std::enable_if</code>的代码实现相当简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="keyword">typename</span> T = <span class="keyword">void</span>&gt;</span><br><span class="line">struct enable_if </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">enable_if</span>&lt;false, T&gt; &#123;</span>&#125;; <span class="comment">// no ::type if B==false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="keyword">typename</span> T = <span class="keyword">void</span>&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIf = <span class="keyword">typename</span> enable_if&lt;B, T&gt;::type;</span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是说如果<code>B</code>是为<strong>true</strong>，那么它会有一个<code>type</code>成员，类型为<code>T</code>。</p>
<p>关于用法，下面写了一个很简单的对指针取值的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_pointer&lt;T&gt;::value&gt; DeRef(<span class="keyword">const</span> T&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *t &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<strong>SFINAE</strong>：</p>
<blockquote>
<p>In the process of template argument deduction, a C++ compiler attempts to instantiate signatures of a number of candidate overloaded functions to make sure that exactly one overloaded function is available as a perfect match for a given function call.</p>
</blockquote>
<blockquote>
<p>If an invalid argument or return type is formed during the instantiation of a function template, the instantiation is removed from the overload resolution set instead of causing a compilation error. As long as there is one and only one function to which the call can be dispatched, the compiler issues no errors.</p>
</blockquote>
<p>编译器在进行模板实例化时会遍历所有的候选项来找到一个最佳匹配，即使出现了无效参数，只要有一个合适的匹配编译器就不会报错。</p>
<p>参考资料：<br><a href="https://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/types/enable_if</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title>Win7下用Hexo建博客的一些说明</title>
    <url>/2016/06/28/build-blog/</url>
    <content><![CDATA[<p>首先要安装好Node.js和Git。</p>
<p>打开<code>Git bash</code> <a id="more"></a></p>
<p>设置你的邮箱和用户名（我这里就是用的GitHub的邮箱，用户名随意）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;guansdu@163.com&quot;</span><br><span class="line">git config --global user.name &quot;guansdu&quot;</span><br></pre></td></tr></table></figure>

<p>生成新的SSH key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;guansdu@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>成功后在文件夹<code>C:\Users\Klaus\.ssh</code>会看到一个<code>id_ras.pub</code>文件，将里面的内容添加到你的GitHub上（在<code>Settings</code>里的<code>SSH and GPG keys</code>，点击<code>New SSH key</code>）。</p>
<p>测试你的Git与GitHub是否成功链接起来了（以下命令无需修改）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>成功后就可以安装Hexo了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>： 2016/10/7 更新：hexo官网已经变成了<code>npm install -g hexo-cli</code>，具体的请以官网为准：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
<p>进到你想把Hexo放在的目录下打开<code>Git bash</code>，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：在部署到GitHub上之前要修改Hexo文件夹下的<code>_config.yml</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:xxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>Hexo常用操作：</p>
<ul>
<li>生成静态页面：<code>hexo g</code></li>
</ul>
<ul>
<li>本地启动：<code>hexo s</code>(默认是localhost:4000，可在浏览器预览发布后的效果，若端口4000出错，可以尝试<code>hexo s -p 3600</code>修改到任意端口)</li>
</ul>
<ul>
<li>发布到GitHub：<code>hexo d</code></li>
</ul>
<ul>
<li>新建文章： <code>hexo new &quot;blog-name&quot;</code></li>
</ul>
<p>参考资料：</p>
<ol>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li>
<li><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="noopener">http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 523. Continuous Subarray Sum</title>
    <url>/2017/09/01/continuous-subarray-sum/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.</p>
<p>Input: [23, 2, 4, 6, 7],  k=6<br>Output: True<br>Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6. [23, 2, 6, 4, 7] is also a right answer because sum up to 42(= 6*7).</p>
</blockquote>

<p>Solution:</p>
<p>一开始除了暴力的解法O(N*N)以外，我也没有想到更好的方法，后来看了discuss才发现了有O(N)的解法，really tricky。。</p>
<p>主要就是利用了<code>(a + n*k) % k = a % k</code>，其中n为整数。对题目中的例子可分析如下：</p>
<p>[23, 2, 4, 6, 7]它的和数组为[23, 25, 29, 35, 42]，可求得每一个数除以K的余数为[5, 1, 1, 5, 0]。考虑到出现了两个余数都为5的位置，分别是0和3，那么我们可以推断出nums[1]+nums[2]+nums[3]必定可以被K整除。</p>
<p>此题有很多corner case需要注意，比如k=0时；k为负数；数为0的情况。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        k = INT_MAX;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// in case of remainder is 0</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">int</span> tmp = sum % k;</span><br><span class="line">        <span class="keyword">if</span> (mp.find(tmp) == mp.end())</span><br><span class="line">        &#123;</span><br><span class="line">            mp[tmp] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - mp[tmp] &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>昨天晚上美团笔试也碰到了类似的这个题，是求所有满足这样条件的连续子数组中最大的长度，哎，泪奔啊。。。现在才知道解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max_length</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">int</span> tmp = sum % K;</span><br><span class="line">        <span class="keyword">if</span> (mp.find(tmp) == mp.end())</span><br><span class="line">        &#123;</span><br><span class="line">            mp[tmp] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            max_len = max(max_len, i - mp[tmp]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型之function</title>
    <url>/2017/08/24/cpp-object-model-function/</url>
    <content><![CDATA[<p>Stanley B.Lippman-<strong>Inside the C++ Object Model</strong> Chapter 4<a id="more"></a></p>
<h2 id="static-member-function"><a href="#static-member-function" class="headerlink" title="static member function"></a>static member function</h2><p>static member function没有this指针；不能够直接存取其class的nonstatic member；不能够被声明为const，virtual和volatile；可以直接用class调用。</p>
<h2 id="virtual-member-function"><a href="#virtual-member-function" class="headerlink" title="virtual member function"></a>virtual member function</h2><p>virtual function的一般实现模型是：每一个class有一个virtual table，内含该class之中有作用的virtual function的地址，然后每个object有一个vptr，指向该virtual table的所在。</p>
<p>virtual member function是支撑C++多态的基石：用一个public base class的指针或引用，指向一个derived class object，根据不同的指向，可以调用不同的virtual member function。</p>
<p>考虑以下调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ptr-&gt;z();</span><br></pre></td></tr></table></figure>

<p>其中z()是一个virtual function，那么什么信息才能让我们在执行期调用正确的z()呢：</p>
<ol>
<li>ptr所指向对象的真是类型；</li>
<li>z()实例的位置；</li>
</ol>
<p>我们可以在每一个多态的class object上添加两个member信息：</p>
<ol>
<li>一个字符或数字，表示class的类型；</li>
<li>一个指针，指向某个表格，表格中持有程序的virtual function的执行期地址；</li>
</ol>
<p>编译器为了找到函数地址，给每一个virtual function指派了一个表格索引值。这样在运行期，只需要在特定的virtual table slot中激活virtual function。</p>
<p>每个class只会有一个virtual table，里面包括了virtual function实例的地址，这些virtual function包括：</p>
<ol>
<li>这一class所定义的函数实例：改写（overriding）自base class的virtual function。</li>
<li>继承自base class的函数实例：derived class没有决定改写这个virtual function才会出现。</li>
<li>一个pure virtual function函数实例。 </li>
</ol>
<p>考虑以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Point&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x = <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> _x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> :</span> <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point2D(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>) : Point(x), _y(y) &#123; &#125;</span><br><span class="line">    ~Point2D();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overriding base class virtual functions</span></span><br><span class="line">    <span class="function">Point2D&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _y; &#125;</span><br><span class="line">    <span class="comment">// ...other functions</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其可能的virtual table布局为：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/object-model-virtual-function.png" alt="virtual table"></p>
<p>这里把 virtual destructor指派为slot 1，而mult指派为slot 2。但是multi并没用定义。而这里面并没用x()，因为它不是virtual function。</p>
<p>Point2D继承自Point，可观察其virtual table分布：slot 1放置destructor，slot 2指出mult()，重写的y()放在slot 3，继承来的z()放在slot 4。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型之data member</title>
    <url>/2017/08/24/cpp-object-model-data-member/</url>
    <content><![CDATA[<p>Stanley B.Lippman-<strong>Inside the C++ Object Model</strong> Chapter 3<a id="more"></a></p>
<h2 id="class的大小"><a href="#class的大小" class="headerlink" title="class的大小"></a>class的大小</h2><p>考虑以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> X, <span class="keyword">public</span> Y &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在codeblocks 16.01上这四个类的大小分别为：1,4,4,8。则是因为一个空的类编译器会默认安插一个char为1 byte大小，Y和Z含有一个指向virtual base class X subobject的指针，所以为4。注意一个virtual base class subobject只会在derived class存在一个实例，不管它在class继承体系出现了多少次。如下图</p>
<blockquote>
<pre><code>  X
 / \
Y   Z
 \ /
  A</code></pre></blockquote>
<h2 id="data-member布局"><a href="#data-member布局" class="headerlink" title="data member布局"></a>data member布局</h2><p>看下面的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Point3d*&gt; *p_list;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> chunk_size = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nonstatic data member在class object中排列顺序和被声明顺序一样，而static data member都不会被放进对象布局之中，它们会被放在程序的data segment，和个别的class objects无关。所以每一个Point3d都是有float x,y,z组成。</p>
<h2 id="data-member存取"><a href="#data-member存取" class="headerlink" title="data member存取"></a>data member存取</h2><h3 id="static-data-member"><a href="#static-data-member" class="headerlink" title="static data member"></a>static data member</h3><p>每个static data member只有一个实例，可直接通过class存取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point3d::chunk_size = <span class="number">250</span>;</span><br></pre></td></tr></table></figure>

<p>derived class也可以直接存取base class的static data member，但是该static data memberpublic必须是public属性。</p>
<p>若两个不同的class都定义了相同名称的chunk_size，那么编译器会使用name-mangling来确保每个static member在data segment拥有一个独一无二的名称。</p>
<h3 id="nonstatic-data-member"><a href="#nonstatic-data-member" class="headerlink" title="nonstatic data member"></a>nonstatic data member</h3><p>nonstatic data member直接存放在class object中，只能通过显示的或者隐式的class object来访问。</p>
<h3 id="继承与data-member"><a href="#继承与data-member" class="headerlink" title="继承与data member"></a>继承与data member</h3><p>C++继承模型中，一个derived class object所表现出来的东西，是其自己的member加上其base class member的总和。但是base class member和derived class member的布局顺序要具体看编译器实现。</p>
<p>如果存在virtual function的话，编译器会在每个class object中加入一个vptr。</p>
<p>对于virtual inheritance，为了保证只有一份virtual base class subobject，编译器会在每个derived class object中安插一个指针，来指向一个virtual base class。比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span><span class="keyword">public</span> C, <span class="keyword">public</span> B &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>不适用virtual继承，那么sizeof(D)就是24 byte；改为如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span><span class="keyword">public</span> C, <span class="keyword">public</span> B &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>那么sizeof(D)就是20 byte。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>模板元编程初探</title>
    <url>/2020/05/18/cpp-metaprogramming-1/</url>
    <content><![CDATA[<p>最近看了下UE4的源码，又勾起了对模板元编程的向往之情。<a id="more"></a></p>
<p>模板元编程的目的无外乎两个：类型安全；提高runtime性能（一部分内容转移到编译期）。当然不排除有大佬秀技的可能。</p>
<p>UE4源码中的<code>Core/Templates/</code>文件夹里面有很多编译期的Traits函数，可以直接拿来用，不过看看实现也是极好的。</p>
<p>Traits早些年在看《STL源码剖析》时候还一直不太明白，现在熟悉了模板后有种恍然大悟的感觉，就是把类型和属性关联起来，说人话就是用类型来表示变量、函数、类的属性。在标准C++库头文件里的<code>type_traits</code>也很有多。其本质就是利用了模板特化和编译器最佳匹配原则。</p>
<p>下面是一些例子（来自Unreal）</p>
<h2 id="TIsPointer"><a href="#TIsPointer" class="headerlink" title="TIsPointer"></a>TIsPointer</h2><p>指针类型萃取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Traits class which tests if a type is a pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TIsPointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">enum</span> &#123; Value = <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">TIsPointer</span>&lt;T*&gt; &#123;</span> <span class="keyword">enum</span> &#123; Value = <span class="literal">true</span> &#125;; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="TIsConst"><a href="#TIsConst" class="headerlink" title="TIsConst"></a>TIsConst</h2><p>常量类型萃取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Traits class which tests if a type is const.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TIsConst</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> Value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TIsConst</span>&lt;const T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> Value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="TIsSigned"><a href="#TIsSigned" class="headerlink" title="TIsSigned"></a>TIsSigned</h2><p>符号类型萃取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Traits class which tests if a type is a signed integral type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TIsSigned</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">enum</span> &#123; Value = <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">TIsSigned</span>&lt;int8&gt;  &#123;</span> <span class="keyword">enum</span> &#123; Value = <span class="literal">true</span> &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">TIsSigned</span>&lt;int16&gt; &#123;</span> <span class="keyword">enum</span> &#123; Value = <span class="literal">true</span> &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">TIsSigned</span>&lt;int32&gt; &#123;</span> <span class="keyword">enum</span> &#123; Value = <span class="literal">true</span> &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">TIsSigned</span>&lt;int64&gt; &#123;</span> <span class="keyword">enum</span> &#123; Value = <span class="literal">true</span> &#125;; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">TIsSigned</span>&lt;const          T&gt; &#123;</span> <span class="keyword">enum</span> &#123; Value = TIsSigned&lt;T&gt;::Value &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">TIsSigned</span>&lt;volatile       T&gt; &#123;</span> <span class="keyword">enum</span> &#123; Value = TIsSigned&lt;T&gt;::Value &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">TIsSigned</span>&lt;const volatile T&gt; &#123;</span> <span class="keyword">enum</span> &#123; Value = TIsSigned&lt;T&gt;::Value &#125;; &#125;;</span><br></pre></td></tr></table></figure>

<p>实际上的话上面这些代码看懂也不是很难，无非就是要熟悉一下C++模板的写法，再一个就是要明白哪些是编译期常量，实际上有了<code>constexpr</code>以后模板元编程会更方便一些。</p>
<p>下面这个就有点奇妙了，是判断指针转换可否的一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests if a From* is convertible to a To*</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> From, <span class="keyword">typename</span> To&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TPointerIsConvertibleFromTo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> uint8  <span class="title">Test</span><span class="params">(...)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> uint16 <span class="title">Test</span><span class="params">(To*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; Value  = <span class="keyword">sizeof</span>(Test((From*)<span class="literal">nullptr</span>)) - <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实的话就是根据函数Test的返回值长度来进行判别；重载了Test函数，编译期会自动根据<code>(From*)nullptr</code>的类型来选择调用哪个函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型之构造、析构和拷贝</title>
    <url>/2017/08/25/cpp-object-model-destruction-copy/</url>
    <content><![CDATA[<p>Stanley B.Lippman-<strong>Inside the C++ Object Model</strong> Chapter 5<a id="more"></a></p>
<h2 id="construction"><a href="#construction" class="headerlink" title="construction"></a>construction</h2><p>是可以定义和调用一个pure virtual function的，不过只能被静态的调用</p>
<p>编译器对constructor的扩充：</p>
<ol>
<li><p>记录在member initialization list中的data members初始化操作会被放进constructor的函数本体，并以members的声明顺序为顺序。</p>
</li>
<li><p>如果有一个member并没用出现在member initialization list之中，但是它有一个default constructor，那么该default constructor也会被调用。</p>
</li>
<li><p>在那之前，如果有virtual table pointer，他们也必须背初始化，指向适当的virtual table。</p>
</li>
<li><p>在那之前，所有上一层的base class constructors必须被调用，以base class声明顺序为顺序。</p>
</li>
<li><p>在那之前，所有virtual base class constructors必须被调用，从左到右，从最深到最浅。</p>
</li>
</ol>
<p>考虑以下派生情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Point&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Point&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span> :</span><span class="keyword">public</span> Point3d, <span class="keyword">public</span> Vertex&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PVertex</span> :</span> <span class="keyword">public</span> Vertex3d&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>要注意的是，virtual base class constructors的被调用有着明确的定义：只有当一个完整的class object被定义出来，它才会被调用；如果object只是某个完整的object的subobject，它就不会调用。例如定义<code>Vertex3d cv</code>，此时Vertex3d的constructor正确的调用Point的constructor，但是这是Point3d和Vertex是Vertex3d的subobject，它们一定不可以调用Point的constructor。</p>
<p>若定义一个<code>PVertex</code>object时，constructor的调用顺序为：Point, Point3d, Vertex, Vertex3d, PVertex。这告诉我们，constructor的调用顺序为：有根源到末端，由内向外（bottom up）。当base class constructor执行时，derived实例还不完整。</p>
<h2 id="copy-assignment-operator"><a href="#copy-assignment-operator" class="headerlink" title="copy assignment operator"></a>copy assignment operator</h2><p>把一个class的copy assignment operator声明为private，就禁止了class之间的赋值操作。</p>
<p>编译器默认会合成一个copy assignment operator，表现的是bitwise copy语意，但是除了以下情况：</p>
<ol>
<li>当class内含一个member object，而其class有一个copy assignment operator；</li>
<li>当一个class的base class有一个copy assignment operator时；</li>
<li>当一个class声明了任何virtual function时；</li>
<li>当一个class继承自一个virtual base class时；</li>
</ol>
<h2 id="destruction"><a href="#destruction" class="headerlink" title="destruction"></a>destruction</h2><p>destructor和constructor类似的扩展，但是顺序相反。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C++中const的用法</title>
    <url>/2016/07/26/cpp-const/</url>
    <content><![CDATA[<p>被const关键字修饰的对象不能被修改，用于把一个对象变成常量。<a id="more"></a>和#define不同的地方在于，const常量有数据类型，而宏常量没有，编译器对const常量可以进行类型安全检查，而对宏常量只进行字符替换。</p>
<h2 id="const修饰普通变量"><a href="#const修饰普通变量" class="headerlink" title="const修饰普通变量"></a>const修饰普通变量</h2><p><code>const int val</code>和<code>int const val</code>这两种写法都可以，都表示val一旦初始化后值不可以被修改。</p>
<h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p>const和指针在一起使用时，主要有下面几种写法：</p>
<ul>
<li>(1) <code>const int* p1</code>：<code>*p1</code>不可变，<code>p1</code>可变；</li>
<li>(2) <code>int* const p2</code>：<code>p2</code>不可变，<code>*p2</code>可变；</li>
<li>(3) <code>int const *p3</code>：同(1)；</li>
<li>(4) <code>const int* const p4</code>：<code>*p4</code>不可变，<code>p4</code>不可变</li>
</ul>
<h2 id="const修饰函数参数"><a href="#const修饰函数参数" class="headerlink" title="const修饰函数参数"></a>const修饰函数参数</h2><p>const修饰函数参数时表示<strong>在该函数体中不能修改该参数的值</strong>。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> val)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">//传递过来的参数val在函数内不可以改变(实际上无意义，因为val本身就是形参)</span></span><br></pre></td></tr></table></figure>

<p>常常和指针传递、引用传递相结合使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* p1)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">//参数指针p1所指内容为常量不可变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">//引用参数在函数内不可以改变</span></span><br></pre></td></tr></table></figure>

<p>const指针可以接受const和非const地址，但是非const指针只能接受非const地址。所以const指针的能力更强一些，所以尽量多用const指针。我们看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func0</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Func0:"</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Func1:"</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Func2:"</span> &lt;&lt; *x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">int</span>* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Func3:"</span> &lt;&lt; *x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">2</span>;    <span class="comment">//可以执行a=b，反之则不可以，因为const变量不允许修改</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> me = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;me;    <span class="comment">//*p1不可变</span></span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> p2 = &amp;me;    <span class="comment">//p2不可变</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;me;    <span class="comment">//p3不可变，*p3也不可变</span></span><br><span class="line">	<span class="keyword">int</span>* p4 = &amp;me;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//p1的值就是变量me的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//p2的值也是变量me的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p1:"</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//4</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p2:"</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> he = <span class="number">5</span>;</span><br><span class="line">	p1 = &amp;he;    <span class="comment">//修改了p1，现在p1的值是变量he的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p1:"</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//5</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p2:"</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> she = <span class="number">6</span>;</span><br><span class="line">	*p2 = she;    <span class="comment">//修改了*p1的值，相当于修改了变量me的值。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p1:"</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//5</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p2:"</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"me:"</span> &lt;&lt; me &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//6 可以看到me的值发生了变化</span></span><br><span class="line"></span><br><span class="line">	Func0(a);</span><br><span class="line">	<span class="comment">//Func0(b);错误</span></span><br><span class="line"></span><br><span class="line">	Func1(a);<span class="comment">//const引用可接受const变量，也可接受非const变量</span></span><br><span class="line">	Func1(b);</span><br><span class="line"></span><br><span class="line">	Func2(p1);<span class="comment">//const指针即可接受const地址，也可接受非const地址</span></span><br><span class="line">	Func2(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Func3(p1);错误</span></span><br><span class="line">	Func3(p4);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const用于类-类的成员函数中"><a href="#const用于类-类的成员函数中" class="headerlink" title="const用于类/类的成员函数中"></a>const用于类/类的成员函数中</h2><p>const修饰类的成员函数，一般放在函数体后面，表示<strong>它不能修改类的成员变量，也不能调用任何非const的成员函数</strong>，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Function3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Function4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const A a;</span><br><span class="line">a.Function3(); //错误</span><br><span class="line">a.Function4(); //正确</span><br></pre></td></tr></table></figure>

<p>任何不修改类的成员变量的成员函数都应该声明为const。</p>
<p>还要注意：关键字const必须用同样的方式重复出现在函数实现里，否则编译器会把它看成一个不同的函数，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> A::Function4() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ul>
<li><a href="http://baike.baidu.com/link?url=posJHyKXPiPlypc43ccE3VwfXedTLVt4VNgXdC4ZrpKTcgKGoCV8pIp1tFoyHhdqUA30lyk1m5DSOrQ-2RX-gCb-lzrEbbY0-UYHwbgpM3O" target="_blank" rel="noopener">CONST (C++中const)</a></li>
<li><a href="http://www.cnblogs.com/xudong-bupt/p/3509567.html" target="_blank" rel="noopener">C++ const用法 尽可能使用const</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的move semantics</title>
    <url>/2020/06/16/cpp-std-move/</url>
    <content><![CDATA[<p>其实是老生常谈的东西，权当复习了。<a id="more"></a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语言面向对象探讨</title>
    <url>/2017/08/19/cpp-oop/</url>
    <content><![CDATA[<p>用这篇文章用来总结C++语言面向对象编程一些问题<a id="more"></a>。</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>在 C++ 中，通过基类的引用（或指针）调用虚函数时，发生动态绑定。引用（或指针）既可以指向基类对象也可以指向子类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。</p>
<p>关键字virtual的作用就是启用动态绑定，我们一般把在基类中需要子类重新定义的函数定义为虚函数（virtual）。</p>
<p>所以，要触发动态绑定，满足两个条件：</p>
<ul>
<li>第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定；</li>
<li>第二，必须通过基类类型的引用或指针进行函数调用。</li>
</ul>
<h2 id="覆盖和多态"><a href="#覆盖和多态" class="headerlink" title="覆盖和多态"></a>覆盖和多态</h2><p>在基类中定义了一个非虚拟函数，然后在子类中又定义了一个同名同参数同返回类型的函数，这就是覆盖了。在子类对象上直接调用这个函数名，只会调用子类中的那个。</p>
<p>子类覆盖了基类的虚函数，就会体现出C++的多态性，常见的表现方式就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。</p>
<p>基类类型引用和指针的关键点在于<strong>静态类型</strong>（在编译时可知的引用类型或指针类型）和<strong>动态类型</strong>（指针或引用所绑定的对象的类型这是仅在运行时可知的）可能不同。引用和指针的静态类型与动态类型可以不同， 这是 C++ 用以支持多态性的基石。</p>
<h2 id="public-protected-private"><a href="#public-protected-private" class="headerlink" title="public,protected,private"></a>public,protected,private</h2><p>在基类中，用户代码可以访问类的public成员而不能访问private成员，private成员只能由基类的成员和友元访问；子类可以基类中访问 public成员而不能访问private成员。</p>
<p>protected：像private成员一样，protected成员不能被类的用户访问；像public成员一样，protected成员可被该类的子类访问；子类只能通过子类对象访问其基类的protected成员，子类对其基类类型对象的protected成员没有特殊访问权限。</p>
<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。</p>
<p>如果类D继承自类B1、B2，而类B1、B2都继承自类A，想要只保存一份A的实例，我们就可以将B1、B2对A的继承定义为虚拟继承。</p>
<h2 id="构造和析构顺序"><a href="#构造和析构顺序" class="headerlink" title="构造和析构顺序"></a>构造和析构顺序</h2><p>子类构造函数首先会调用基类的构造函数，对基类成员初始化，随后对自己的类成员初始化。</p>
<p><strong>注意</strong>：构造函数初始化列表为类的成员提供初始值，它并不指定初始化的执行次序，实际上是根据声明次序初始化类的成员。</p>
<p>析构顺序和构造顺序相反，先调用子类析构函数，随后调用基类的。</p>
<p><strong>注意</strong>：通过 new 从系统的堆空间中分配的，程序运行结束之后，系统是不会自动回收分配给它的空间的，需要程序员手动调用 delete 来释放。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>只在基类中声明，把具体实现留给子类。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将函数定义为纯虚能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的版本决不会调用。</p>
<p>含有（或继承）一个或多个纯虚函数的类是<strong>抽象基类</strong>。</p>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>重载一元操作符如果作为成员函数就没有（显式）形参，如果作为非成员函数就有一个形参。类似地，重载二元操作符定义为成员时有一个形参，定义为非成员函数时有两个形参。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaleItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SaleItem&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> SaleItem&amp; rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> revenue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SaleItem <span class="keyword">operator</span>+(<span class="keyword">const</span> SaleItem&amp; lhs, <span class="keyword">const</span> SaleItem&amp; rhs);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）等操作符必须定义为成员，将这些操作符定义为非成员函数将在编译时标记为错误。</p>
<p>看下面加法操作符重载的实现，要注意加法操作符并不改变参数的状态，而是返回一个新的对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SaleItem <span class="keyword">operator</span>+(<span class="keyword">const</span> SaleItem&amp; lhs, <span class="keyword">const</span> SaleItem&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SaleItem <span class="title">ret</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    ret += rhs;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下面赋值操作符重载的的实现，注意其返回值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SaleItem&amp; SaleItem::<span class="keyword">operator</span>+=(<span class="keyword">const</span> SaleItem&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，赋值操作符与复合赋值操作符（<code>+=,-+,*=,/=</code>等）应返回该对象的引用。</p>
<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>表现形式为<code>A(const A&amp; a)</code>，复制构造函数可用于：</p>
<ul>
<li>根据另一个同类型的对象显式或隐式初始化一个对象。</li>
<li>复制一个对象，将它作为实参传给一个函数。</li>
<li>从函数返回时复制一个对象。</li>
<li>初始化顺序容器中的元素。</li>
<li>根据元素初始化式列表初始化数组元素。</li>
</ul>
<p>三原则：如果类需要析构函数，则它也需要赋值操作符和复制构造函数，这是一个有用的经验法则。</p>
<p>如果要禁止复制，可以在类中显式声明其复制构造函数为<code>private</code>。</p>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>删除指向动态分配对象的指针时，需要运行析构函数在释放对象的内存之前清除对象。处理继承层次中的对象时，指针的静态类型可能与被删除对象的动态类型不同，可能会删除实际指向派生类对象的基类类型指针。</p>
<p>如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际是派生类型的，则没有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数。</p>
<p>一般我们规定即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。</p>
<h2 id="构造函数不能为虚函数"><a href="#构造函数不能为虚函数" class="headerlink" title="构造函数不能为虚函数"></a>构造函数不能为虚函数</h2><p>构造函数不能为虚函数，因为构造函数是在对象完全构造之前运行的，在构造函数运行的时候，对象的动态类型还不完整。vptr变量是在构造函数中进行初始化的。又因为要想执行虚函数必须通过vptr变量找到虚函数表。</p>
<p>内联函数，static函数也不可以为虚函数。</p>
<h2 id="建议构造（析构）函数不调用虚函数"><a href="#建议构造（析构）函数不调用虚函数" class="headerlink" title="建议构造（析构）函数不调用虚函数"></a>建议构造（析构）函数不调用虚函数</h2><p>构造派生类对象时首先运行基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。实际上，此时对象还不是一个派生类对象。</p>
<p>撤销派生类对象时，首先撤销它的派生类部分，然后按照与构造顺序的逆序撤销它的基类部分。</p>
<p>在这两种情况下，运行构造函数或析构函数的时候，对象都是不完整的。为了适应这种不完整，编译器将对象的类型视为在构造或析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象当作基类类型对象对待。</p>
<p>如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型之constructors</title>
    <url>/2017/08/24/cpp-object-model-constructors/</url>
    <content><![CDATA[<p>Stanley B.Lippman-<strong>Inside the C++ Object Model</strong> Chapter 2<a id="more"></a></p>
<h2 id="default-constructor"><a href="#default-constructor" class="headerlink" title="default constructor"></a>default constructor</h2><p>看看这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    <span class="comment">// val和p并不会被初始化为0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f.val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>default constructor只在编译器需要的适合才会自动合成，上面的Foo类即使合成了default constructor也不会把val和p初始化为0，这是程序员的责任，而不是编译器的责任。</p>
<p>一般来说，如果某个类没有显示定义default constructor，那么编译器自动生成一个隐式的implicit default constructor，但这个default constructor是trivial（指浅薄无能，没啥大用处）的；但是有4种情况下，会生成nontrivial default constructor。</p>
<p>（一）带有default constructor的member class objects<br>比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() : x(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时Bar就会生成一个default constructor来处理foo，foo中的x会被初始化，但是初始化s任然是程序员的责任。编译器合成的default constructor只满足编译器的需求，我们永远不要指望编译器能为我们做更多的事情。</p>
<p>如果有多个class member objects，初始化顺序按照它们的声明顺序来。</p>
<p>（二）带有default constructor的base class</p>
<p>（三）带有一个virtual function的class</p>
<p>如果某个类带有virtual function，那么编译器会做两件事情：</p>
<ol>
<li>一个带有virtual function table（虚函数表vtbl）会被编译出来，里面存放class的virtual function地址；</li>
<li>在每一个class对象中，一个额外的pointer member（虚函数表指针vptr）会被合成出来，执行这个vtbl；</li>
</ol>
<p>（四）带有virtual base class的class</p>
<h2 id="copy-constructor"><a href="#copy-constructor" class="headerlink" title="copy constructor"></a>copy constructor</h2><p>有三种情况下，会调用copy constructor：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接对xx赋值为x进行初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>...&#125;;</span><br><span class="line">X x;</span><br><span class="line">X xx = x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 做为函数形参</span></span><br><span class="line">    foo(xx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function">X <span class="title">fb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy constructor显示定义可以如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X::X(<span class="keyword">const</span> X&amp; x);</span><br><span class="line">X::X(<span class="keyword">const</span> X&amp; x, <span class="keyword">int</span> y = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>也可以是多参数，第二个及后面的都有默认值即可。</p>
<p>如果一个类没有explicit copy constructor，那么默认展现出bitwise copy语意，就是直接赋值每个对象的值，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">noun</span><span class="params">(<span class="string">"book"</span>)</span></span>;</span><br><span class="line">String verb = noun;</span><br></pre></td></tr></table></figure>

<p>那么这两个成员的值是一样的：<code>noun.str=verb.str; noun.len=noun.len;</code>。也就是说两个指针指向同一个地方；所以这样的拷贝会经常出现问题，比如两次释放指针指向的内存。</p>
<p>C++规定了以下四种情况下不产生bitwise copy语意：</p>
<ol>
<li>当类内含有一个member object 而后者的类声明中有个复制构造函数时（无论这个构造函数是设计者明确地声明还是编译器合成）。</li>
<li>当类继承于一个基类而后者有已给复制构造函数时（同样的，无论基类的构造函数是设计者明确声明的还是合成的）。</li>
<li>当类声明了一个或多个virtual function（虚函数）时。</li>
<li>当类派生自一个继承串链，其中有一个或多个virtual base class（虚基类）时。</li>
</ol>
<h2 id="NRV优化"><a href="#NRV优化" class="headerlink" title="NRV优化"></a>NRV优化</h2><p>用于函数返回对象时，减少一次构造和析构的开销：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">(<span class="keyword">const</span> X&amp; a, <span class="keyword">const</span> X&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X c;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不开启NRV优化，会有两次构造函数和两次析构函数开销，开启NRV优化后，只有一次构造和析构调用。copy constructor和NRV是相关的，实现explicit copy constructor有助于开启NRV优化（具体看编译器实现，现在大都默认开启）。</p>
<p>协助返回值优化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X foo(const X&amp; a, const X&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return  X(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="member-initialization-list"><a href="#member-initialization-list" class="headerlink" title="member initialization list"></a>member initialization list</h2><p>以下情况，必须使用初始化成员列表：</p>
<ol>
<li>当初始化一个reference member；</li>
<li>当初始化一个const member；</li>
<li>当调用一个base class的constructor，而它拥有一组参数时；</li>
<li>当调用一个member class的constructor，而它拥有一组参数时；</li>
</ol>
<p>注意initialization list实际上是把初始化操作代码插入到任何explicit user code之前（list里的先执行），list中的各项初始化顺序是由class中members的声明顺序决定的。</p>
<p>看这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(<span class="keyword">int</span> val) : j(val), i(j) &#123; &#125;;</span><br><span class="line">    <span class="comment">// 错误，i(j)会先执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(<span class="keyword">int</span> val) : j(val) &#123; i = j; &#125;;</span><br><span class="line">    <span class="comment">// 正确，j(val)会先执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（六）命令模式</title>
    <url>/2017/08/13/design-patterns-command/</url>
    <content><![CDATA[<p>命令模式（Command）用来将“动作的请求者”从“动作的执行者”对象中解耦。<a id="more"></a>把“请求”封装成对象，以便应对不同的请求，下面看它的类图：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/command.png" alt="command"></p>
<p>Client负责创建一个ConcreteCommand，并设置其接受者；</p>
<p>Invoker持有一个命令对象，可以在某个时刻调用其execute()方法；</p>
<p>Command是一个接口，所有具体的命令对象都必须实现这个接口；具体的命令对象定义了动作和接受者之间的绑定关系，调用者只需要调用execute()就可以发出请求，然后由ConcreteCommand调用接受者的一个或多个动作。</p>
<p>Receiver接受者知道如何进行必要的工作，实现这个请求；</p>
<p>看一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令对象，是纯虚基类，</span></span><br><span class="line"><span class="comment">// 所有的“请求命令”要继承这个类。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//virtual ~Command() &#123;&#125;;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现一个具体的命令：负责关闭灯光</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LightOffCommand(Light light);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Light light;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LightOffCommand::LightOffCommand(Light light) : light(light)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LightOffCommand::Execute()</span><br><span class="line">&#123;</span><br><span class="line">    light.Off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一个具体的命令：负责打开灯光：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个命令的具体实例（打开灯），实现Execute函数，</span></span><br><span class="line"><span class="comment">// 调用接受者的动作，以满足请求。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LightOnCommand(Light light);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Light light;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LightOnCommand::LightOnCommand(Light light) : light(light)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Light对象的的On函数</span></span><br><span class="line"><span class="keyword">void</span> LightOnCommand::Execute()</span><br><span class="line">&#123;</span><br><span class="line">    light.On();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们也要实现命令的接受者：灯Light</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令的接受者。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Light();</span></span><br><span class="line">    <span class="comment">//Light(const Light&amp; rhs);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">On</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Off</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Light::On()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"light is on!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Light::Off()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"light is off!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后实现调用者，来完成“请求”：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleRemoteControl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SimpleRemoteControl(Command* cmd);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ButtonOnWasPressed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ButtonoffWasPressed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetCommand</span><span class="params">(Command* cmd)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~SimpleRemoteControl() &#123; <span class="keyword">delete</span> cmd; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command* cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SimpleRemoteControl::SimpleRemoteControl(Command* cmd)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;cmd = cmd; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleRemoteControl::SetCommand(Command* cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;cmd = cmd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleRemoteControl::ButtonOnWasPressed() </span><br><span class="line">&#123; </span><br><span class="line">    cmd-&gt;Execute(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SimpleRemoteControl::ButtonoffWasPressed()</span><br><span class="line">&#123;</span><br><span class="line">    cmd-&gt;Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在调用者SimpleRemoteControl中持有Command对象，通过传递给它不同的具体命令就可以实现不同的命令请求。</p>
<p>比如我们现在要打开灯：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Light light;</span><br><span class="line">Command* c;</span><br><span class="line"><span class="function">LightOnCommand <span class="title">l</span><span class="params">(light)</span></span>;</span><br><span class="line">c = &amp;l;</span><br><span class="line"></span><br><span class="line"><span class="function">SimpleRemoteControl <span class="title">s</span><span class="params">(c)</span></span>;</span><br><span class="line">s.ButtonOnWasPressed();</span><br></pre></td></tr></table></figure>

<p>就可把开灯的具体命令对象传递给调用者，而调用者只需要执行execute即可完成命令请求。</p>
<p>关上灯的办法类似，只需要修改调用者的命令对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LightOffCommand <span class="title">l_off</span><span class="params">(light)</span></span>;</span><br><span class="line">c = &amp;l_off;</span><br><span class="line">s.SetCommand(c);</span><br><span class="line">s.ButtonoffWasPressed();</span><br></pre></td></tr></table></figure>

<p>我们可以看到命令模式的本质是对命令进行封装，将发出请求的对象和执行请求的对象分割开；通过引入抽象命令接口，两种通过这个接口进行交互，使得发出请求的对象针对这个抽象接口进行编程，而并不要知道该命令对象是怎么实现的。</p>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>What&#39;s new in C++ 11?</title>
    <url>/2017/09/03/cpp11-new-features/</url>
    <content><![CDATA[<p>A qucik glimpse of C++ 11: <a id="more"></a></p>
<h2 id="type-inference"><a href="#type-inference" class="headerlink" title="type inference"></a>type inference</h2><p><code>auto</code>：自动类型推断。不用显示指定变量类型，编译器会自动推断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;        <span class="comment">// i is an int</span></span><br><span class="line"><span class="keyword">auto</span> l = <span class="number">42L</span>L;      <span class="comment">// l is an long long</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> foo(); <span class="comment">// p is a foo*</span></span><br></pre></td></tr></table></figure>

<p>使用auto代码更加简洁，比如以前要这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itr = myvec.cbegin(); itr != myvec.cend(); ++itr)</span><br></pre></td></tr></table></figure>

<p>现在这么写即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = myvec.cbegin(); itr != myvec.cend(); ++itr)</span><br></pre></td></tr></table></figure>

<p>甚至可以这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : myvec)</span><br></pre></td></tr></table></figure>

<p><code>decltype</code>：在编译时期推断表达式的类型，而不计算表达式的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> some_int;</span><br><span class="line"><span class="keyword">decltype</span>(some_int) other_integer_variable = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="range-based-for-loop"><a href="#range-based-for-loop" class="headerlink" title="range-based for loop"></a>range-based for loop</h2><p>如果我们不关心元素的下标的话，对for循环可以这么使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// double the value of each element in my_array:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : my_array) &#123;</span><br><span class="line">    x *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// similar but also using type inference for array elements</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : my_array) &#123;</span><br><span class="line">    x *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lambda-functions-and-expressions"><a href="#lambda-functions-and-expressions" class="headerlink" title="lambda functions and expressions"></a>lambda functions and expressions</h2><p>C++ 11现在支持匿名函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> print_it = [](<span class="keyword">int</span> n) -&gt;<span class="keyword">void</span> &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(<span class="built_in">std</span>::begin(v), <span class="built_in">std</span>::end(v), print_it);</span><br></pre></td></tr></table></figure>

<p>标准格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123; function_body &#125;</span><br></pre></td></tr></table></figure>

<p>[]叫做捕获说明符，表示一个lambda表达式的开始。lambda函数能够捕获lambda函数外的具有自动存储时期的变量。函数体与这些变量的集合合起来叫Closures。</p>
<ul>
<li>[] 不捕获任何变量</li>
<li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用</li>
<li>[=] 捕获外部作用域中所有变量，并拷贝一份在函数体中使用</li>
<li>[=, &amp;foo] 捕获外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo变量使用引用</li>
<li>[bar] 捕获bar变量并且拷贝一份在函数体重使用，同时不捕获其他变量</li>
<li>[x, &amp;y] x按值传递，y按引用传递</li>
<li>[this] 捕获当前类中的this指针。如果已经使用了&amp;或者=就默认添加此选项。</li>
</ul>
<h2 id="explicit-overrides-and-final"><a href="#explicit-overrides-and-final" class="headerlink" title="explicit overrides and final"></a>explicit overrides and final</h2><p>在C++ 11中可以用<code>override</code>关键字显示的指定子类重写父类的虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">some_func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">some_func</span><span class="params">(<span class="keyword">float</span>)</span> override</span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">some_func</span><span class="params">(<span class="keyword">float</span>)</span> override</span>; <span class="comment">// ill-formed - doesn't override a base class method</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用<code>final</code>关键字来阻止子类重写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> final</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// ill-formed because the virtual function Base::f has been marked final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="null-pointer-constant"><a href="#null-pointer-constant" class="headerlink" title="null pointer constant"></a>null pointer constant</h2><p>之前我们可以用NULL来代表空指针，而NULL被定义为0或者<code>((void*) 0)</code>。这就导致了函数重载过程中的一些歧义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由于C++禁止了<code>void *</code>到其他类型指针的隐式转换，因此<code>foo(NULL)</code>会默认调用的是<code>foo(int)</code>。这并不是我们想要的结果。</p>
<p>C++ 11用<code>nullptr</code>来代表空指针，<code>nullpt</code>和任何指针类型以及类成员指针类型的空值之间可以发生隐式类型转换，同样也可以隐式转换为bool型（取值为false）。但是不存在到整形的隐式类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* pc = <span class="literal">nullptr</span>;     <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">int</span> * pi = <span class="literal">nullptr</span>;     <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">int</span>    i = <span class="literal">nullptr</span>;     <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">foo(pc);           <span class="comment">// call foo(char *)</span></span><br></pre></td></tr></table></figure>

<h2 id="hash-tables"><a href="#hash-tables" class="headerlink" title="hash tables"></a>hash tables</h2><p>终于把unordered associative containers加入了标准库。</p>
<ul>
<li>std::unordered_map</li>
<li>std::unordered_set</li>
<li>std::unordered_multimap</li>
<li>std::unordered_multiset</li>
</ul>
<p>对比之前的<code>std::map</code>和<code>std::set</code>，新的采用了哈希表来实现，链地址法处理碰撞冲突，而且容器中元素是无序的。</p>
<h2 id="smart-pointers"><a href="#smart-pointers" class="headerlink" title="smart pointers"></a>smart pointers</h2><p>C++ 11提供了新的<code>std::unique_ptr</code>，改进了TR1中的<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。注意<code>auto_ptr</code>已经弃用。</p>
<h2 id="uniform-initialization"><a href="#uniform-initialization" class="headerlink" title="uniform initialization"></a>uniform initialization</h2><p>之前我们只能对结构体和POD使用aggregate initializers，像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object scalar = &#123;<span class="number">0.43f</span>, <span class="number">10</span>&#125;; <span class="comment">// One Object, with first=0.43f and second=10</span></span><br></pre></td></tr></table></figure>

<p>C++ 11拓展了这一初始化方式，使其可以在任意类型使用，比如标准容器vector可以如下初始化了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v = &#123; <span class="string">"xyzzy"</span>, <span class="string">"plugh"</span>, <span class="string">"abracadabra"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v(&#123; <span class="string">"xyzzy"</span>, <span class="string">"plugh"</span>, <span class="string">"abracadabra"</span> &#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v&#123; <span class="string">"xyzzy"</span>, <span class="string">"plugh"</span>, <span class="string">"abracadabra"</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>再比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AltStruct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AltStruct(<span class="keyword">int</span> x, <span class="keyword">double</span> y) : x_&#123;x&#125;, y_&#123;y&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x_;</span><br><span class="line">        <span class="keyword">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AltStruct var2&#123;<span class="number">2</span>, <span class="number">4.3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="initializer-lists"><a href="#initializer-lists" class="headerlink" title="initializer lists"></a>initializer lists</h2><p>通过引入<code>std::initializer_list</code>允许如下的初始化方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyNumber(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; &amp;v) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itm : v) </span><br><span class="line">            mVec.push_back(itm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itm : mVec) </span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; itm &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyNumber mn = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="explicitly-defaulted-and-deleted-special-member-functions"><a href="#explicitly-defaulted-and-deleted-special-member-functions" class="headerlink" title="explicitly defaulted and deleted special member functions"></a>explicitly defaulted and deleted special member functions</h2><p>C++ 11中可以显示的指定或者删除a default constructor, a copy constructor, a copy assignment operator (operator=), and a destructor了。以前我们要禁止某个类的拷贝，需要声明该类的copy constructor和copy assignment operator为private，现在直接指定为<code>delete</code>即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NonCopyable</span> &#123;</span></span><br><span class="line">    NonCopyable() = <span class="keyword">default</span>;</span><br><span class="line">    NonCopyable(<span class="keyword">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用<code>defalut</code>显示指定默认构造器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeType</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SomeType() = <span class="keyword">default</span>; <span class="comment">//The default constructor is explicitly stated.</span></span><br><span class="line">    SomeType(OtherType value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以用<code>delete</code>指定某个成员函数特定的参数不能调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoInt</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在调用<code>f(int)</code>会被编译器拒绝。</p>
<h2 id="Rvalue-References-and-move-constructor"><a href="#Rvalue-References-and-move-constructor" class="headerlink" title="Rvalue References and move constructor"></a>Rvalue References and move constructor</h2><p>右值引用是用来支持std::move语义的，move语义是指将一个同类型的对象A中的资源（可能是在堆上分配，也可能是一个文件句柄或者其他系统资源）搬移到另一个同类型的对象B中，解除对象A对该资源的所有权。这样可以减少不必要的临时对象的构造、拷贝以及析构等动作。</p>
<p>为了支持move语义，C++ 11新增了move constructor，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Moveable() :i(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>)) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"default"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~Moveable() &#123; <span class="keyword">delete</span> i; &#125;</span><br><span class="line">    Moveable(<span class="keyword">const</span> Moveable &amp; m) : i(<span class="keyword">new</span> <span class="keyword">int</span>(*m.i)) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Moveable(Moveable &amp;&amp; m) :i(m.i)  <span class="comment">// move constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">        m.i = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么我们如下调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Moveable a;</span><br><span class="line"><span class="function">Moveable <span class="title">b</span><span class="params">(<span class="built_in">std</span>::move(a))</span></span>;</span><br></pre></td></tr></table></figure>

<p>只会输出default和move。</p>
<p>参考资料：<br><a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/C%2B%2B11</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础复习总结</title>
    <url>/2017/08/01/database-review/</url>
    <content><![CDATA[<p>本文用来记录一些数据库相关的基础知识。<a id="more"></a></p>
<h3 id="数据库-模型"><a href="#数据库-模型" class="headerlink" title="数据库 模型"></a>数据库 模型</h3><ul>
<li>关系模型：关系数据模型是以集合论中的关系概念为基础发展起来的。关系模型中无论是实体还是实体间的联系均由单一的结构类型–关系来表示。在实际的关系数据库中的关系也称表。一个关系数据库就是由若干个表组成。</li>
<li>层次模型：用树型（层次）结构表示实体类型及实体间联系的数据模型称为层次模型。</li>
<li>网状模型：用网络结构表示实体类型及其实体之间联系的模型。顾名思义，一个事物和另外的几个都有联系，这样构成一张网状图。</li>
</ul>
<h3 id="数据库-事务"><a href="#数据库-事务" class="headerlink" title="数据库 事务"></a>数据库 事务</h3><p>特性：</p>
<ul>
<li>原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。</li>
<li>一致性：事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。</li>
<li>隔离性：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。</li>
<li>持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。</li>
</ul>
<h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul>
<li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li>
<li>实体完整性：关系的主关键字不能重复也不能取空值</li>
<li>参照完整性：是定义建立关系之间联系的主关键字与外部关键字引用的约束条件</li>
<li>用户自定义完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li>
</ul>
<h3 id="数据库三级模式"><a href="#数据库三级模式" class="headerlink" title="数据库三级模式"></a>数据库三级模式</h3><ul>
<li>外模式：外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语(Data Manipulation Language，DML)对这些数据记录进行操作。外模式反映了数据库的用户观。</li>
<li>概念模式：又称概念模式或逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的，体现、反映了数据库系统的整体观。</li>
<li>内模式：内模式又称存储模式，对应于物理级，它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。</li>
</ul>
<h3 id="数据库-视图"><a href="#数据库-视图" class="headerlink" title="数据库 视图"></a>数据库 视图</h3><p>视图（View）是从一个或多个表（或视图）导出的表。视图与表（有时为与视图区别，也称表为基本表——Base Table）不同，视图是一个虚表，即视图所对应的数据不进行实际存储，数据库中只存储视图的定义，在对视图的数据进行操作时，系统根据视图的定义去操作与视图相关联的基本表。</p>
<p>作用：简单性。看到的就是需要的。视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。安全性。通过视图用户只能查询和修改他们所能见到的数据。数据库中的其它数据则既看不见也取不到，通过视图，用户可以被限制在数据的不同子集上。</p>
<p>如果视图定义中有如下子句则不能更新：</p>
<p>1.分组 使用group by 和 Having<br>2.联结（选项B）<br>3.子查询<br>4.并集<br>5.聚集函数 MAX MIN COUNT AVG（选项A）<br>6.DISTINCT（选项D）<br>7.导出列</p>
<h3 id="数据库-索引"><a href="#数据库-索引" class="headerlink" title="数据库 索引"></a>数据库 索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p>
<p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<p>索引的实现通常使用B树及其变种B+树。</p>
<p>B树定义：（来自算法导论第18章）</p>
<ul>
<li>每个结点x有以下域：<ol>
<li>n，当前存存储在结点x中的关键字数。</li>
<li>n个关键字本身，以非降序存放，因此key[1] &lt;= key[2] &lt;= … &lt;= key[n]。</li>
<li>leaf[x]，是一个bool值，如果x是叶子节点则为true，如果x为内结点，则false。</li>
</ol>
</li>
<li>每个结点x还包含n+1个指向其子女的指针，p[1]，p[2]，···，p[n+1]；</li>
<li>各个关键字key[n]对各子树的关键字范围加以划分，如果k[i]是存储在以p[i]为根的子树中的关键字，那么有：k[1] &lt;= key[1] &lt;= k[2] &lt;= key[2] &lt;= ··· &lt;= key[n] &lt;= k[n+1]。</li>
<li>每个叶子节点的深度相同，都是树的高度h。</li>
<li>每个结点能包含的关键字都有一个上界和下界。每个非根的内结点最少有t个子女（t&gt;=2），每个非根的内结点至少有t-1个关键字；每个结点可包含最多2t-1个关键字。</li>
</ul>
<p>B+树与B树不同点在于：</p>
<ul>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针p[i]，指向关键字值属于[k[i], k[i+1])的子树；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ul>
<p>此外：B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中）。</p>
<p>B+树优点：（更适合操作系统的文件索引和数据库索引）</p>
<ul>
<li>由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。</li>
<li>B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li>
</ul>
<p>索引种类：</p>
<ul>
<li>唯一索引：唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</li>
<li>主键索引：数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</li>
<li>聚集索引： 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同（就是说B+树中的叶子节点就是数据结点）。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。对于频繁更新和修改的列不适合简历聚集索引。</li>
<li>非聚集索引：索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。（B+树中的叶子节点不包含数据页，而是一个指针指向具体的数据）</li>
</ul>
<h3 id="脏读-幻读-不可重复读"><a href="#脏读-幻读-不可重复读" class="headerlink" title="脏读 幻读 不可重复读"></a>脏读 幻读 不可重复读</h3><p>数据库锁：实现并发控制，保证多个用户操控同一数据库时不发生数据不一致现象。</p>
<p>脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<blockquote>
<pre><code>事务1：更新一条数据
----&gt;事务2：读取事务1更新的记录
事务1：调用commit进行提交</code></pre></blockquote>
<p>幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同。</p>
<blockquote>
<pre><code>事务1：查询表中所有记录
----&gt;事务2：插入一条记录
----&gt;事务2：调用commit进行提交
事务1：再次查询表中所有记录</code></pre></blockquote>
<p>不可重复读：在同一事务中，两次读取同一数据，得到内容不同。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
<blockquote>
<pre><code>事务1：查询一条记录
----&gt;事务2：更新事务1查询的记录
----&gt;事务2：调用commit进行提交
事务1：再次查询上次的记录</code></pre></blockquote>
<p>读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁。读取时候不允许其他事物修改该数据，不管数据在事务过程中读取多少次，数据都是一致的，避免了不可重复读问题。</p>
<h3 id="MYSQL数据引擎"><a href="#MYSQL数据引擎" class="headerlink" title="MYSQL数据引擎"></a>MYSQL数据引擎</h3><p><strong>MyISAM引擎</strong>：它是MYSQL的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行Insert插入和Update更新语句时，即执行写操作的时候需要锁定这个表。所以会导致效率会降低。不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将MyIASM作为数据库引擎的首先。</p>
<p>MyISAM引擎的索引结构为<strong>B+Tree</strong>，中B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的<strong>非聚集索引</strong>。</p>
<p><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。它本身实际上是基于MYSQL后台的完整的系统。MYSQL运行的时候，Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是，该引擎是不支持全文搜索的。同时，启动也比较的慢，它是不会保存表的行数的。当进行Select count(*) from table指令的时候，需要进行扫描全表。所以当需要使用数据库的事务时，该引擎就是首选。由于锁的粒度小，写操作是不会锁定全表的。所以在并发度较高的场景下使用会提升效率的。</p>
<p>Innodb的索引文件本身就是数据文件，即<strong>B+Tree</strong>的数据域存储的就是实际的数据，这种索引就是<strong>聚集索引</strong>。</p>
<p>大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的。</p>
<p>大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候。</p>
<h3 id="MYSQL事务隔离级别"><a href="#MYSQL事务隔离级别" class="headerlink" title="MYSQL事务隔离级别"></a>MYSQL事务隔离级别</h3><p>MYSQL数据库为我们提供的四种隔离级别：</p>
<ol>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>
<li>Read committed (读已提交)：可避免脏读的发生。</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>
</ol>
<p>在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p>查看当前事物隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br></pre></td></tr></table></figure>

<p>设置隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>  [glogal | <span class="keyword">session</span>]  <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="string">'隔离级别名称'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> tx_isolation = <span class="string">'隔离级别名称'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="MYSQL锁"><a href="#MYSQL锁" class="headerlink" title="MYSQL锁"></a>MYSQL锁</h3><p>表锁： 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低；</p>
<p>行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高；</p>
<p>表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许。</p>
<p>行级,，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。</p>
<p>MyISAM只支持表锁，有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。就是说对MyISAM表进行读操作时，它不会阻塞其他用户对同一表的读请求，但会阻塞 对同一表的写操作；而对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作。因此MyISAM表的读和写是串行的，即在进行读操作时不能进行写操作，反之也是一样。</p>
<p>InnoDB与MyISAM的最大不同有两点：InnoDB支持一是支持事务（TRANSACTION）；二是采用了行级锁。</p>
<p>InnoDB有两种模式的行锁：</p>
<ul>
<li>共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>注意InnoDB行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（七）适配器模式</title>
    <url>/2017/08/15/design-patterns-adapter/</url>
    <content><![CDATA[<p>适配器模式（Adapter）是将一个类的接口，转换成客户期望的另一个接口<a id="more"></a>，适配器让原本接口不兼容的类可以合作无间。</p>
<p>先看一个简单的例子：</p>
<p>我们有一个Duck类和Turkey类，我们可以利用适配器模式把Turkey类变成Duck类。</p>
<p>先看Duck类实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Duck 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Quck</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Duck() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mallardduck</span> :</span> <span class="keyword">public</span> Duck</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Quck</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"quck!!\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"i'm flying!!\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Turkey类实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Turkey 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turkey</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Gobble</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Turkey() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> :</span> <span class="keyword">public</span> Turkey</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gobble</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"gobble!!\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"i can only fly a short distance!!\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>利用适配器来转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把Turkey变成Duck的适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> :</span> <span class="keyword">public</span> Duck</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TurkeyAdapter(Turkey* turkey) : turkey(turkey) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Quck</span><span class="params">()</span> </span>&#123; turkey-&gt;Gobble(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123; turkey-&gt;Fly(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Turkey* turkey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在代码中可以看到，首先你的适配器类要实现想转换的类型（Duck类）接口，然后适配器类里面要用一个被适配对象（Turkey类）的引用，然后利用这个印用来相应的表现出类似Duck类的行为。</p>
<p>看一个简单的类图：<br><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/adapter.png" alt="adapter"></p>
<p>客户只看到目标接口，而适配器实现了目标接口；适配器与被适配者组合；所有的请求都委托给被适配者。</p>
<p>因此我们可以如下来使用适配器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个Turkey对象</span></span><br><span class="line">Turkey* turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line"><span class="comment">// 将turkey包装到适配器中，这样他表现出来的就是Duck对象了</span></span><br><span class="line">Duck* turkey_adapter = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line"><span class="comment">// 测试这个“适配Duck”的行为</span></span><br><span class="line">turkey_adapter-&gt;Quck();</span><br><span class="line">turkey_adapter-&gt;Fly();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（三）装饰者模式</title>
    <url>/2017/08/09/design-patterns-decorator/</url>
    <content><![CDATA[<p>装饰者模式（decorator）指的是动态的将责任附加到对象上<a id="more"></a>，若要扩展功能，装饰者模式提供了比继承更有弹性的替代方案。先来看看它的类图：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/decorator.png" alt="decorator"></p>
<p>ConcreteComponent是我们将要动态的加上新行为的对象，也就是被装饰者，它扩展自Component；</p>
<p>Decorator是具体装饰者共同实现的接口，也可以是抽象类。</p>
<p>每个具体的装饰者Decorator都有一个组件Component，也就是说，装饰者有一个实例变量以保存某个Component；装饰者可以扩展Component的状态。</p>
<p>可以注意到图中，我们的装饰者和被装饰者都扩展自Component，也就是有共同的基类，这是为什么呢？其实我们这里使用的继承并不是要继承它的“行为”，而只是为了达到<strong>类型匹配</strong>，因为装饰者必须能取代被装饰者。</p>
<p>下面来看一个具体的例子：</p>
<p>假定现在饮料Beverage是一个组件Component，而几种咖啡Espresso和HouseBlend是具体的组件，它们继承自Beverage，也就是被装饰的对象，每个人喝咖啡都有不同的习惯，可能会在咖啡里面加一些配料CondimentDecorator，也就是说这些具体的配料就是装饰者。</p>
<p>我们这么编写Beverage类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beverage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Beverage() : description(<span class="string">"unknow beverage"</span>) &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetDescription</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> description; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Beverage() &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次用配料装饰咖啡后我们都会重写Cost函数，表示当前的花费。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的被装饰的对象Espresso</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> :</span> <span class="keyword">public</span> Beverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Espresso() &#123; description = <span class="string">"espresso"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1.99</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的被装饰的对象HouseBlend</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBlend</span> :</span> <span class="keyword">public</span> Beverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HouseBlend() &#123; description = <span class="string">"houseblend"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.89</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面看配料对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装饰者类的基类（抽象类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> :</span> <span class="keyword">public</span> Beverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetDescription</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给出两种具体的配料（装饰者）Macha和Whip：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的装饰者类Mocha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> :</span> <span class="keyword">public</span> CondimentDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mocha(Beverage* beverage) : beverage(beverage) &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetDescription</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;GetDescription().append(<span class="string">", Mocha"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.20</span> + beverage-&gt;Cost(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Beverage* beverage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的装饰者类Whip</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whip</span> :</span> <span class="keyword">public</span> CondimentDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Whip(Beverage* beverage) : beverage(beverage) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;GetDescription().append(<span class="string">", Whip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> beverage-&gt;Cost() + <span class="number">0.10</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Beverage* beverage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么现在我们点了一杯Espresso，然后打印它的价格（Cost）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Beverage* bev = <span class="keyword">new</span> Espresso();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bev-&gt;GetDescription() &lt;&lt; <span class="string">", "</span> &lt;&lt; bev-&gt;Cost() &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>

<p>开始加一点配料，先加Mocha吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bev = <span class="keyword">new</span> Mocha(bev);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bev-&gt;GetDescription() &lt;&lt; <span class="string">", "</span> &lt;&lt; bev-&gt;Cost() &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>

<p>再来点Whip更好喝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bev = <span class="keyword">new</span> Whip(bev);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bev-&gt;GetDescription() &lt;&lt; <span class="string">", "</span> &lt;&lt; bev-&gt;Cost() &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>

<p>我们最终得到的花费就是1.99+0.20+0.10，你是否看懂了呢？</p>
<p>我们不断地用装饰者来包装组件，而实际上它还是一种Beverage，这就是我们前面所说的类型匹配，而每次包装后，组件都有了一些新的行为，它的行为来自基本组件和装饰者，实际上这是利用了组合而不是继承，这样我们就可以对组件在运行时进行动态的扩展。</p>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（五）单件模式</title>
    <url>/2017/08/11/design-patterns-singleton/</url>
    <content><![CDATA[<p>单件模式（singleton）用来创建独一无二的对象<a id="more"></a>，确保某个类在程序运行期间最多只能生成一个对象，也是比较容易理解的一个设计模式。</p>
<p>我们来看一看用C++实现单例模式的具体例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2017.8.19更新，更改了一些错误</span></span><br><span class="line"><span class="comment">// 线程安全的写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MyClass* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    MyClass();</span><br><span class="line">    MyClass(<span class="keyword">const</span> MyClass&amp; rhs);</span><br><span class="line">    MyClass <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MyClass* myclasss_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::MyClass() </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass* MyClass::myclass_instance = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">MyClass* MyClass::GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> myclass_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的代码，我们可以知道单件模式的实现基于以下两点：</p>
<ul>
<li>不直接用类的构造函数，而另外提供一个Public的静态方法来构造类的实例。通常这个方法取名为GetInstance。Public保证了它的全局可见性，静态方法保证了不会创建出多余的实例。</li>
<li>将类的构造函数设为Private，即将构造函数”隐藏”起来，任何企图使用构造函数创建实例的方法都将报错。这样就阻止了开发人员绕过上面的Instance方法直接创建类的实例。</li>
</ul>
<p>单件模式的使用场景是要求某个类对象只能有一个实例，比如线程池，缓存，打印机对象，数据库连接对象和对话框等。此外单件模式也提供了一个全局的访问点，因为静态成员函数是直接通过类名来访问，这看起来就和全局变量一样。但是全局变量并不能替代单件模式，原因有二：大量使用全局对象会使得程序质量降低，而且有些编程语言例如C#，根本就不支持全局变量。其二，全局对象的方法并不能阻止人们将一个类实例化多次，除了类的全局实例外，开发人员仍然可以通过类的构造函数创建类的多个局部实例。</p>
<hr>
<p>2017.8.30更新</p>
<p>在C++ 11中，局部static变量是线程安全的，一个更好的写法，避免了用new分配内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> S&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> S instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        S() &#123;&#125;</span><br><span class="line">        S(S <span class="keyword">const</span>&amp;); <span class="comment">// Don't implement.</span></span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>=(S <span class="keyword">const</span>&amp;); <span class="comment">// Don't implement.</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/1008019/c-singleton-design-pattern" target="_blank" rel="noopener">stack overflow: C++ Singleton design pattern</a></li>
</ol>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础复习总结</title>
    <url>/2017/07/24/cpp-review/</url>
    <content><![CDATA[<p>这几天复习了一下C++语言基础，总结了一些容易犯错（忽视）的地方<a id="more"></a>，记录如下：</p>
<hr>
<p><em>持续完善中…</em></p>
<hr>
<h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><p>比如<code>char c1={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}</code>和<code>char c2[]=&quot;abc&quot;</code>的区别，<code>sizeof(c1)=3</code>，<code>sizeof(c2)=4</code>。但是strlen函数不会计算<code>&#39;\0&#39;</code>。</p>
<p>还有<code>char *p=&quot;abc&quot;</code>和<code>char c3[]=&quot;abc&quot;</code>的区别，前者的<code>&quot;abc&quot;</code>是存放在静态数据区的，不可以被修改，而后者在栈区，可以修改。</p>
<p>注意我们自己在使用的过程中，要用这种形式的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ca2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> ca3[] = <span class="string">"C++"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"C++"</span>;</span><br></pre></td></tr></table></figure>

<p>都要有字符串结束标志（第一个是明确指定，后两个系统会自动加上）。</p>
<h2 id="char-p-5-和char-p-5-区别"><a href="#char-p-5-和char-p-5-区别" class="headerlink" title="char *p[5]和char (*p)[5]区别"></a><code>char *p[5]</code>和<code>char (*p)[5]</code>区别</h2><p>前者是数组，存放5个char *类型数据；后者是一个指针，指向一个长度为5的数组。<br>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// array of size 3, each element is an array of ints of size 4</span></span><br><span class="line"><span class="comment">// wrong: int *p = ia;</span></span><br><span class="line"><span class="keyword">int</span> (*ip)[<span class="number">4</span>] = ia; <span class="comment">// ip points to an array of 4 ints</span></span><br><span class="line">ip = &amp;ia[<span class="number">2</span>]; <span class="comment">// ia[2] is an array of 4 ints</span></span><br></pre></td></tr></table></figure>

<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>引用在定义时必须要初始化，否则会出错，引用始终指向同一个特定的对象，给引用赋值修改的是该引用所关联的对象的值，而并不是使引用与另一个对象关联。</p>
<h2 id="区别a-1和-amp-a-1"><a href="#区别a-1和-amp-a-1" class="headerlink" title="区别a+1和(&amp;a)+1"></a>区别a+1和(&amp;a)+1</h2><p>如果int a[3]={1,2,3}的话，a+1指向数组的第二个数，(&amp;a)+1指向3后面的一个位置，在数组外。</p>
<h2 id="size-t和ptrdiff-t"><a href="#size-t和ptrdiff-t" class="headerlink" title="size_t和ptrdiff_t"></a><code>size_t</code>和<code>ptrdiff_t</code></h2><p>数组长度是<code>size_t</code>类型，unsigned；<code>ptrdiff_t</code>是指针的差值类型，signed，都是和机器相关的类型。</p>
<h2 id="const和指针"><a href="#const和指针" class="headerlink" title="const和指针"></a>const和指针</h2><p><code>const int *p</code>，const限定了<code>*p</code>所指向的对象，而不是p，等同于<code>int const *p</code>；</p>
<p><code>int *const p</code>，const限定了p，p不可变；</p>
<p><code>const int *const p</code>，两个都限定，不可变；</p>
<p>不允许把const对象的地址赋给一个非const指针；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// wrong: double *ptr = &amp;pi;</span></span><br></pre></td></tr></table></figure>

<p>允许把非 const 对象的地址赋给指向 const 对象的指针；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp; pi;</span><br><span class="line"><span class="comment">// 此时*cptr不可变，cptr可变</span></span><br></pre></td></tr></table></figure>

<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>指针函数是指返回值是指针的函数，即本质是一个函数。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>; <span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="keyword">int</span> (*f) (<span class="keyword">int</span> x); <span class="comment">// 声明一个函数指针</span></span><br><span class="line">f = &amp;func; <span class="comment">// 将函数地址赋给函数指针</span></span><br></pre></td></tr></table></figure>

<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>我们举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"12345"</span>; <span class="comment">// sizeof(str) = 6</span></span><br><span class="line"><span class="keyword">char</span> *p = str; <span class="comment">//sizeof(p) = 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]; <span class="comment">//sizeof(a) = 5*4 = 20</span></span><br></pre></td></tr></table></figure>

<p>如果把字符数组当函数参数的话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么输出还是4。</p>
<p>还要注意另一种写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1[<span class="number">3</span>] = &#123; <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span> &#125;; <span class="comment">// sizeof(p1) = 3*4 = 12</span></span><br><span class="line"><span class="keyword">char</span> **p2 = p1; <span class="comment">// sizeof(p2) = 4</span></span><br></pre></td></tr></table></figure>

<h2 id="实现strcpy"><a href="#实现strcpy" class="headerlink" title="实现strcpy()"></a>实现strcpy()</h2><p>在头文件cstring里面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值：目标串的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于出现异常的情况ANSI-C99标准并未定义，故由实现者决定返回值，通常为NULL。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：des为目标字符串，source为原字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// while((*des++=*source++));的解释：赋值表达式返回左操作数，所以在赋值'\0'后，循环停止。</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* des,<span class="keyword">const</span> <span class="keyword">char</span>* source)</span></span></span><br><span class="line"><span class="function">　</span></span><br><span class="line"><span class="function"></span>&#123;    　</span><br><span class="line">    <span class="keyword">char</span>* r=des;</span><br><span class="line"></span><br><span class="line">    assert((des != <span class="literal">NULL</span>) &amp;&amp; (source != <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((*r++ = *source++)!=<span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现memcpy"><a href="#实现memcpy" class="headerlink" title="实现memcpy()"></a>实现memcpy()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 考虑内存重叠的实现</span></span><br><span class="line"><span class="comment">// 也可使用memmove</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert((dest != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *d;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dest &gt; (src+size)) || (dest &lt; src))</span><br><span class="line">    &#123;</span><br><span class="line">        d = dest;</span><br><span class="line">        s = src;</span><br><span class="line">        <span class="keyword">while</span> (count--)</span><br><span class="line">            *d++ = *s++;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* overlap */</span></span><br><span class="line">    &#123;</span><br><span class="line">        d = (<span class="keyword">char</span> *)(dest + count - <span class="number">1</span>); <span class="comment">/* offset of pointer is from 0 */</span></span><br><span class="line">        s = (<span class="keyword">char</span> *)(src + count <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (count --)</span><br><span class="line">            *d-- = *s--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>strcpy和memcpy主要有以下3方面的区别。</p>
<ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ol>
<h2 id="动态创建数组"><a href="#动态创建数组" class="headerlink" title="动态创建数组"></a>动态创建数组</h2><p>在编译期间不需要知道数组的长度，运行时才确定，分配在堆中。分配：<code>int *p = new int[10];</code>，释放：<code>delete [] p;</code>。</p>
<p>new和delete搭配，new []和delete []搭配使用。</p>
<p>执行delete p以后，p执行的内存已经被释放，为了防止悬垂指针，要重设指针的值（p = 0）。</p>
<h2 id="自增-i和i"><a href="#自增-i和i" class="headerlink" title="自增++i和i++"></a>自增++i和i++</h2><p>建议只在必要时才使用后置操作符，多使用前置操作符，不会造成性能的损失。</p>
<p>一个优先级问题：<code>*iter++</code>等于<code>*(iter++)</code>，iter++使iter加1，然后返回iter原值的副本作为该表达式的结果。因此，解引用操作<code>*</code>的操作数是iter未加1前的副本。</p>
<h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p>格式一般为<code>cast-name&lt;type&gt;(expression);</code></p>
<p><code>static_cast</code>：编译器隐式执行的任何类型转换都可以由 static_cast 显式完成。当需要将一个较大的算术类型赋值给较小的类型时，使用强制转换非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不关心潜在的精度损失。</p>
<p><code>dynamic_cast</code>：支持运行时识别指针或引用所指向的对象，将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理。注意：基类对象若没有虚函数，会编译出错。</p>
<p><code>const_cast</code>：转换掉表达式的const属性。</p>
<p><code>reinterpret_cast</code>：通常为操作数的位模式提供较低层次的重新解释。</p>
<h2 id="内联函数的理解"><a href="#内联函数的理解" class="headerlink" title="内联函数的理解"></a>内联函数的理解</h2><p>内联机制适用于优化小的、只有几行的而且经常被调用的函数；</p>
<p>内联对于编译器来说只是一个建议，编译器可以选择忽略这个建议；</p>
<p>内联的原理：编译器通过使用函数的定义体来替代函数调用语句，在编译阶段执行；</p>
<p>内联函数通过避免函数调用所带来的开销来提高你程序的运行速度；</p>
<p>因为代码的扩展，内联函数增大了可执行程序的体积。</p>
<h2 id="const和define宏"><a href="#const和define宏" class="headerlink" title="const和define宏"></a>const和define宏</h2><ul>
<li>define：在预处理阶段进行替换</li>
<li>const：在编译时确定其值</li>
<li>define：无类型，不进行类型安全检查，可能会产生意想不到的错误</li>
<li>const：有数据类型，编译时会进行类型检查</li>
<li>define：不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大</li>
<li>const：在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>具有相同的名字而形参表不同（形参类型和个数）</p>
<p>对于const形参：仅当形参是引用或指针时，形参是否为 const 才有影响。</p>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><p>vector list deque</p>
<p>stack queue priority_queue</p>
<p>迭代器：只有random access迭代器才指出<code>+=</code>，比如vector deque string；而list set map是bidiretional迭代器。支持<code>++</code>和<code>--</code>。</p>
<h2 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h2><p><code>map</code> <code>set</code>：底层用R-B tree使用</p>
<p><code>multimap</code> <code>multiset</code>(不常用)：Key值可以重复</p>
<p><code>unordered_map</code> <code>unordered_set</code> (C++ 11)：底层用hash table实现</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>struct，class，union都存在内存对齐。</p>
<p>对于空的<code>class A { };</code>，sizeof(A) = 1`。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>sizeof(B) = 8</code>，<code>sizeof(C) = 12</code>。</p>
<p>对齐规则：</p>
<ul>
<li>第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照<code>#pragma pack</code>指定的数值和这个数据成员自身长度中，比较小的那个进行。</li>
<li>在数据成员完成各自对齐之后，类(结构或联合)本身也要进行对齐，对齐将按照<code>#pragma pack</code>指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</li>
<li>若<code>#pragma pack</code>未指定，则最后按照以结构体中最长的成员的长度来对齐。</li>
</ul>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>对于函数内部的static变量，也就是静态局部变量，只在第一次调用时执行初始化，始终驻留在全局区内，直到程序运行结束。静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化)。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plus_va</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> va = <span class="number">0</span>;</span><br><span class="line">    va += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; va &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    plus_va();</span><br></pre></td></tr></table></figure>

<p>这段代码任然会输出1到10，也就是说<code>va = 0</code>实际上就执行了第一次。</p>
<p>对于static函数，只在当前文件可见，不能被其他文件使用。</p>
<p>对于类的静态成员来说，无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。static 成员遵循常规访问控制：如果成员在基类中为 private，则派生类不能访问它。</p>
<p>静态成员变量要通过类名来访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_va</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> va; &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> va;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 静态成员变量的初始化</span></span><br><span class="line"><span class="keyword">int</span> MyClass::va = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问静态成员函数</span></span><br><span class="line">MyClass:: get_va()</span><br></pre></td></tr></table></figure>

<p>对于static成员函数，它没有this指针，也不能访问类的非静态成员和非静态成员函数。</p>
<h2 id="枚举变量"><a href="#枚举变量" class="headerlink" title="枚举变量"></a>枚举变量</h2><p>默认地，第一个枚举成员赋值为 0，后面的每个枚举成员赋的值比前面的大1。比如有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// point2d is 2, point2w is 3, point3d is 3, point3w is 4</span></span><br><span class="line"><span class="keyword">enum</span> Points &#123; point2d = <span class="number">2</span>, point2w, point3d = <span class="number">3</span>, point3w &#125;;</span><br></pre></td></tr></table></figure>

<p>枚举成员point2d显式初始化为2。下一个枚举成员point2w默认初始化，即它的值比前一枚举成员的值大1。因此point2w初始化为3。枚举成员point3 显式初始化为3。一样，point3w默认初始化，结果为4。</p>
<h2 id="class和struct"><a href="#class和struct" class="headerlink" title="class和struct"></a>class和struct</h2><p>在C++里面，用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct的成员为public，而class的成员为private。</p>
<h2 id="C和C-区别和联系"><a href="#C和C-区别和联系" class="headerlink" title="C和C++区别和联系"></a>C和C++区别和联系</h2><p>C++是C的一个超集，C++在C的基础上添加了面向对象（object oriented），模板（template）和STL。</p>
<h2 id="关键字explicit"><a href="#关键字explicit" class="headerlink" title="关键字explicit"></a>关键字explicit</h2><p>explicit的作用就是防止类构造函数的隐式自动转换，但是只能用于修饰只有一个参数的类构造函数, 用来表明该构造函数是显示的。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : x(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> x) : x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们这样调用是合法的<code>A a = 5</code>，因为编译器会根据第二个构造函数自动把整形转换为A类对象。如果我们加上了<code>explicit</code>，那么编译器就不再会我们做隐式转换。</p>
<h2 id="new和malloc区别"><a href="#new和malloc区别" class="headerlink" title="new和malloc区别"></a>new和malloc区别</h2><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换。而malloc内存分配成功则是返回void *，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
<p>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p>
<p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>
<p>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构，而malloc则不会。</p>
<p>C++提供了new[]与delete[]来专门处理数组类型，new对数组的支持体现在它会分别调用构造函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。</p>
<p>opeartor new /operator delete可以被重载，而malloc/free不允许。</p>
<p>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充，而new没有这样直观的配套设施来扩充内存。</p>
<h2 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h2><ul>
<li>预编译主要展开包含的头文件，宏定义<code>#define</code>，条件编译如<code>#ifdef</code>，<code>#ifndef</code>等操作。</li>
<li>编译期是指把你的源程序交给编译器编译的过程，包括预编译，编译，汇编三个阶段，然后得到.obj文件，链接后生成可执行文件。</li>
<li>运行期指的是你将可执行文件交给操作系统（输入文件名，回车）执行、直到程序执行结束。</li>
</ul>
<p>运行期多态的实现依赖于虚函数机制。对模板参数而言，多态是通过模板具现化和函数重载解析实现的，以不同的模板参数具现化导致调用不同的函数，这就是所谓的编译期多态。</p>
<p>参考：<a href="http://www.cnblogs.com/acSzz/p/5743789.html" target="_blank" rel="noopener">http://www.cnblogs.com/acSzz/p/5743789.html</a></p>
<h2 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h2><p>将无符号数转换为一个更大的数据类型，我们只需要简单地在开头添加0，这种称为零扩展；</p>
<p>将一个补码数字转换成一个更大的数据类型可以执行符号扩展，规则就是添加最高有效位的值的副本（正数为0，赋值为1）；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> y1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(x1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; x1 &lt;&lt; <span class="string">", "</span> &lt;&lt; y1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// fffffffe, fffffffe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> y2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(x2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; x2 &lt;&lt; <span class="string">", "</span> &lt;&lt; y2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 00000002, 00000002</span></span><br></pre></td></tr></table></figure>

<h2 id="关键字extern"><a href="#关键字extern" class="headerlink" title="关键字extern"></a>关键字extern</h2><p>extern，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义。</p>
<p>extern “C”用于函数前，告诉编译器在编译这个函数名时按着C的规则去翻译相应的函数名而不是C++的。</p>
<h2 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h2><p>用于声明类型参数时，和class的意义是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">typename</span> <span class="title">U</span>&gt; <span class="title">class</span> <span class="title">Widget</span>;</span></span><br></pre></td></tr></table></figure>

<p><code>typename</code>还可以标识嵌套从属类型名称：比如使用迭代器作为参数时</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="内存泄漏检测"><a href="#内存泄漏检测" class="headerlink" title="内存泄漏检测"></a>内存泄漏检测</h2><p>VS中，添加头文件<code>crtdbg.h</code>，代码中加入_CrtDumpMemoryLeaks()；按下F5即可显示</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数组分割问题</title>
    <url>/2017/08/05/divide-array-into-two-parts/</url>
    <content><![CDATA[<p>这是今天在《编程之美》上看到的一道题，觉得还不错就分享给大家看看。<a id="more"></a></p>
<p>我们先来看题目的描述（原书2.18）：</p>
<blockquote>
<p>有一个无序的，元素个数为2n的正整数数组，要求把它分割成元素个数为n的两的数组，并且使它们的和最接近，请问该如何分割呢？</p>
</blockquote>
<p>粗略一看好像没什么思路，不过我们转换一下视角，如果这2n个数的总和为sum，那么我们现在要求的就是找出n个数使其总和最接近sum/2。</p>
<p>这题可以用动态规划来解决。为了让思路更清晰一点，我们思考一个简单的问题，现在不限制分割后两个数字元素的个数，我们要怎么解呢？假设数字元素为A[1…2n]，dp[i][j]表示是否可以从前i个元素中选取任意个元素，使其和为j。现在考虑状态转移过程，取还是不取第i个元素，如果不取第i个，那么dp[i][j] = dp[i-1][j];如果取第i个，那么dp[i][j] = dp[i-1][j] || dp[i][j-A[i]]。可以见到写出伪代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dp[<span class="number">2</span>*n + <span class="number">1</span>][sum/<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] = 1说明存在这样的取法；</span></span><br><span class="line"><span class="comment">// dp[i][j] = 0说明不存在；</span></span><br><span class="line"><span class="comment">// 注意初始化dp[1..2*n][0]都为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i &lt;= sum/<span class="number">2</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; j)</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - A[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在考虑取n个数的情况，假定在前i个元素中选择，在i个元素中选k个的和为j，也就是多了一层循环，由于最多只能去n个数，所以第二层循环中使k的值为min(i, n)，取这k个数也包含两种情况，一种是取第i个元素，一种是不取第i个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化dp[i][j]为0，dp[0][0]为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = min(i, n); k &gt;= <span class="number">1</span>; --k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= sum/<span class="number">2</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= A[i])</span><br><span class="line">                dp[k][j] = dp[k - <span class="number">1</span>][j] || dp[k][j - A[i]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[k][j] = dp[k - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过目前只是知道了分割成两部分后的数组和，如果要输出子数组好像还没有找到很好的解法。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（八）模板方法</title>
    <url>/2017/08/17/design-patterns-template/</url>
    <content><![CDATA[<p>模板方法模式指的是在一个方法中定义一个算法的骨架<a id="more"></a>，而将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>来看一个简单的类图:</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/template.png" alt="template"></p>
<p>模板方法中用到了两个原操作，然后把这两个原操作交个子类去具体实现，这样就把模板方法本身和这两个具体的操作解耦了。</p>
<p>下面举一个例子来说明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lass CaffeineBeverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 由子类提供具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddCondiments</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BoilWater</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"boil water...\n"</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pour in cup...\n"</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PrepareRecipe是模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrepareRecipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BoilWater();</span><br><span class="line">        Brew();</span><br><span class="line">        PourInCup();</span><br><span class="line">        AddCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">virtual</span> ~CaffeineBeverage() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>交给子类来实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> :</span> <span class="keyword">public</span> CaffeineBeverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"steeing the tea...\n"</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddCondiments</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"adding lemon...\n"</span>; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以根据不同的实现来调用不同的算法步骤：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CaffeineBeverage* cb = <span class="keyword">new</span> Tea;</span><br><span class="line">cb-&gt;PrepareRecipe();</span><br></pre></td></tr></table></figure>

<p>模板方法为我们的代码复用提供了一种技巧，在Java中，为了防止子类修改模板方法，可以将其声明为final。</p>
<p>前面说过的策略模式和模板方法类似，都封装了算法，但前者使用的是组合，后者是继承。</p>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找第K大的数</title>
    <url>/2017/06/27/find-Kth-largest-elements/</url>
    <content><![CDATA[<p>在LeetCode上看到一道题，感觉还是很有启发的，故在这里记录一下<a id="more"></a>。</p>
<p>题目链接：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/#/description" target="_blank" rel="noopener">215. Kth Largest Element in an Array</a></p>
<p>题目要求：</p>
<blockquote>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example, Given [3,2,1,5,6,4] and k = 2, return 5.</p>
</blockquote>
<p>拿到这道题，最直接的思路就是排序，平均时间复杂度为<code>O(nlgn)</code>，利用STL自带的排序算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.size() - k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们考虑能否在进行优化呢，我们只需要求第k大的数，对整个数组进行排序有点浪费了，下面介绍两种方法：</p>
<h2 id="QuickSelect"><a href="#QuickSelect" class="headerlink" title="QuickSelect"></a>QuickSelect</h2><p>第一种方法这里借鉴快速排序的思想，每次把数组分成两部分，一部分大于pivot，另一部分小于等于pivot。若在某一时刻，大于pivot的元素刚好有<code>k-1</code>个，那么我们可以直接得出，第k大的元素就是这个pivot（注意：我们把数组按照降序排列）。完整的代码如下所示：</p>
<pre><code class="cpp"><span class="keyword">int</span> _Partition(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> first, <span class="keyword">int</span> last)
{
    <span class="keyword">int</span> pivot = nums[last];
    <span class="keyword">int</span> i = first - <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> j = first; j &lt; last; ++j)
    {
        <span class="keyword">if</span> (nums[j] &gt; pivot)
        {
            ++i;
            swap(nums[i], nums[j];
        }
    }
    swap(nums[i + <span class="number">1</span>], nums[last]);
    <span class="keyword">return</span> i + <span class="number">1</span>;
}        

<span class="keyword">int</span> findKthLargest(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)
{    
    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || nums.empty() || k &gt; nums.size())
        <span class="keyword">return</span> <span class="number">-1</span>;
    <span class="keyword">int</span> first = <span class="number">0</span>, last = nums.size() - <span class="number">1</span>;
    <span class="keyword">while</span> (<span class="literal">true</span>)
    {
        <span class="keyword">int</span> p = _Partition(nums, first, last, k);
        <span class="keyword">if</span> (p == k - <span class="number">1</span>)
            <span class="keyword">return</span> nums[p];
        <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; k - <span class="number">1</span>)
            last = p - <span class="number">1</span>;
        <span class="keyword">else</span>
            first = p + <span class="number">1</span>;
    }
}        </code></pre>
<p>这种方法的时间复杂度分析：最好的情况下，就是只进行一次划分就得到了<code>p = k -1</code>，那么时间复杂度是<code>O(n)</code>；最坏的情况下，每次划分都是n-1个元素和0个元素，是<code>O(n*n)</code>。</p>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>借助堆的思想，我们也可以很方便的求出第k大的元素，考虑到每次建堆后，最大值都放在<code>nums[0]</code>处（最大堆），那么执行k次建堆操作我们就可以得到第k大的数，每次建堆后删除最大的元素，最后<code>nums[0]</code>存放的就是第k大的数。完整的代码如下所示：</p>
<pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> last)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;
    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;

    <span class="keyword">int</span> largest = <span class="number">-1</span>;
    <span class="keyword">if</span> (left &lt; last &amp;&amp; nums[i] &lt; nums[left])
        largest = left;
    <span class="keyword">else</span>
        largest = i;

    <span class="keyword">if</span> (right &lt; last &amp;&amp; nums[largest] &lt; nums[right])
        largest = right;

    <span class="keyword">if</span> (largest != i)
    {
        swap(nums[i], nums[largest]);
        max_heapify(nums, largest, last);
    }
}    

<span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>
<span class="function"></span>{    
    <span class="keyword">int</span> len = nums.size();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)
        max_heapify(nums, i, len);
}    

<span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>
<span class="function"></span>{    
    <span class="keyword">int</span> len = nums.size();
    build_max_heap(nums);
    <span class="comment">// 每次循环将当前最大值移动到nums[j]处</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">1</span> ; --j, --k)
    {
        swap(nums[<span class="number">0</span>], nums[j]);
        max_heapify(nums, <span class="number">0</span>, j);
    }
    <span class="keyword">return</span> nums[<span class="number">0</span>];
}        </code></pre>
<p>该方法的时间复杂度分析，考虑到建堆的复杂度为<code>O(n)</code>，再加上k-1次调整，最后总的时间复杂度为<code>O(n) + O(klgn)</code>。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++中class和struct的区别</title>
    <url>/2016/06/08/diff-class-and-struct/</url>
    <content><![CDATA[<p>在C++中，class和struct是基本一致的，都可以定义成员变量和成员函数，<a id="more"></a>都可以用private/protected/public修饰，唯一的区别就是class定义的数据类型默认的访问权限和继承方式是<code>private</code>，而struct的是<code>public</code>。</p>
<p>看一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;    <span class="comment">//default private</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printA1</span><span class="params">()</span>    <span class="comment">//default private</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A1:"</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x)    <span class="comment">//specifies public</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printA2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A2:"</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> y;    <span class="comment">//default public</span></span><br><span class="line"></span><br><span class="line">	B(<span class="keyword">int</span> y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B:"</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">test_a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">B <span class="title">test_b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; test_a.x &lt;&lt; endl;    // error : cannot access private member declared in class 'A'</span></span><br><span class="line">	<span class="comment">//test_a.printA1();    //error : cannot access private member declared in class 'A'</span></span><br><span class="line">	test_a.printA2();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; test_b.y &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//OK</span></span><br><span class="line">	test_b.printB();    <span class="comment">//OK</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C中，struct里面是不能定义函数的，而且C中也没有class关键字。</p>
<p>还有一点，在C++中class和typename一样可以用于模板参数，而struct则不行。</p>
<p>C++为了兼容C，所以保留并扩充了struct。</p>
<p>但是我们在实际编程中，更倾向于显露出class和struct的明显区别：定义一个类型包含public data和少量的methods使用struct，定义一个类型包含private data和member functions使用class。</p>
<p><strong>注</strong>：程序在VC++6.0下编译</p>
<p>代码下载地址：<a href="https://github.com/guansdu/diff-class-and-struct" target="_blank" rel="noopener">download</a></p>
<p>参考资料：</p>
<ol>
<li><a href="http://stackoverflow.com/questions/54585/when-should-you-use-a-class-vs-a-struct-in-c" target="_blank" rel="noopener">When should you use a class vs a struct in C++?</a></li>
<li><a href="http://stackoverflow.com/questions/2750270/c-c-struct-vs-class" target="_blank" rel="noopener">C/C++ Struct vs Class</a></li>
<li><a href="http://genwoxuec.blog.51cto.com/1852764/503334" target="_blank" rel="noopener">C/C++面试题：class和struct有什么区别？</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>研一读过的书</title>
    <url>/2016/09/04/dushu1/</url>
    <content><![CDATA[<p>去年开学到现在也读了不少书，在这里总结一下吧：<a id="more"></a></p>
<p><strong>《人生》</strong>：高加林转了一圈回到了起点。</p>
<p><strong>《活着》</strong>：最后只剩下自己。</p>
<p><strong>《岛上书店》</strong>：一般般，看着京东排行榜买的，说实话，个人觉得书的内容对不起这个排名，比《追风筝的人》差远了。</p>
<p><strong>《摆渡人》</strong>：很烂，不解释，不推荐。</p>
<p><strong>《迦陵说诗 叶嘉莹说诗讲稿》</strong>：挑着看了几篇，喜欢诗的不要错过。</p>
<p><strong>《白鹿原》</strong>：白家和鹿家三代人的命运，值得一读。</p>
<p><strong>《穆斯林的葬礼》</strong>：悲情小说。韩新月与楚雁潮太可惜了。</p>
<p><strong>《嫌疑人x的献身》</strong>：人外有人，天外有天，你以为你赢了，结果是你输了，很棒，结局意想不到。</p>
<p><strong>《解忧杂货铺》</strong>：很好，很温情的一部书，强烈推荐。</p>
<p><strong>《白夜行》</strong>、<strong>《幻夜》</strong>：我觉得可以放在一起，剧情大体类似，还不错。（这两部的女主雪穗和美冬也太可怕了，心机Max啊）</p>
<p><strong>《雪国》</strong>：看着很朦胧，看不透作者川端康成真正表达的意思。</p>
<p><strong>《菊与刀》</strong>：感觉被吹嘘过头了，不推荐。</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/dushu1/b.jpg?imageView/1/w/200/h/200" alt="朕看书呢"></p>
]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>Read</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划dynamic programming的一些总结</title>
    <url>/2017/07/09/dynamic-programing/</url>
    <content><![CDATA[<p>动态规划（Dynamic Programming）在我们寻找某个问题的最优解<a id="more"></a>（optimization，比如最大值，最小值）时是一个很有效的手段，它有点类似与分治法（Divide and Conquer）：通过寻找子问题的解从而来解决整个问题。</p>
<p>但是又不同与分治法，分治法是把原问题划分为一个一个独立的子问题，然后递归的求解各个子问题，最后合并子问题的解得到原问题的解。而动态规划来解决的是当划分的子问题都非常相似的情况，各个子问题都不是互相独立的，当相同的子问题重复出现时，通过用一个表来保存每个子问题的解，避免重复计算，相当于以空间换取时间。</p>
<p>动态规划的核心点有二：一个是<code>原问题的划分</code>，二是<code>状态转移方程的定义</code>。第一个也是寻找最优子结构的过程，找出原问题中存在的重叠子问题；第二个是求整个问题最优解的关键，状态转移方程就是描述根据子问题来求解全局最优解的过程。</p>
<p>在用动态规划求解的过程中，每个子问题只会求解一次，然后保存在表中，子问题可以被视为一个状态，下一个状态的解会用到上一个状态的解（通过查表可得，不用重复计算），这也就是我们所说的状态转移方程，是一种自底向上bottom-up的方式。</p>
<p>先看几个简单的问题，来加强我们的理解：</p>
<h2 id="Fibonacci-numbers"><a href="#Fibonacci-numbers" class="headerlink" title="Fibonacci numbers"></a>Fibonacci numbers</h2><p>回想以前我们求第n个Fibonacci数时，用的还是递归的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是其实这样的方法是很低效的，因为子问题被重复计算了很多次，我们用DP来解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a>Climbing Stairs</h2><p>一个爬楼梯的问题，来自<a href="https://leetcode.com/problems/climbing-stairs/#/description" target="_blank" rel="noopener">70. Climbing Stairs</a>，每次可以走一层或者两层，假设你要爬到第n层，求一共有多少种走法？</p>
<p>首先确定初始状态，如果n = 1，那么只有一种解法，如果n = 2，那么有两种走法（两次一步，一次两步），考虑一般情况，要走到第n层，有两种可能，在n-1层走一步，在n-2层走两步，所以我们可以写出状态转移方程<code>f(n) = f(n - 1) + f(n - 2), n &gt; 2</code>，<code>f(n)</code>表示走到第n层所有可能的走法。我们用数组来保存子问题的解，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; steps(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        steps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        steps[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        steps[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            steps[i] = steps[i - <span class="number">1</span>] + steps[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> steps[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h2><p>求连续子数组的和最大值，来自<a href="https://leetcode.com/problems/maximum-subarray/#/description" target="_blank" rel="noopener">53. Maximum Subarray</a>，当我们思考用DP来解决问题时，我们要考虑如何来表示子问题（子问题的形式），分析当前子问题的解是不是能关联下一个子问题的解，已达到求解整个问题最优解的目的。</p>
<p>用f(i)来表示数组下标从0到i范围内的最优解（即连续子数组的最大值），那么求f(i + 1)有两种选择：一个是f(i) + nums[i + 1]或者nums[i + 1]，继续考虑，如果f(i)小于0，那么加上nums[i + 1]只会得到更小的值，所以我们只在f(i)是非负数才加上它，综上我们可以写出状态转移表达式：<code>f(i + 1) = nums(i + 1) + f(i) &lt; 0 ? 0 : f(i)</code>。</p>
<p>最后对整个数组而言，最优解就是f(i)里面的最大值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_value = nums[<span class="number">0</span>], sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = max(sum, sum + nums[i]);</span><br><span class="line">            max_value = max(max_value, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**另一种写法</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt; nums[0]; ++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if (sum &lt; 0)</span></span><br><span class="line"><span class="comment">                sum = nums[i];</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                sum += nums[i];</span></span><br><span class="line"><span class="comment">            max_value = max(max_value, sum);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> max_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h2><p>求数组最长递增子序列LIS，题目来自<a href="https://leetcode.com/problems/longest-increasing-subsequence/#/description" target="_blank" rel="noopener">300. Longest Increasing Subsequence</a>，返回最长的子序列的长度。比如给定数组[3,10,2,1,20]，它的最长递增子序列为[3,10,20]，返回长度3。</p>
<p>我们假设dp[i]表示的是LIS的长度而且这个子序列是以nums[i]为结尾的，那么我们可得：</p>
<ul>
<li>dp[i] = max(dp[j]) + 1, if 0 &lt; j &lt; i &amp; nums[j] &lt; nums[i];</li>
<li>dp[i] = 1, if no such j exists;</li>
</ul>
<p>最后所以的LIS长度就是dp[i]的最大值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// run time O(N*N)</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i] is the length of the LIS ending at index i.</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>)</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>拓展：本题给出的解法的时间复杂度是<code>O(n*n)</code>，其实还有更快的<code>O(n*logn)</code>的解法，可参考<a href="http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/" target="_blank" rel="noopener">Longest Increasing Subsequence Size (N log N)</a>。</p>
<h2 id="0-1-Knapsack-Problem"><a href="#0-1-Knapsack-Problem" class="headerlink" title="0-1 Knapsack Problem"></a>0-1 Knapsack Problem</h2><p>背包问题是一个很经典的问题，也有很多延伸及变种问题。我们这里谈论的是0-1背包，就是每个物体只能选择放进背包0个或者1个，也就是说每个物体最多只能被选中一次，求能获得的最大价值。</p>
<p>用w[i]表示第i个物品的重量，c[i]表示第i个物品的价值。考虑该问题的一般情况：我们把东西放进背包是，总价值会变高，相应的重量也会变大，对某一件物品而言，它可以被放进背包，也可以不放进去，我们用一个二维数组<code>f[i][j]</code>来表示前i个物体且背包剩余负重为j的时候能获得的最大价值，如果第i个物品不放进去，那么它的最大价值是<code>f[i-1][j]</code>，如果第i个物品放进去，那么它的最大价值为<code>f[i]f[j - w[i]] + c[i]</code>和<code>f[i-1][j]</code>的最大值。至此，我们得到的状态转移方程为：</p>
<blockquote>
<p><code>f[i][j] = max(f[i-1][j], f[i]f[j - w[i]] + c[i])</code></p>
</blockquote>
<p>初始化对所有的i，j：f[i][j] = 0，这里简单写下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...we is maximum weight, n is the number of object.</span></span><br><span class="line"><span class="comment">// ...initialization</span></span><br><span class="line"><span class="comment">// w[1..n] w[1..we]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= we; ++j) <span class="comment">//每个重量都试一试</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= w[i]) <span class="comment">//有足够的负重空间</span></span><br><span class="line">            f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j-w[i]] + c[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f[n][we];</span><br></pre></td></tr></table></figure>

<p>上面的时间复杂度和空间复杂度都是<code>O(n*we)</code>，我们发现，每次求f[i][j]时只用到了上方和左上方的数据，那么我们还能不能进一步优化空间复杂度呢？其实这是可以的，不过我们需要改变一下循环方向，从后往前：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...initialization</span></span><br><span class="line"><span class="comment">// extra space O(we)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = we; j &gt;= w[i]; --j)</span><br><span class="line">        f[j] = max(f[j], f[j - w[i]] + c[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f[we];</span><br></pre></td></tr></table></figure>

<h2 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h2><p>求最长公共子序列，原题目来自《算法导论第二版》第十五章。给定两个字符串，求它们的LCS的长度，比如“abcdgh”和“aedfhr”最长的公共子序列是“adh”，那么返回其长度3。</p>
<p>用X[0,…,m-1]和Y[0,…,n-1]来表示这两个字符串，其中m和n是它们各自的长度。用L(X[0,…,m-1], Y[0,…,n-1])表示X和Y的LCS长度，那么我们有：</p>
<p>如果X[m-1] == Y[n-1]，那么L(X[0,…,m-1], Y[0,…,n-1]) = 1 + L(X[0,…,m-2], Y[0,…,n-2])；否则的话我们有：L(X[0,…,m-1], Y[0,…,n-1]) = max(L(X[0,…,m-2], Y[0,…,n-1]), L(X[0,…,m-1], Y[0,…,n-2]))。</p>
<p>由此我们可以写出代码，我们用二维数组L[i][j]表示X[i-1]和Y[j-1]的LCS长度：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; L(m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; ++i)</span><br><span class="line">    L.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (X[i] == Y[j])</span><br><span class="line">            L[i + <span class="number">1</span>][j + <span class="number">1</span>] = L[i][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(L[i + <span class="number">1</span>][j], L[i][j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> L[m][n];</span><br></pre></td></tr></table></figure>

<h2 id="Longest-Common-Substring"><a href="#Longest-Common-Substring" class="headerlink" title="Longest Common Substring"></a>Longest Common Substring</h2><p>求最长公共子串的长度，比如”abcxy”和”xyabc”的最长公共子串是”abc”，那么我们返回其长度为3。</p>
<p>两个字符串为X[0…m-1]和X[0…n-1]，其中m和n分别是两个字符串的长度，我们用L[i][j]表示字符串X[0…i-1]和Y[0…j-1]的最长公共后缀的长度（longest common suffix），那么我们有：</p>
<ul>
<li>L[i][j] = L[i-1][j-1] + 1, if X[i-1] = y[j-1];</li>
<li>otherwise, L[i][j] = 0;</li>
</ul>
<p>由此我们可以写出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; L(m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; ++i)</span><br><span class="line">    L.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> max_lcs_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            L[i][j] = L[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            max_lcs_length = max(max_lcs_length, L[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_lcs_length;</span><br></pre></td></tr></table></figure>

<p>好了，对DP的总结到这里就告一段落了，希望能有所启发，找出用DP解题的一般规则。</p>
<p>参考文献：</p>
<ol>
<li>Introduction to Algorithms (2ed edition).</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找的一个应用</title>
    <url>/2017/07/12/find-Ks-binary-search/</url>
    <content><![CDATA[<p>今天看《剑指offer》遇到一个题目，是一个关于二分查找的算法题，其实也不难<a id="more"></a>：求一个已经排序的数组中某个数K出现的次数，顺便复习一下啊二分查找，我在这里就简单的分析一下道题的解法：</p>
<p>最直接的解法当然是顺序扫描整个数组，然后统计出K的出现次数，时间复杂度<code>O(n)</code>，但是我们要思考出更快的算法：利用二分查找。</p>
<p>首先我们要找到数组中第一次出现K的位置，基于二分查找的思想，如果中间的数字大于K，那么我们要继续在前半段搜寻；如果中间的数字小于K，我们要继续在后半段搜寻；如果中间的数字等于K呢？我们要仔细思考一下，考虑前一个数是否也等于K，如果不是的话，那么这个中间位置即为所求，如果是的话，那么我们就继续在前半段搜寻。</p>
<p>基于这个思路，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_first_K</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; k)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; k)</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (middle &gt; <span class="number">0</span> &amp;&amp; nums[middle - <span class="number">1</span>] != k</span><br><span class="line">            || middle == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来求数组中最后出现K的位置，思路也很类似：如果中间的数字等于K，这个时候我们它前一个数字是否也等于K，如果是的话，那么我们继续往后半段搜寻，不是的话，直接返回这个位置即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_last_K</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; k)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; k)</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (middle &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[middle + <span class="number">1</span>] != k</span><br><span class="line">            || middle == nums.size() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后想说明的是，代码里面边界测试不够完整，大家在实践过程中一定要考虑周全，比如K的值不在数组里面，我们该怎么办呢？其实也很简单，只要判断返回的位置的值是不是等于K即可。</p>
<hr>
<p>2017.07.26更新</p>
<hr>
<p>最近看书发现了一个更简洁的办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_first_K</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">int</span>  i = <span class="number">-1</span>, j = nums.size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">1</span> &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            i = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; nums.size() &amp;&amp; nums[j] == target)</span><br><span class="line">        ret = j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_last_K</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    i = <span class="number">-1</span>;</span><br><span class="line">    j = nums.size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">1</span> &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            j = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">-1</span> &amp;&amp; nums[i] == k)</span><br><span class="line">        ret = i;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ul>
<li>《剑指offer》，何海涛。</li>
<li>《Programming Pearls 2nd Edition》，John Bentley。</li>
</ul>
<p><em>Tips:大家在看《剑指offer》这本书的时候，一定要带有批判性的去看，要多思考作者给出的解法是不是最优、最简洁的，多问问自己，还能优化吗？还能更快吗？其实书中有很多题目都有更清晰速度更快的结果，作者给的解法更多的只是一种参考。</em></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（二）观察者模式</title>
    <url>/2017/08/07/design-patterns-observer/</url>
    <content><![CDATA[<p>首先我们来看观察者模式（observer）的定义：<a id="more"></a>定义了对象之间的一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到并通知自动更新。有时候也被称为发布-订阅者模式，一般把发布者称为“主题”subject，把订阅者称为observer。</p>
<p>首先来看它的类图：<br><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/observer.png" alt="observer"></p>
<p>一个具体的主题总是继承了抽象主题基类，然后自己实现注册观察者，移除观察者和通知观察者这三种方法；而所有的观察者对象都必须要实现更新Update方法，用来接收更新，当主题状态改变时就会调用观察者的这个方法。</p>
<p>我们在这了可以看到：主题只知道观察者实现了某个接口（图中Observer接口），而并不关心观察者具体的其他细节。任何时候都可以增加或者移除观察者，而主题不会受到任何影响，它只是一如既往的发送通知给实现了观察者接口的对象，这样的设计我们就叫<strong>松耦合</strong>，它将对象之间的依赖降到最低，使得我们系统的弹性更大。</p>
<p>下面我们来看一个具体的例子：</p>
<p>比如一个气象站会有很多的气象数据WeatherData，比如温度、湿度和压强等等，那我们现在目的就是要处理这些数据，分类的展现给用户，因为气象数据都是会定时更新的，所以我们希望我们的系统也能动态的更新这些信息。好了，现在观察者模式就派上用场了，气象站不就是我们说的发布者subject吗？而展现里面气象数据的就是我们的订阅者observer。</p>
<p>于是我们这么设计具体的主题类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> :</span> <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WeatherData();</span><br><span class="line">    <span class="comment">//WeatherData(const WeatherData&amp; rhs);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span><span class="params">(Observer* ob)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RemoveObserver</span><span class="params">(Observer* ob)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 气象数据更新</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetMeasurements</span><span class="params">(<span class="keyword">double</span> tem, <span class="keyword">double</span> hum, <span class="keyword">double</span> pre)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="comment">// 湿度</span></span><br><span class="line">    <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="comment">// 压强</span></span><br><span class="line">    <span class="keyword">double</span> pressure;</span><br><span class="line">    <span class="comment">// 存放具体的观察者</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Observer*&gt; list_observers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个专门检测温度的具体观察者类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurrentTemperature</span> :</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CurrentTemperature(Subject* wea);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">double</span> tem, <span class="keyword">double</span> hum, <span class="keyword">double</span> pre)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> temperature;</span><br><span class="line">    Subject* weather_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我自己用C++实现这两个类的时候也遇到了一点困难，下面给出我自己的方案，不一定是最好的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WeatherData::WeatherData() : temperature(<span class="number">0.0</span>), humidity(<span class="number">0.0</span>), pressure(<span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::RegisterObserver(Observer* ob)</span><br><span class="line">&#123;</span><br><span class="line">    list_observers.push_back(ob);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::RemoveObserver(Observer* ob)</span><br><span class="line">&#123;</span><br><span class="line">    list_observers.remove(ob);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::NotifyObserver()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Observer*&gt;::iterator it = list_observers.begin();</span><br><span class="line">    <span class="keyword">for</span> ( ; it != list_observers.end(); ++it)</span><br><span class="line">        (*it)-&gt;Update(temperature, humidity, pressure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WeatherData::SetMeasurements(<span class="keyword">double</span> tem, <span class="keyword">double</span> hum, <span class="keyword">double</span> pre)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 状态改变后，通知观察者</span></span><br><span class="line">    temperature = tem;</span><br><span class="line">    humidity = hum;</span><br><span class="line">    pressure = pre;</span><br><span class="line">    NotifyObserver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了C++多态机制，用了一个基类Observer的指针来指向不同的子类观察者，这样就会更加指向的不同调用不同的update方法。<code>SetMeasurements</code>方法是用来修改主题的数据，并调用NotifyObserver通知观察者。</p>
<p>下面是观察者CurrentTemperature的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CurrentTemperature::CurrentTemperature(Subject* wea)</span><br><span class="line">&#123;</span><br><span class="line">    weather_data = wea;</span><br><span class="line">    weather_data-&gt;RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CurrentTemperature::Update(<span class="keyword">double</span> tem, <span class="keyword">double</span> hum, <span class="keyword">double</span> pre)</span><br><span class="line">&#123;</span><br><span class="line">    temperature = tem;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"temperature: "</span> &lt;&lt; temperature &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意具体的观察者里面有一个基类Object的指针，表示这个观察者想要监听的某个主题。</p>
<p>那么我们在使用的时候就要这么来用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Subject* sub; <span class="comment">// 观察者</span></span><br><span class="line">WeatherData wea; <span class="comment">// 主题</span></span><br><span class="line">sub = &amp;wea;</span><br><span class="line"></span><br><span class="line">CurrentTemperature* ct = <span class="keyword">new</span> CurrentTemperature(sub);</span><br><span class="line">CurrentHumidity* ch = <span class="keyword">new</span> CurrentHumidity(sub);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类是无法调用子类独有的方法的</span></span><br><span class="line"><span class="comment">// 比如sub-&gt;SetMeasurements()是不行的</span></span><br><span class="line">wea.SetMeasurements(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>);</span><br><span class="line">wea.SetMeasurements(<span class="number">2.2</span>, <span class="number">1.2</span>, <span class="number">3.3</span>);</span><br></pre></td></tr></table></figure>

<p>好了，到这里你基本明白了观察者模式基本的运作原理。在Java的Swing组件中就大量使用了观察者模式。</p>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（四）工厂模式</title>
    <url>/2017/08/10/design-patterns-factory/</url>
    <content><![CDATA[<p>工厂模式有两种：工厂方法模式（Factory Method）<a id="more"></a>和抽象工厂（Abstract Factory），本文主要介绍的是工厂方法：它定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。</p>
<p>来看一个简单的类图：<br><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/factory.png" alt="Factory Method"></p>
<p>Creator是一个类，它实现了所有操控产品的方法（AnOperation），但是不会实现工厂方法（FactoryMethod），所有Creator的子类都必须实现这个抽象方法，ConcreteCreator是Creator的子类，实现了工厂方法，以制造出产品；</p>
<p>所有的ConcreteProduct都实现了一个共同的接口，这样一来，使用这些产品的类就可以引用这个接口，而不是具体的类。</p>
<p>下面看一个具体的例子：<br><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/factory-pizza-store.png" alt="Pizza Store"><br>Creator类是一个PizzaStore，用来创建Pizza，而具体的创建者是不同地方的披萨店NYPizzaStore和ChicagoPizzaStore，里面的CreatePizza()就是工厂方法，用来创建披萨，不同的店可以实现自己的CreatePizza()，来创建不同风味的Pizza。</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/factory-pizza.png" alt="Pizza"><br>具体的产品类就是Pizza，所以店里可以实际制造出来的披萨口味都在这里。</p>
<p>于是我们这么设计PizzaStore基类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// abstruct class 只用来作为基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">Pizza <span class="title">OrderPizza</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> pizza_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Pizza piz = CreatePizza(pizza_type);</span><br><span class="line">        piz.bake();</span><br><span class="line">        piz.cut();</span><br><span class="line">        piz.box();</span><br><span class="line">        <span class="keyword">return</span> piz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// factory method</span></span><br><span class="line">    <span class="comment">// pure virtual 希望在子类中重写</span></span><br><span class="line">    <span class="comment">// 依靠子类来实现对象的创建</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza <span class="title">CreatePizza</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> pizza_type)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~PizzaStore() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Pizza类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// abstract class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pizza(<span class="built_in">std</span>::<span class="built_in">string</span> name):name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"now bake\n"</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"now cut\n"</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"now box\n"</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Pizza() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体的创建者NYPizzaStore和ChicagoPizzaStore：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NYPizzaStore</span> :</span> <span class="keyword">public</span> PizzaStore</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pizza <span class="title">CreatePizza</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> pizza_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pizza_type == <span class="string">"cheese"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NYCheeseStylePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这个例子中，我们是根据不同的参数来创建不同的产品对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> :</span> <span class="keyword">public</span> PizzaStore</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pizza <span class="title">CreatePizza</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> pizza_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pizza_type == <span class="string">"cheese"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ChicagoStyleCheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后是两个店生成的不同口味的披萨：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NYCheeseStylePizza</span> :</span> <span class="keyword">public</span> Pizza</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NYCheeseStylePizza() : Pizza(<span class="string">"NY style sauce and cheese pizza"</span>) </span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"NY style sauce and cheese pizza\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    ~NYCheeseStylePizza() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChicagoStyleCheesePizza</span> :</span> <span class="keyword">public</span> Pizza</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChicagoStyleCheesePizza() : Pizza(<span class="string">"Chicago style deep dish cheese pizza"</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~ChicagoStyleCheesePizza() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么我们现在要点一份披萨，就可以这样来做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PizzaStore* ny_store = new NYPizzaStore();</span><br><span class="line">Pizza ny_pizza = ny_store-&gt;OrderPizza(&quot;cheese&quot;);</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到，利用工厂方法，我们把产品的实现交给了子类，增加产品或者修改产品的实现，Creator类并不会受到影响。</p>
<p>工厂方法的使用体现了面向对象编程的一个设计原则：<strong>依赖抽象，而不是具体类</strong>。这也被称为倒置依赖原则，也就是说不能要高层组件依赖底层组件。PizzaStore就是高层组件，而比萨的具体实现是底层组件，我们很清楚的看到，PizzaStore依赖这些具体的比萨类。</p>
<p>一般来说有以下几点来帮助我们避免违反倒置依赖原则：</p>
<ul>
<li>不要让类派生自具体类</li>
<li>不要覆盖基类中的非virtual方法</li>
<li>实例变量不要持有具体类的引用，应该利用多态机制，基类指针可以指向不同的子类对象。</li>
</ul>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>主机字节序判断</title>
    <url>/2017/09/08/host-byte-order/</url>
    <content><![CDATA[<p>在UNP v1第三章提到了字节排序函数，在这里稍微总结一下。<a id="more"></a></p>
<p>考虑一个16bit的整数，它由2个字节组成内存中存储这两个字节有两种方法：一种是将低序字节存储在起始位置，这种称为小端(little-endian)字节序,另一种是将高序字节存储在起始地址，这称为大端（bin-endian）字节序。</p>
<p>网络协议中使用大端字节序。</p>
<p><strong>判断主机字节序</strong></p>
<p>如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// win10 vs2013: little endian</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_byte_order</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> un</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">short</span> s;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    un u;</span><br><span class="line">    u.s = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">short</span>) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; u.c[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (u.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; u.c[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"little endian\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"unknown\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>大小端字节转换</strong></p>
<p>如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对32位整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">big_to_little</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf("%02x\n", x);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = ((x &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>)</span><br><span class="line">            | ((x &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">8</span>)</span><br><span class="line">            | ((x &amp; <span class="number">0x0000ff00</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">            | ((x &amp; <span class="number">0x000000ff</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("%02x\n", tmp);</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Networks</category>
      </categories>
      <tags>
        <tag>Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中序遍历的前驱和后继</title>
    <url>/2017/08/02/inorder-tree-successor/</url>
    <content><![CDATA[<p>假如现在二叉树中每个结点都有指向父结点的指针，我们现在要求某个结点<a id="more"></a>中序遍历下的前序和后继结点，该怎么做呢？</p>
<p>二叉树定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), parent(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h2><p>根据中序遍历的特点，先左子结点，再是根结点，最后右子结点。分析如下：</p>
<ul>
<li>如果该结点的左子树不为空，那么它的前驱就是它左子结点的最右结点；</li>
<li>如果该结点左子树为空，而且是它父结点的右孩子，那么它的前驱就是它的父结点；</li>
<li>如果该结点左子树为空，而且是它父结点的左孩子，就要往上开始找，直到某个结点是父亲的右孩子为止；</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">predecessor</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t = node-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (t-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            t = t-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t = t-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">NULL</span> &amp;&amp; t-&gt;left == node)</span><br><span class="line">        &#123;</span><br><span class="line">            x = t;</span><br><span class="line">            t = t-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后继"><a href="#后继" class="headerlink" title="后继"></a>后继</h2><p>同理可分析：</p>
<ul>
<li>如果该结点的右子树不为空，那么它的后继就是它右子结点的最左结点；</li>
<li>如果该结点右子树为空，而且是它父结点的左孩子，那么它的前驱就是它的父结点；</li>
<li>如果该结点右子树为空，而且是它父结点的右孩子，就要往上开始找，直到某个结点是父亲的左孩子为止；</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">successor</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t = node-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (t-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            t = t-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t = t-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">NULL</span> &amp;&amp; t-&gt;right == node)</span><br><span class="line">        &#123;</span><br><span class="line">            x = t;</span><br><span class="line">            t = t-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信方式</title>
    <url>/2017/07/30/inter-process-communication/</url>
    <content><![CDATA[<p>熟悉下常用的进程之间通信方式<a id="more"></a>：</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程间通信（IPC，Interprocess communication）是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。这使得一个程序能够在同一时间里处理许多用户的要求。因为即使只有一个用户发出要求，也可能导致一个操作系统中多个进程的运行，进程之间必须互相通话。</p>
<p>IPC方法包括管道（PIPE）、系统IPC（包括消息队列，信号量，共享内存)以及套接字（Socket）。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道包括两种：</p>
<ul>
<li>普通管道PIPE，通常有两种限制，一是半双工的，数据只能在一个方向流动;二是只能在父子或者兄弟进程间使用。</li>
<li>命名管道name_pipe：或者叫FIFO，去除了第二种限制，可以在许多并不相关的进程之间进行通讯。</li>
</ul>
<p>管道的使用：</p>
<ul>
<li>pipe：创建一个管道，返回2个管道描述符.通常用于父子进程之间通讯。</li>
<li>popen和pclose：这种方式只返回一个管道描述符，常用于通信另一方是stdin or stdout。</li>
<li>mkpipe：命名管道，在许多进程之间进行交互。</li>
<li>管道通过系统调用read()， write()函数进行读写操作，管道以先进先出(FIFO)方式组织数据传输。</li>
</ul>
<p>管道与系统IPC比较：</p>
<ul>
<li>管道：优点是所有的UNIX实现都支持， 并且在最后一个访问管道的进程终止后，管道就被完全删除；缺陷是管道只允许单向传输或者用于父子进程之间。</li>
<li>系统IPC：优点是功能强大，能在毫不相关进程之间进行通讯； 缺陷是关键字KEY_T使用了内核标识，占用了内核资源，而且只能被显式删除，而且不能使用SOCKET的一些机制，例如select，epoll等。</li>
</ul>
<h3 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h3><p>信号用来通知进程系统中发生了一个某种类型的事件。每一种信号都对应与某种系统事件（比如，一个进程试图除以0，内核就发给它一个SIGFPE信号）。</p>
<p>底层的硬件异常通常是由内核异常处理程序处理的，一般情况下用户进程不可见，而信号提供了这种机制，通知用户进程发生了这些异常。</p>
<p>发送一个信号到目的进程分为两个步骤：</p>
<ul>
<li>发送信号。内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。发送信号可以有以下两个原因：一是内核检测到一个系统事件；二是一个进程调用了kill函数。一个进程可以给自己发送信号。</li>
<li>接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接受了信号。</li>
</ul>
<p>一个只发出而没有被接受的信号叫做待处理信号，一个类型至多只有一个待处理信号。一个待处理信号至多只被接收一次。</p>
<h3 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h3><p>更为一般的进程间通信机制，可用于不同机器之间的进程间通信。</p>
<h3 id="IPC信号量"><a href="#IPC信号量" class="headerlink" title="IPC信号量"></a>IPC信号量</h3><p>IPC信号量，是一个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<h3 id="IPC消息队列"><a href="#IPC消息队列" class="headerlink" title="IPC消息队列"></a>IPC消息队列</h3><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。但是进程从IPC消息队列中读出了一条消息，内核就会把这个消息删除。</p>
<p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
<h3 id="IPC共享内存"><a href="#IPC共享内存" class="headerlink" title="IPC共享内存"></a>IPC共享内存</h3><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p>参考资料：<a href="http://blog.csdn.net/ljianhui/article/details/10253345" target="_blank" rel="noopener">http://blog.csdn.net/ljianhui/article/details/10253345</a></p>
<h3 id="IPC目的："><a href="#IPC目的：" class="headerlink" title="IPC目的："></a>IPC目的：</h3><ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</li>
<li>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li>资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（一）策略模式</title>
    <url>/2017/08/06/design-patterns-strategy/</url>
    <content><![CDATA[<p>早些时候看了《Head First设计模式》这本书，选择读这本书的<a id="more"></a>主要原因是比较适合初学者，图文并茂，通俗易懂~~（当然最经典的还是GoF的那本）所以打算写几篇的博客总结一下，算是一个简单的复习吧。这本书上的例子都是Java写的，所幸我本科用过两年多Java，还不至于到看不懂的地步。</p>
<p>就以策略模式（strategy）作为开端：</p>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于算法的客户。</p>
<p>假如我们要设计一个鸭子duck基类，一般来说它的行为有：游泳，咕咕叫。于是我们这么设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Swim</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是所有继承Duck的子类都有了Swim和Quack行为，那么现在需求突然变了，有一只会飞的鸭子，要怎么做呢？</p>
<p>简单的想法就是直接在子类中添加一个Fly方法，这样做也行，但是当有很多会飞的鸭子时，我们要在每个会飞的鸭子中添加重复的代码，这样显然不太好。</p>
<p>还有一个想法就是把基类Duck中添加Fly方法，那么所以的子类都会自动继承Fly方法，但是有些鸭子确实又不会飞，我们只好在子类中重写Quack行为，这样好像也不太好。</p>
<p>想的更多一点，其实咕咕叫的行为好像也不太好，有的鸭子是“吱吱叫”，那怎么办呢？（哈哈，是不是想太多了）</p>
<p>我们现在知道一个情况是：Fly行为和Quack行为会随着鸭子种类的变化而变化，就此记住一个设计原则：<strong>找出程序中可能变化的部分，把它和不变的部分分离开来</strong>。那么我们该如何设计这个Fly行为和Quack行为的类呢？我们要思考的远一点，比如一个小鸭子可能刚开始不会飞，但是长大了就会飞了，所以说我们干脆要鸭子的Fly行为可以动态的改变，就此记住第二个设计原则：<strong>针对接口编程，而不是实现编程</strong>。</p>
<p>现在我们把Fly行为和Quack行为设计成FlyBehavior和QuackBehavior这两个接口，现在鸭子类就不需要知道行为的具体细节，它会根据这两个接口的不同实现而表现出不同的行为。</p>
<p>看下面代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBehavior</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~FlyBehavior() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuackBehavior</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Quack</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~QuackBehavior() &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里把鸭子的Fly行为和Quack行为定义为纯虚函数，FlyBehavior和QuackBehavior也就成了抽象基类，把它的具体实现交给子类。</p>
<p>现在整理一下基类Duck，加入了两个行为接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Swim</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PerformQuack</span><span class="params">()</span> </span>&#123; quack_behavior-&gt;Quack(); &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PerfromFly</span><span class="params">()</span> </span>&#123; fly_behavior-&gt;Fly(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetQuackBehavior</span><span class="params">(QuackBehavior* quack_behavior)</span> </span>&#123; <span class="keyword">this</span>-&gt;quack_behavior = quack_behavior; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFlyBehavior</span><span class="params">(FlyBehavior* fly_behavior)</span> </span>&#123; <span class="keyword">this</span>-&gt;fly_behavior = fly_behavior; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QuackBehavior* quack_behavior;</span><br><span class="line">    FlyBehavior* fly_behavior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以利用SetQuackBehavior和SetFlyBehavior来动态的指定鸭子的具体行为。</p>
<p>下面给出两种FlyBehavior的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyNoWay</span> :</span> <span class="keyword">public</span> FlyBehavior</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i can not fly...\n"</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> :</span> <span class="keyword">public</span> FlyBehavior</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>:: <span class="built_in">cout</span> &lt;&lt; <span class="string">"fly with wings...\n"</span>; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加入现在有一种鸭子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> :</span> <span class="keyword">public</span> Duck</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a mallard duck...\n"</span>; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们现在指定它可以飞：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Duck* mallard = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">mallard-&gt;Display();</span><br><span class="line"></span><br><span class="line">mallard-&gt;SetFlyBehavior(<span class="keyword">new</span> FlyWithWings());</span><br><span class="line"></span><br><span class="line">mallard-&gt;PerfromFly();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a mallard duck...</span><br><span class="line">fly with wings...</span><br></pre></td></tr></table></figure>

<p>假如它现在又不可以飞了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mallard-&gt;SetFlyBehavior(<span class="keyword">new</span> FlyNoWay());</span><br><span class="line"></span><br><span class="line">mallard-&gt;PerfromFly();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i can not fly...</span><br></pre></td></tr></table></figure>

<p>你是否感受到了这样做的魅力呢？我们在子类中利用SetFlyBehavior来制定具体FlyBehavior的行为，利用C++的多态性质来给鸭子不同的行为。</p>
<p>看下图应该更明了：<br><img src="http://7xv63n.com1.z0.glb.clouddn.com/design-patterns/strategy.png" alt="stratrgy"></p>
<p>好了，到这里你基本上就了解策略模式的思路了，我们还应该注意到，这里把FlyBehavior和QuackBehavior放到Duck类中，使用了组合，如你所见，使用组合可以让我们的对象极具弹性，可以动态的改变对象的行为。</p>
<p>我们也要知道，当对象的行为很多时，我们的行为类也会不断的增多，这也是策略模式的缺点之一。</p>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O多路复用：select,poll和epoll</title>
    <url>/2017/08/23/io-multiplexing/</url>
    <content><![CDATA[<p>想象以下场景：如果我们现在要求服务器既能对客户端的连接请求进行响应<a id="more"></a>，也能对用户从标准输入键入的交互命令做出响应，那么此时我们的服务器应该先等待哪个I/O事件呢？没有哪个选择是理想的，如果我们在accept中等待一个连接请求，那么就不能响应输入的命令，反之，如果等待输入命令，我们就不能响应任何连接请求。</p>
<p>解决这个问题的一个办法就是I/O多路复用技术，IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
</ol>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select函数，要求内核挂起进程，只有在一个或者多个I/O事件发生后，才将控制权返回给应用程序。作为一个例子，我们可以调用select，告知内核仅在下列情况时才返回：</p>
<ul>
<li>集合{1,4,5}中的任何描述符准备好读；</li>
<li>集合{2,7}中的任何描述符准备好写；</li>
<li>集合{1,4}中任何描述符有异常条件待处理；</li>
<li>已经经历了10.2秒，超时；</li>
</ul>
<p>select函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数列表解释：</p>
<ol>
<li>中间的三个参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针；</li>
<li>maxfdp1参数指定待测试的描述字个数，它的值是待测试的最大描述字加1，描述符0、1、2…maxfdp1-1均将被测试。</li>
<li>timeout告知内核等待所指定描述字中的任何一个就绪可花多少时间，这个参数有三种可能：第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值（也成为轮询polling）；第三，timeout的值大于0，这就是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。</li>
</ol>
<p>如何给一个参数指定一个或者多个描述符值？</p>
<p>select使用的是描述符集fd_set，通常是一个整数数组，每个整数的每一位对应一个描述符，比如32位整数，那么第三个数组的第一个元素对应描述符0<del>31，第二个对应32</del>63，以此类推。具体的实现细节我们目前不关心，可以用一下四个函数对描述符进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;     <span class="comment">// 用来清除描述集合fdset的全部位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;    <span class="comment">// 用来打开描述集合fdset中相关fd的位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;    <span class="comment">// 用来清除描述集合set中相关fd的位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;    <span class="comment">// 检查集合中指定的fd相关的描述符是否就绪</span></span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<p>select函数修改指针readset、writeset和exceptset所指向的描述符集，因此这三个参数都是值-结果参数。调用该函数时，我们用<code>FD_SET</code>指定所关心的描述符的值；函数返回后，我们用<code>FD_ISSET</code>来测试fd_set中的描述符。描述符集内任何与未就绪描述符对应的返回值均被清除为0。因此，每次重新调用select函数时，我们都要再次把所有描述符集内关心的位均设置为1。</p>
<p>该函数返回值表示所有描述符集的已就绪的总位数，若没有任何描述符就绪定时器超时返回0，出错返回-1。</p>
<p>彻底理解select工作机制：</p>
<p>下面给出一个基于I/O复用的服务器代码（不能运行，用来讲解原理）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略了一部分代码</span></span><br><span class="line">    <span class="keyword">int</span> listenfd, port;</span><br><span class="line">    fd_set read_set, ready_set;</span><br><span class="line">    listenfd = open_listenfd(port);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_set); <span class="comment">/* Clear read set */</span></span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;read_set); <span class="comment">/* Add stdin to read set */</span></span><br><span class="line">    FD_SET(listenfd, &amp;read_set); <span class="comment">/* Add listenfd to read set */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        ready_set = read_set;</span><br><span class="line">        select(listenfd+<span class="number">1</span>, &amp;ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 注意这里没有轮询判断，因为我们作为例子，只有两个两个描述符</span></span><br><span class="line">        <span class="comment">// 实际情况下，当描述符集中有很多已连接的描述符时，我们是需要用循环判断的。</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;ready_set))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中<code>open_listenfd</code>用来打开一个监听描述符listenfd（对应socket，bind和listened），接下来用<code>FD_SET</code>创建一个空的描述符集：</p>
<blockquote>
<pre><code>  index:     3  2  1  0
            ------------
read_set{∅}: 0  0  0  0</code></pre></blockquote>
<p>接下来我们用<code>FD_SET</code>设置了由监听描述符listenfd（对应index 3）和标准输入<code>STDIN_FILENO</code>描述符（对应index 0）组成的集合：</p>
<blockquote>
<pre><code>  index:       3  2  1  0
              ------------
read_set{0,3}: 1  0  0  1</code></pre></blockquote>
<p>接下来服务器开始了典型的循环，但是我们不再调用accept函数来等待一个连接请求的到来，而是调用select函数，这个函数会一直阻塞，直达监听描述符或者标准输入准备好可以读。比如，下面用户按下回车键，使得标准输入变得可以读，这个时候select函数返回ready_set的值：</p>
<blockquote>
<pre><code>  index:       3  2  1  0
              ------------
ready_set{0}:  0  0  0  1</code></pre></blockquote>
<p>一旦select返回，我们就可以用FD_ISSET宏指令来判断哪个描述符准备好了，然后做出不同的响应。</p>
<p>select缺点：</p>
<ol>
<li>有最大描述符限制，<code>FD_SETSIZE</code>一般为1024。</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</li>
<li>需要维护一个用来存放大量fd_set的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
</ol>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是指向一个结构体数组的第一个元素的指针。每个数组元素都是一个pollfd结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pollfd结构中要测试的条件由的events指定，函数在相应的revents成员中返回该描述符的状态（一个为调用值，一个为返回结果）。不再使用select“参数-值”传递的方式。</p>
<p>poll不再有最大描述符限制，但是仍然有select的第二和第三个缺点。</p>
<p>我们可以看到select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少<code>epoll_wait</code>的调用，提高应用程序效率。</p>
<p>epoll提供了三个函数，<code>epoll_create</code>,<code>epoll_ctl</code>和<code>epoll_wait</code>，<code>epoll_create</code>是创建一个epoll句柄；<code>epoll_ctl</code>是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>彻底理解epoll优点：</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，为了避免不必要的内存拷贝，epoll是通过内核与用户空间mmap同一块内存实现的（共享内存），使得使得这块物理内存对内核和对用户均可见。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<h3 id="不需轮询判断"><a href="#不需轮询判断" class="headerlink" title="不需轮询判断"></a>不需轮询判断</h3><p>epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在<code>epoll_ctl</code>时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。<code>epoll_wait</code>的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果）。</p>
<h3 id="描述符没有数量上限"><a href="#描述符没有数量上限" class="headerlink" title="描述符没有数量上限"></a>描述符没有数量上限</h3><p>所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子，在1GB内存的机器上大约是10万左右。</p>
<h3 id="IO效率不随FD数目增加而线性下降"><a href="#IO效率不随FD数目增加而线性下降" class="headerlink" title="IO效率不随FD数目增加而线性下降"></a>IO效率不随FD数目增加而线性下降</h3><p>传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是“活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对“活跃”的socket进行操作–这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。只有“活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会。</p>
<p><strong>红黑树</strong>将存储epoll所监听的套接字描述符。epoll在实现上采用红黑树去存储所有套接字描述符，当添加或者删除一个套接字时（epoll_ctl），都在红黑树上去处理，红黑树本身插入和删除性能比较好，时间复杂度O(logN)。</p>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>epoll有2种工作方式：LT和ET：</p>
<p>LT（level triggered）水平触发，是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p>
<p>ET （edge-triggered）边缘触发，是高速工作方式，只支持non-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
<p>参考资料：</p>
<ol>
<li>CSAPP 第12章</li>
<li>UNP 第6章</li>
</ol>
<p>更权威的,请参阅Linux Programmer’s Manual:</p>
<ul>
<li><a href="http://www.man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man2/select.2.html</a></li>
<li><a href="http://www.man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man2/poll.2.html</a></li>
<li><a href="http://www.man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man7/epoll.7.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Networks</category>
      </categories>
      <tags>
        <tag>Networks</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>详解KMP字符串匹配算法</title>
    <url>/2017/07/31/kmp-pattern-match/</url>
    <content><![CDATA[<p>在文本编辑器（Word，记事本）里面，我们常常需要在某一段文本中找出某个模式<a id="more"></a>的全部出现位置，比如在英文文章中找出单词<code>farewell</code>的出现次数等等。使用一种好的字符串匹配算法能大大提高搜索所需要的时间。本篇博客就来介绍一个能在线性时间解决字符串搜索问题的算法。</p>
<p>首先我们定义字符串匹配问题：假定文本是一个长度为n的数组T[1..n]，模式（待搜索字符串）是一个长度为m&lt;=n的数组P[1..m]。对于<code>0 &lt;= s &lt;= n-m</code>，有<code>T[s+1..s+m] = P[1..m]</code>，我们就认为模式P在文本T中出现且位移为s。</p>
<blockquote>
<pre><code>T : a b c a b a a
P :----&gt;c a b
       s</code></pre></blockquote>
<p>如上图所示，我们认为s=2就是一个有效位移。</p>
<h2 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h2><p>考虑朴素的字符串匹配算法，它用一个循环来找出所有的位移，该循环对n-m+1个可能的每个s检查条件<code>T[s+1..s+m]=P[1..m]</code>是否满足，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Naive-String-Matcher</span><br><span class="line"></span><br><span class="line">n = Length(T)</span><br><span class="line">m = Length(P)</span><br><span class="line">for s = 0 : n - m</span><br><span class="line">    check if (T[s+1..s+m] == P[1..m])</span><br><span class="line">        record s</span><br></pre></td></tr></table></figure>

<p>Naive String Matcher的运行时间为O(m(n-m+1))，它在发现T和P某一位匹配不成功以后，又会立即从T的下一位对P从头开始匹配，这样的效率是很底下的，因为它忽略了匹配过程中获得的一些信息，而这些信息可能是非常有用的。比如P=aaab，如果T=aaabcaaab，我们发现位移s=0是有效的，那么位移s=1,2,3都不是有效的，因为T[4]=b。</p>
<h2 id="KMP匹配算法"><a href="#KMP匹配算法" class="headerlink" title="KMP匹配算法"></a>KMP匹配算法</h2><p>KMP算法是由Knuth、Morris和Pratt三人共同设计的，它的运行时间为O(n)，需要额外空间O(m)，也就是数组π[1..m]，它是事先根据模式P计算出来的，用来辅助我们进行字符串匹配。</p>
<p>在理解KMP算法过程之前，我们要知道几个概念：</p>
<ul>
<li>前缀：若对于某个字符有x=wy（x,y不为空），我们就称字符串w是字符串x的前缀，比如abca的前缀有{∅, a, ab, abc, abca}；</li>
<li>后缀：若对于某个字符有x=yw（x,y不为空），我们就称字符串w是字符串x的后缀，比如abca的后缀有{∅, a, ca, bca, abca}；</li>
<li>真前缀：不包括自身的前缀；</li>
<li>真后缀：不包括自身的后缀；</li>
</ul>
<p>不管是算法导论（第二版）上的讲解或者是网上博客都把KMP分为两步，第一个是计算这个辅助数组，算法导论上称为模式的前缀函数π，网上的博客称为next数组；第二步是利用辅助数组进行匹配。</p>
<h3 id="Prefix-Function"><a href="#Prefix-Function" class="headerlink" title="Prefix Function"></a>Prefix Function</h3><p>本文以算法导论的命名方式来，模式的前缀函数π（prefix function）包含了模式与其自身的位移进行匹配的信息。可以把这些信息用于朴素字符串匹配算法中，避免对无效位移进行测试。</p>
<p>对模式P[1..m]，我们定义前缀函数π[i]为子串P[1..i]的<strong>真后缀</strong>的最长前缀的长度（1&lt;=i&lt;=n）。是不是很拗口，别急，我举个例子你就明白了，对于字符串<code>&quot;ababa&quot;</code>，它的真后缀有{a,ba,aba,baba,∅}，它的前缀有{a,aba,abab}，它的真后缀的最长前缀为<code>&quot;aba&quot;</code>，所以这里可得π[5]=3。（很多博客这里就没有讲清楚，所以大家就没看明白）还不懂的可看下图：</p>
<blockquote>
<pre><code>1 2 3 4 5     ....字符串下标
a b a b a     ....
    a b a b a ....π[5] = 3
    1 2 3 4 5 ....字符串下标</code></pre></blockquote>
<p>下面讨论如何求解模式P的前缀函数π[1..n]，假设我们现在已经求得了π[0]，π[1]，···，π[i-1]，那么如何求解π[i]呢？如果P[π[i-1]+1]=P[i]相等，那么π[i]=π[i-1]+1；如果不相等，则要进行回溯，具体是如何进行呢，我稍后解释，先看算法导论上的伪代码，我再逐行解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Compute-Prefix-Function(P)</span><br><span class="line">m = Length(P)</span><br><span class="line">π[1] = 0</span><br><span class="line">k = 0</span><br><span class="line">for q = 2 : m</span><br><span class="line">    while k &gt; 0 &amp;&amp; P[k+1] != P[q]</span><br><span class="line">        k = π[k]</span><br><span class="line">    if P[k+1] == P[q]</span><br><span class="line">        k = k + 1</span><br><span class="line">    π[q] = k</span><br><span class="line">return π</span><br></pre></td></tr></table></figure>

<p>代码第二行，根据定义单个字符π[1]=0，没有问题；</p>
<p>结合一个例子我们来分析，若P[1..n]=”ababababca”，n=10，我们先不看代码，可以根据定义求出π数组如下：</p>
<blockquote>
<pre><code>i     1 2 3 4 5 6 7 8 9 10
P[i]  a b a b a b a b c a
π[i]  0 0 1 2 3 4 5 6 0 1</code></pre></blockquote>
<p>计算过程如下：</p>
<ul>
<li>i=1，p[1]=”a”，显然π[1]=0；</li>
<li>i=2，p[2]=”ab”，真后缀与前缀没有相同的，π[2]=0；</li>
<li>i=3，p[2]=”aba”，真后缀与前缀最长的字符串为”a”，所以π[3]=1；</li>
<li>i=4，p[2]=”abab”，真后缀与前缀最长的字符串为”ab”，所以π[4]=2；</li>
<li>i =  …</li>
</ul>
<p>我们注意到，这么计算难免过于繁琐，每次都要求出真后缀和前缀，能不能简单一点呢？当然能，我们若得到了π[i-1]=k，那么我们知道在模式P[1..i-1]中有子串P[1..k]和P[i-k..i-1]是相等的，现在要求出P[1..i]的π[i]，如果P[k+1]处的字符与P[i]处的相等，那么我们知道子串P[1..k+1]和P[i-k..i]也是肯定相等的。</p>
<p>举个例子，对上面的字符我们已知P[1..4]=”abab”对于的π[4]=2，就是说子串P[1..2]等于P[3..4]，现在要求π[5]，怎么求呢？我们发现字符P[π[4]]=P[2]和字符P[5]相等都为’a’，那么显然有P[1..3]等于P[3..5]，即π[5]=2+1=3。</p>
<p>这也就是对程序8-9行的解释。k的值始终是前一个子串（P[1..q-1]）的真后缀的最长前缀的长度。</p>
<p>那么更严峻的问题来了，如果不相等呢？也就是说P[k+1]不等于P[i]了，那么我们现在当然要进行往回探测，看代码中我们是直接回到π[k]处，这是为什么呢？按道理来说我们应该是依次回到k，k-1，···，1，这样的顺序。</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/string-match-kmp/kmp1.png" alt="kmp-prefix-function"></p>
<p>如上图所示，假设我们要退回到k处，注意已知条件，我们现在有π[i-1]=k，即P[1..k]=P[i-k..i-1]，由于P[i]!=P[k+1]，我们要检查P[1..k]与P[i-K+1..i]是否相等，这就是相当于检查P[1..k]中第一个字符是否等于第二个字符，第二个字符是否等于第三个字符，···。除非P[1..k]中所有的的字符都相等，否则是不能成立的，因此我们还不如直接退回到π[k]（表示字符P[1..π[k]]的真后缀的最长前缀的长度）处，<strong>因为我们总能保证P[1..π[k]]与P[i-π[k]..i-1]相等</strong>。（不明白的想一想π[k]的定义）</p>
<p>好了，上面就是程序6-7行的解释了，至此我们求解辅助函数完成，接下来匹配就稍微easy些了。</p>
<h3 id="KMP-Match"><a href="#KMP-Match" class="headerlink" title="KMP Match"></a>KMP Match</h3><p>读懂了前缀函数的求解方法，我们就已经克服了最困难的部分，接下来一鼓作气，看看匹配的过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KMP-Matcher(T, P)</span><br><span class="line">n = Length(T)</span><br><span class="line">m = Length(P)</span><br><span class="line">π[1..m] = Compute-Prefix-Function(P)</span><br><span class="line"></span><br><span class="line">q = 0</span><br><span class="line">for i = 1 : n</span><br><span class="line">    while q &gt; 0 &amp;&amp; P[q + 1] != T[i]</span><br><span class="line">        q = π[q]</span><br><span class="line">    if P[q + 1] == T[i]</span><br><span class="line">        q = q + 1</span><br><span class="line">    if q == m</span><br><span class="line">        record (shift) s = i - m</span><br><span class="line">        q = π[q]</span><br></pre></td></tr></table></figure>

<p>可以看到程序中在文本T上的下标i是永不回退的，只有在模式P上的下标q会回退。</p>
<p>如果大家对第8-9行还有点模糊的话，我在这里再啰嗦的解释一下，看下面的例子：</p>
<blockquote>
<pre><code>T ... c b a b a b a a b c...
      | | | | | ~
P     a b a b a c a</code></pre></blockquote>
<p>当进行到某一位置使T[i]!=P[5+1]，这就发生了程序第8-9行的情形，这是我们就根据计算的π[5]=3的值，因为π[5]的值表示了P[1..3]和P[3..5]是相等字符，这也是我们计算π的意义所在，把指针q往回退到3处：</p>
<blockquote>
<pre><code>T ... c b a b a b a a b c...
          | | |
P         a b a b a c a</code></pre></blockquote>
<p>然后继续对P[q+1]和T[i]进行匹配。</p>
<p>呼<del>~</del>终于写完了，也是花了我2天才理解透这个算法，若有不对的地方，欢迎大家拍砖指正。</p>
<hr>
<p>2017.08.20更新</p>
<p>附上C++实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// author: Klaus</span></span><br><span class="line"><span class="comment">// using KMP string match.</span></span><br><span class="line"><span class="comment">// find the first occurrence position of string "str" in string "t".</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; t, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = t.length();</span><br><span class="line">    <span class="keyword">int</span> m = str.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(m, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; str[k] != str[i])</span><br><span class="line">            k = pre[k];</span><br><span class="line">        <span class="keyword">if</span> (str[i] == str[k])</span><br><span class="line">            k += <span class="number">1</span>;</span><br><span class="line">        pre[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; t[i] != str[q])</span><br><span class="line">            q = pre[q];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t[i] == str[q])</span><br><span class="line">            q += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q == m)</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<ul>
<li>Introduction to Algorithms-2ed edition.</li>
<li><a href="http://blog.csdn.net/fightlei/article/details/52712461" target="_blank" rel="noopener">详细解读KMP模式匹配算法 - ZhangLei的博客</a></li>
<li><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">Knuth–Morris–Pratt algorithm - Wikipedia</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>KMP</tag>
        <tag>String Match</tag>
      </tags>
  </entry>
  <entry>
    <title>取随机数的一些思考</title>
    <url>/2017/07/27/get-random-numbers/</url>
    <content><![CDATA[<p>我们知道，在C++头文件<code>cstdlib</code>中有一个<code>rand()</code>函数，就是用来产生（伪）随机数的<a id="more"></a>。它产生的随机数范围默认在<code>[0, RAND_MAX]</code>，RAND_MAX的大小与标准库具体实现有关，一般认为是不小于32767（0x7FFF）。</p>
<p>还有一个与<code>rand()</code>息息相关的函数：<code>srand()</code>，它用来为<code>rand()</code>设置产生随机数的种子，因为相同种子的值返回的随机数值是一样的，这样失去了随机性的意义，为使每次得到的随机数不一样，我们用<code>time(0)</code>的返回值或NULL来当做种子，这样使得每次运行产生的随机数都不同。</p>
<p>看个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rand() % <span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>这样每次产生的都是0-9之间的随机数。</p>
<p>有一个技巧需要我们记住：如果我们要产生分布在<code>[x,y]</code>区间内的随机数，那么应该使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rand() % (y - x + <span class="number">1</span>) + x;</span><br></pre></td></tr></table></figure>

<p>好了，下面问题来了，如果现在我们有两个整数m和n，其中<code>m &lt; n</code>，我们要输出分布在区间<code>[0, n-1]</code>内的m个随机整数，要求不能包含重复元素，并且要有序的输出，那么这个时候该怎么做呢？</p>
<p>首先比较直观的解法就是在一个空的集合里面插入产生的随机数，直到达到m个为止，伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">initialize <span class="title">size</span><span class="params">(S)</span> </span>= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">while size(S) &lt; m </span><br><span class="line">    t = rand() % n</span><br><span class="line">    <span class="keyword">if</span> t is <span class="keyword">not</span> is S</span><br><span class="line">        insert t into S</span><br><span class="line">    ++size(S)</span><br><span class="line"></span><br><span class="line">print the elements of S in sorted order</span><br></pre></td></tr></table></figure>

<p>很容易想到可以用STL中的<code>set</code>（关键字不重复而且插入有序）来解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gensets</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (s.size() &lt; m)</span><br><span class="line">        s.insert(rand() % n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : s)</span><br><span class="line">        count &lt;&lt; i &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这个方法在m和n的值比较接近时，运行时间会比较慢。接下来我们看这个解法（是来源于Don Knuth）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genknuth</span> <span class="params">(<span class="keyword">int</span> m ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rand() % (n - i) &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            --m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以简单证明每次选取的概率都是m/n：比如i=0时被选出的概率为m/n；那么i=1被选出的概率为：(m/n) * ((m-1)/(n-1)) + (1-m/n) * (m/(n-1)) = m/n（此时分两种情况：i=0已经被选中和i=0没有被选中）；以此类推。。</p>
<p>还有一种解法就是把包含整数0~n-1的数组顺序打乱，然后把前m个元素有序输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    vec[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = rand() % (n - i) + i;</span><br><span class="line">    swap(vec[i], vec[tmp]);</span><br><span class="line">&#125;</span><br><span class="line">sort(vec.begin(), vec.begin() + m);</span><br></pre></td></tr></table></figure>

<p>蓄水池采样：针对n很大，或者未知的情况，要在其中随机选择m个样本。</p>
<p>解决思路：先把读到的前k个对象放入“水库”，对于第k+1个对象开始，以k/(k+1)的概率选择该对象，以k/(k+2)的概率选择第k+2个对象，以此类推，以k/m的概率选择第m个对象（m&gt;k）。如果m被选中，则随机替换水库中的一个对象。终每个对象被选中的概率均为k/n。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A function to randomly select k items from stream[0..n-1].</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectKItems</span><span class="params">(<span class="keyword">int</span> stream[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">// index for elements in stream[]</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// reservoir[] is the output array. Initialize it with</span></span><br><span class="line">    <span class="comment">// first k elements from stream[]</span></span><br><span class="line">    <span class="keyword">int</span> reservoir[k];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        reservoir[i] = stream[i];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Use a different seed value so that we don't get</span></span><br><span class="line">    <span class="comment">// same result each time we run this program</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Iterate from the (k+1)th element to nth element</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Pick a random index from 0 to i.</span></span><br><span class="line">        <span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// If the randomly  picked index is smaller than k, then replace</span></span><br><span class="line">        <span class="comment">// the element present at the index with new element from stream</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; k)</span><br><span class="line">          reservoir[j] = stream[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Following are k randomly selected items \n"</span>);</span><br><span class="line">    printArray(reservoir, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>洗牌算法：把54张牌完全随机打乱，一共有$A^{54}_{54}$种可能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">54</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t = i + rand() % (<span class="number">54</span> - i + <span class="number">1</span>);</span><br><span class="line">    swap(nums[i], nums[t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ul>
<li>《Programming Pearls 2ed Edition》，Jon Bentley。</li>
<li><a href="http://www.geeksforgeeks.org/reservoir-sampling/" target="_blank" rel="noopener">http://www.geeksforgeeks.org/reservoir-sampling/</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Random</tag>
      </tags>
  </entry>
  <entry>
    <title>Win7下在VS2012中配置OpenCV3.0.0</title>
    <url>/2016/06/07/initial-opencv300/</url>
    <content><![CDATA[<p>最早接触<a href="http://opencv.org/" target="_blank" rel="noopener">OpenCV</a>还是大四做毕设的时候，那个时候用的还是2.4的版本，配置环境也不是一件很简单的事情。<a id="more"></a></p>
<p>现在做一个课程设计要用到OpenCV，所以就寻思着再配一遍，<strong>注意</strong>：我下载的是OpenCV3.0.0版本，我的配置方案对于2.4.x的版本可能不适用。</p>
<p>下面介绍两种方法来在VS2012中配置OpenCV3.0.0：</p>
<h2 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h2><p>首先当然是配置环境变量，（老套路了，安装Java的时候也要配置环境变量）在系统变量的<code>path</code>中追加两条:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\opencv\build\x86\vc11\bin;D:\opencv\build\x64\vc11\bin;</span><br></pre></td></tr></table></figure>

<p>当然你的可能会和我的不一样，看你OpenCV存放的路径而定，这里我们为了在Win32和64下都能跑，所以加了两条记录，<code>vc11</code>代表的就是VS2012，你也会目录下看到<code>vc12</code>指的是VS2013。</p>
<p>接下来新建一个名为<code>opencv3.0.0.props</code>（文件名可任意起，后缀名不能）的配置文件，把下面的内容复制进去：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">ToolsVersion</span>=<span class="string">"4.0"</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/developer/msbuild/2003"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImportGroup</span> <span class="attr">Label</span>=<span class="string">"PropertySheets"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Label</span>=<span class="string">"UserMacros"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">IncludePath</span>&gt;</span>D:\opencv\build\include;$(IncludePath)<span class="tag">&lt;/<span class="name">IncludePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LibraryPath</span> <span class="attr">Condition</span>=<span class="string">"'$(Platform)'=='Win32'"</span>&gt;</span>D:\opencv\build\x86\vc11\lib;$(LibraryPath)<span class="tag">&lt;/<span class="name">LibraryPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LibraryPath</span> <span class="attr">Condition</span>=<span class="string">"'$(Platform)'=='X64'"</span>&gt;</span>D:\opencv\build\x64\vc11\lib;$(LibraryPath)<span class="tag">&lt;/<span class="name">LibraryPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">Condition</span>=<span class="string">"'$(Configuration)'=='Debug'"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AdditionalDependencies</span>&gt;</span>opencv_ts300d.lib;opencv_world300d.lib;%(AdditionalDependencies)</span><br><span class="line">      <span class="tag">&lt;/<span class="name">AdditionalDependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">Condition</span>=<span class="string">"'$(Configuration)'=='Release'"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AdditionalDependencies</span>&gt;</span>opencv_ts300.lib;opencv_world300.lib;%(AdditionalDependencies)</span><br><span class="line">      <span class="tag">&lt;/<span class="name">AdditionalDependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们在VS2012下新建一个<code>Win32控制台应用程序</code>，打开<code>属性管理器</code>，右键工程名，选择<code>添加现有属性表</code>：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/initial-opencv/1/1.png" alt="1"><br>然后选择我们刚才新建的文件<code>opencv3.0.0.props</code>就好了。可以直接去我的github下载：<a href="https://github.com/guansdu/config-opencv3.0.0" target="_blank" rel="noopener">download-props</a>。</p>
<p>最后用一个简单的程序测试下配置是否成功了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(  )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat image;</span><br><span class="line">	image = imread(<span class="string">"D:/banner.jpg"</span>, IMREAD_COLOR); <span class="comment">// Read the file</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( image.empty() )                      <span class="comment">// Check for invalid input</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;  <span class="string">"Could not open or find the image"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> ;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	namedWindow( <span class="string">"Display window"</span>, WINDOW_AUTOSIZE ); <span class="comment">// Create a window for display.</span></span><br><span class="line"></span><br><span class="line">	imshow( <span class="string">"Display window"</span>, image );                <span class="comment">// Show our image inside it.</span></span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>); <span class="comment">// Wait for a keystroke in the window</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝文件到工程里"><a href="#拷贝文件到工程里" class="headerlink" title="拷贝文件到工程里"></a>拷贝文件到工程里</h2><p>有时候我们需要让我们的程序在没有安装OpenCV的电脑上运行，这时候我们就可以采用下面介绍的这种方法。</p>
<p>将OpenCV3.0.0中以下三个文件夹拷贝到工程目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...\opencv\build\include</span><br><span class="line">...\opencv\build\x86\vc11\bin</span><br><span class="line">...\opencv\build\x86\vc11\lib</span><br></pre></td></tr></table></figure>

<p>拷贝后的工程目录结构为：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/initial-opencv/2/2.PNG" alt="2"><br>然后打开工程属性页面，</p>
<p>修改<code>配置属性</code>下<code>VC++目录</code>的<code>包含目录</code>和<code>库目录</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">包含目录添加：</span><br><span class="line">.\include</span><br><span class="line">.\include\opencv</span><br><span class="line">.\include\opencv2</span><br><span class="line">库目录添加：</span><br><span class="line">.\lib</span><br></pre></td></tr></table></figure>

<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/initial-opencv/3/3.png" alt="3"><br>修改<code>配置属性</code>下<code>链接器</code>的<code>附加依依赖项</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加：</span><br><span class="line">opencv_ts300d.lib</span><br><span class="line">opencv_world300.lib</span><br></pre></td></tr></table></figure>

<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/initial-opencv/4/4.png" alt="4"><br>至此，配置完成。</p>
<p><strong>注意</strong>：若出现找不到dll的问题，尝试修改项目的<code>配置属性</code>-<code>调试</code>-<code>工作目录</code>，使其指向bin文件夹。</p>
<p>同样可以写程序测试一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/opencv2/imgcodecs/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat image;</span><br><span class="line"></span><br><span class="line">	image = imread(<span class="string">"D:/banner.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( image.empty() )               </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"Could not open or find the image"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> ;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	namedWindow( <span class="string">"Display window"</span>, WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">	imshow( <span class="string">"Display window"</span>, image );       </span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; CV_VERSION &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有问题欢迎交流(<em>^__^</em>)</p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（二）:allocator</title>
    <url>/2016/06/16/learn-stl2-allocator/</url>
    <content><![CDATA[<p>在C++中，一般看到的内存配置和释放操作是这样的：<a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>...&#125;;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure>

<p>这其中new包含两部分操作：（1）调用::operator new配置内存；（2）调用Foo::Foo()构造对象内容。delete也包含两部分：（1）调用Foo::~Foo()析构对象；（2）调用::operator delete释放内存。</p>
<p>在SGI STL中，内存配置动作由<code>alloc:allocate()</code>负责，内存释放动作由<code>alloc::deallocate()</code>负责；对象构建操作由<code>::construct()</code>负责，对象析构操作由<code>::destroy()</code>负责。</p>
<p>在内存的配置和释放方面，SGI设计了双层配置器，第一级配置器直接使用<code>malloc()</code>和<code>free()</code>，第二级配置器则视情况采用不用的策略：如果配置区块大于128bytes，就调用第一级配置器；当配置区块小玉128bytes，便采用复杂的memory pool方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SGI STL第一级配置器</span><br><span class="line">class _malloc_alloc_template</span><br><span class="line">其中：</span><br><span class="line">1. allocate()直接使用malloc()</span><br><span class="line">   deallocate()直接使用free()</span><br><span class="line">2. 模拟C++的set_new_handler()以便处理内存不足的状况</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SGI STL第二级配置器</span><br><span class="line">class _default_alloc_template</span><br><span class="line">其中：</span><br><span class="line">1. 维护16个自由链表（free lists）</span><br><span class="line">   负责16种小型区块的此配置能力</span><br><span class="line">   内存池（memory pool）以malloc()配置而得</span><br><span class="line">   如果内存不足，转调用第一级配置器</span><br><span class="line">2. 如果需求区块大于128bytes，就调用第一级配置器</span><br></pre></td></tr></table></figure>

<p>STL中有五个全局函数，用于未初始化的空间上，除了前面说的<code>construct()</code>和<code>destroy()</code>之外，还有<code>uninitialized_copy(), uninitialized_fill(), uninitialized_fill_n()</code>。</p>
<p>这三个函数在实现过程中也使用了traits机制：首先萃取出迭代器的value_type，然后判断该类型是否为POD类型，最后根据是is-POD还是non-POD来采用不同操作：对is-POD采取最有效率的初值填写手法，对non-POD采取最保险安全的做法。</p>
<p><strong>注</strong>：POD(plain old data)，也就是标量型别scalar type或者传统的C struct型别，POD型别必然有trivial ctor/dtor/copy/assignment函数，参考维基百科：<a href="https://zh.wikipedia.org/wiki/POD" target="_blank" rel="noopener">POD</a></p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（一）:template</title>
    <url>/2016/06/03/learn-stl1-template/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近打算抽时间开始看侯捷老师的<strong>STL源码剖析</strong>，作为预备知识，首先当然要复习下STL的一些基本内容。</p>
<a id="more"></a>
<h2 id="关于STL"><a href="#关于STL" class="headerlink" title="关于STL"></a>关于STL</h2><p>STL（英文：Standard Template Library）是一套强大的C++程序库，包含了六大组件：</p>
<ul>
<li>容器（containers）</li>
<li>算法（algorithms）</li>
<li>迭代器（iterators）</li>
<li>仿函数（functors）</li>
<li>适配器（adapters）</li>
<li>配置器（allocators）</li>
</ul>
<h2 id="C-Template"><a href="#C-Template" class="headerlink" title="C++ Template"></a>C++ Template</h2><p>STL几乎每个部分都用到了template，所以我们在使用STL之前有必要理解template。</p>
<p>Template允许我们定义一个抽象的类或者函数，而我们不需要确切的知道这个类或者函数所操作的数据类型，从本质上说就是一种<code>generic programming</code>。</p>
<p>有了template，可以让我们更加关注类或者函数里的算法思想，因为一个类或者函数可以处理几种不同数据类型的数据，我们不必去关心某种数据类型的细微差异。</p>
<h3 id="class-templates"><a href="#class-templates" class="headerlink" title="class templates"></a>class templates</h3><p>类模板的基本语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//do something...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>举个例子我们定义如下的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">DoMulitply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">DoAdd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Calc::DoMulitply(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Calc::DoAdd(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然上面的类只可以处理int型数据，现在我们用template改造一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CalcT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">T <span class="title">DoMulitply</span><span class="params">(T x, T y)</span></span>;</span><br><span class="line">  <span class="function">T <span class="title">DoAdd</span><span class="params">(T x, T y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">CalcT</span>&lt;T&gt;:</span>:DoMulitply(T x, T y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">CalcT</span>&lt;T&gt;:</span>:DoAdd(T x, T y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意到这里类的成员函数里面有3个T，这里解释下各自的含义：第一个T是模板参数，第二个是函数的返回类型，第三个T指出了该函数的模板参数也是类的模板参数。</strong></p>
<p>现在我们这个类可以用以下方式处理就不同类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CalcT&lt;<span class="keyword">double</span>&gt; calc_double;</span><br><span class="line">calc_double.DoAdd(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line">CalcT&lt;<span class="keyword">int</span>&gt; calc_int;</span><br><span class="line">calc_int.DoMulitply(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="function-templates"><a href="#function-templates" class="headerlink" title="function templates"></a>function templates</h3><p>函数模板的基本语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">FuncName</span>(<span class="title">T</span> <span class="title">arg1</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个模板参数的话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>, ...&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如写一个简单的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用template修改下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">MaxT</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就可以用不同类型了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; MaxT(<span class="number">1.2</span>, <span class="number">2.2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MaxT(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MaxT(<span class="string">'a'</span>, <span class="string">'b'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//can also use MaxT&lt;int&gt;(1, 2)</span></span><br></pre></td></tr></table></figure>

<p>代码在VC++6.0上运行，可以参阅<a href="https://github.com/guansdu/Learning-STL/tree/master/template" target="_blank" rel="noopener">learn-stl-template</a>。</p>
<p>参考资料：</p>
<ol>
<li><p><a href="http://www.cprogramming.com/tutorial/templates.html" target="_blank" rel="noopener">Templates and Template Classes in C++</a></p>
</li>
<li><p><a href="http://www.cplusplus.com/doc/tutorial/templates/" target="_blank" rel="noopener">Classes (II)–Class templates</a></p>
</li>
<li><p><a href="http://www.cprogramming.com/tutorial/templated_functions.html" target="_blank" rel="noopener">Templated Functions</a></p>
</li>
<li><p><a href="http://en.cppreference.com/w/cpp/language/function_template" target="_blank" rel="noopener">Function template</a></p>
</li>
<li><p><a href="http://www.codeproject.com/Articles/257589/An-Idiots-Guide-to-Cplusplus-Templates-Part" target="_blank" rel="noopener">An Idiot’s Guide to C++ Templates</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（五）:heap</title>
    <url>/2016/07/15/learn-stl5-heap/</url>
    <content><![CDATA[<p>heap并不是STL的容器组件，它扮演幕后英雄的角色，<a id="more"></a>为priority queue提供支持。顾名思义，priority queue就是（最大）优先级队列，允许用户以任意的顺序把元素（push）放入容器中，但是进行（pop）出队操作时，按照元素优先级最大的，排在最前面，在第一个弹出。</p>
<h2 id="heap概述"><a href="#heap概述" class="headerlink" title="heap概述"></a>heap概述</h2><p>heap是一种完全二叉树（complete binary tree），也就是说,只有最下面两层结点的度能小于2，并且最底层的叶结点由左到右不得有空隙。</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/learn-stl-heap%2Fheap1.png" alt="一个完全二叉树以及其数组表示"><br>根据heap的特性，在STL中用vector了存储所有的结点 ；若将vector的第0的元素保留，已知某个结点位于vector的i处，那么可以知道其父结点下标为<code>parent(i) = i/2</code>，左子结点下标为<code>left(i) = 2i</code>，右子结点下标为<code>right(i) = 2i+1</code>。（’/‘表示高斯符号，取不超过i/2的最大整数）</p>
<p>heap分为max-heap和min-heap。在STL中提供的是max-heap，所以本篇文章也是讲的max-heap。max-heap是指每个结点的键值（key）都大于等于其子结点的键值，因此，max-heap的最大值位于根结点，也就是在vector的起头处。</p>
<h2 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h2><h3 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h3><p>新加入一个结点。先放在最底层最右叶结点，也就是放在vector的<code>end()-1</code>处，然后为了保持max-heap的性质，执行一个percolate up（上溯）的过程：将新结点与父结点比较，如果大于父结点的键值，就与父结点交换位置，如此反复，直到不需要交换或者根结点为止。</p>
<h3 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h3><p>取出根结点，也就是最大值所在的结点（实际上STL只是将它移到了vector的尾部）。为了保持max-heap的性质，必须割舍掉最底层最右边的叶结点，并将其重新安插至合适的位置，执行一个percolate down（下溯）的过程：从根节点开始将空洞节点（一开始是根节点）和较大子节点交换，并持续向下进行，直到到达叶节点为止。然后将被割舍的元素值赋给“已到达叶结点的空洞结点”，并再执行一次percolate up过程。</p>
<h3 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h3><p>每次pop_heap都将最大值放到了vector的末尾，我们可以持续对整个heap做pop_heap操作，每次将操作范围从后向前缩小一个元素，这样我们便可以得到一个递增序列。</p>
<h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h3><p>将一个已有的vector数据转化为一个heap，就是从第i个元素开始（<code>i = vector.size()/2 ; i&gt;=0 ; i--</code>）不断调整结点顺序使其满足heap的性质。</p>
<h2 id="heap实现"><a href="#heap实现" class="headerlink" title="heap实现"></a>heap实现</h2><p>我对书中给的源码稍作修改使之简洁一些，注释也已经很详尽了，大家应该都能看懂，可以自己运行测试。分为两个文件一个是<code>my_heap.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//author:Klaus</span></span><br><span class="line"><span class="comment">//time:2016/7/15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_HEAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _MY_HEAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeHeap</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator first, <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//长度为0或者1时，不需要任何操作</span></span><br><span class="line">	<span class="keyword">if</span> (last - first &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="comment">//待建堆的元素个数</span></span><br><span class="line">	<span class="keyword">ptrdiff_t</span> len = last - first;</span><br><span class="line">	<span class="comment">//只需要对非叶子结点进行重排即可，找到最后一个非叶子结点</span></span><br><span class="line">	<span class="comment">//这里下标从0开始，所以最后一个非叶子结点下标为(len-2)/2</span></span><br><span class="line">	<span class="comment">//注意：vector的范围是[first,last)，半闭半开区间，所以这里不是(len-1)/2</span></span><br><span class="line">	<span class="keyword">ptrdiff_t</span> parent = (len - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AdjustHeap&lt;T&gt;(first, parent, len, T(*(first + parent)));</span><br><span class="line">		<span class="keyword">if</span> (parent == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		parent--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushHeap</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator first, <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//新插入的值已经放入了vector的尾部，则初始空洞结点就是vector的尾端元素</span></span><br><span class="line">	<span class="comment">//topIndex为根结点的下标，这里设置为0</span></span><br><span class="line">	_PushHeap&lt;T&gt;( first, <span class="keyword">ptrdiff_t</span>((last - first) - <span class="number">1</span>), <span class="number">0</span>, T(*(last - <span class="number">1</span>)) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _PushHeap(<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator first, <span class="keyword">ptrdiff_t</span> holeIndex, <span class="keyword">ptrdiff_t</span> topIndex, T value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//找到空洞元素的父结点</span></span><br><span class="line">	<span class="keyword">ptrdiff_t</span> parent = (holeIndex <span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//未到达根结点，且父结点的值小于value</span></span><br><span class="line">	<span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//把父结点的值赋给空洞结点</span></span><br><span class="line">		*(first + holeIndex) = *(first + parent);</span><br><span class="line">		<span class="comment">//设置新的空洞结点</span></span><br><span class="line">		holeIndex = parent;</span><br><span class="line">		<span class="comment">//新的空洞结点的父结点</span></span><br><span class="line">		parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*(first + holeIndex) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopHeap</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator first, <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//value用来保存尾结点的值</span></span><br><span class="line">	T value = T(*(last<span class="number">-1</span>));</span><br><span class="line">	<span class="comment">//将尾结点的值设置为首结点的值，这样我们就可以用pop_back操作取出</span></span><br><span class="line">	*(last<span class="number">-1</span>) = *first;</span><br><span class="line">	<span class="comment">//第二个参数ptrdiff_t holeIndex：初始空洞结点就是0，即为根结点；</span></span><br><span class="line">	<span class="comment">//第三个参数ptrdiff_t len：对区域[first,last-1)进行调整，使之符合堆的性质</span></span><br><span class="line">	AdjustHeap&lt;T&gt;(first, <span class="number">0</span>, <span class="keyword">ptrdiff_t</span>(last - first - <span class="number">1</span>), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustHeap</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator first, <span class="keyword">ptrdiff_t</span> holeIndex, <span class="keyword">ptrdiff_t</span> len, T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//保存根结点的下标</span></span><br><span class="line">	<span class="keyword">ptrdiff_t</span> topIndex = holeIndex;</span><br><span class="line">	<span class="comment">//初始为空洞结点的右子结点</span></span><br><span class="line">	<span class="keyword">ptrdiff_t</span> bigChild = <span class="number">2</span>*holeIndex+<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (bigChild &lt; len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//比较空洞结点左右子大小，使之成为较大的子结点</span></span><br><span class="line">		<span class="keyword">if</span> (*(first + bigChild) &lt; *(first + bigChild - <span class="number">1</span>))</span><br><span class="line">			bigChild--;</span><br><span class="line">		<span class="comment">//把大的子结点赋值给空洞结点</span></span><br><span class="line">		*(first + holeIndex) = *(first + bigChild);</span><br><span class="line">		holeIndex = bigChild;</span><br><span class="line">		<span class="comment">//为新空洞结点的右子结点</span></span><br><span class="line">		bigChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bigChild == len)</span><br><span class="line">	&#123;</span><br><span class="line">		*(first + holeIndex) = *(first + bigChild - <span class="number">1</span>);</span><br><span class="line">		holeIndex = bigChild - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里直接用*(first+holeIndex) = value是不正确的，侯捷的书中有误。</span></span><br><span class="line">	<span class="comment">//注意：最后将value放在最后的空洞结点位置时，要再执行一次percolate up上溯操作</span></span><br><span class="line">	<span class="comment">//因为直接赋值后可能不满足堆的性质。</span></span><br><span class="line">	_PushHeap&lt;T&gt;(first, holeIndex, topIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortHeap</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator first, <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一次执行PopHeap，最大值就被放在vector的尾端</span></span><br><span class="line">	<span class="comment">//扣除尾端再执行一次PopHeap，次大值又被放在尾端</span></span><br><span class="line">	<span class="comment">//如此反复，即可得到递增序列</span></span><br><span class="line">	<span class="keyword">while</span> (last - first &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PopHeap&lt;T&gt;(first, last--);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_MY_HEAP_H</span></span></span><br></pre></td></tr></table></figure>

<p>一个是<code>stl_heap.cpp</code>用于测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_heap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve(ia, ia+<span class="number">9</span>);</span><br><span class="line">	MakeHeap&lt;<span class="keyword">int</span>&gt; (ve.begin(), ve.end());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve.size(); i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ve[i] &lt;&lt; <span class="string">" "</span>;    <span class="comment">//9  5 8 3 4 0 2 3 1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	ve.push_back(<span class="number">7</span>);</span><br><span class="line">	PushHeap&lt;<span class="keyword">int</span>&gt;(ve.begin(), ve.end());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve.size(); i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ve[i] &lt;&lt; <span class="string">" "</span>;    <span class="comment">//9 7 8 3 5 0 2 3 1 4</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	PopHeap&lt;<span class="keyword">int</span>&gt; (ve.begin(), ve.end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve.size(); i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ve[i] &lt;&lt; <span class="string">" "</span>;    <span class="comment">//8 7 4 3 5 0 2 3 1 9</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	ve.pop_back();    <span class="comment">//remove 9</span></span><br><span class="line">	SortHeap&lt;<span class="keyword">int</span>&gt;(ve.begin(), ve.end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve.size(); i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ve[i] &lt;&lt; <span class="string">" "</span>;    <span class="comment">//0 1 2 3 3 4 5 7 8</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码我放在github上了，下载地址：<a href="https://github.com/guansdu/Learning-STL/tree/master/heap" target="_blank" rel="noopener">learn-stl-heap</a>。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（十）:algorithm之binary search</title>
    <url>/2017/01/13/learn-stl10-algorithm/</url>
    <content><![CDATA[<p>了解STL<code>&lt;algorithm&gt;</code>类里面关于binary search的算法：<a id="more"></a></p>
<h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h2><p>函数原型为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">bool</span> <span class="title">binary_search</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>) &#123;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>功能：在有序区间查出指定元素，返回值为<code>true</code> 找到或者<code>false</code> 未找到。</p>
<h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h2><p>函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">ForwardIterator</span> <span class="title">lower_bound</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>) &#123;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>功能：返回一个迭代器，指向有序区间<code>[first, last)</code>里第一个<strong>不小于</strong>val的元素。</p>
<h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h2><p>函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">ForwardIterator</span> <span class="title">upper_bound</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>) &#123;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>功能：返回一个迭代器，指向有序区间<code>[first, last)</code>里第一个<strong>大于</strong>val的元素。</p>
<h2 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h2><p>函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">pair</span>&lt;ForwardIterator,ForwardIterator&gt;</span></span><br><span class="line"><span class="class">  <span class="title">equal_range</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>) &#123;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>功能：返回pair类型，表示一个子区间的起始位置，该子区间里是包含了所有在有序区间<code>[first, last)</code>里所有值等于val的元素。</p>
<p>举例：若对于数组<code>[10, 10, 20, 20, 20, 30]</code>，使用<code>equal_range</code>查找20的话，返回的区间就是<code>[2, 5)</code>。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Binary Search</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（四）:vector</title>
    <url>/2016/07/11/learn-stl4-vector/</url>
    <content><![CDATA[<p>在STL中vector可以说是数组的的一个扩展，它们二者的数据安排<a id="more"></a>以及操作方式十分相似，都定义的是一块连续的线性空间，这也就意味着它们都可以用<strong>普通指针加偏移量</strong>就可以访问其中的各个元素。但是vector是动态空间，大小可以改变；而数组是静态空间，一旦分配后大小就不能改变。</p>
<p>对比其他动态的序列式容器（比如list，deque），vector在随机元素访问上的效率和在末端进行插入、删除元素操作的效率很高；但是在除了末端的元素以外的元素上进行插入、删除操作时的效率就不如其他的这些容器了。</p>
<h2 id="vector结构"><a href="#vector结构" class="headerlink" title="vector结构"></a>vector结构</h2><p>在vector中用两个迭代器<code>start</code>和<code>finish</code>分别指向这一块连续空间中已被使用的范围，用迭代器<code>end_of_storage</code>来指向整块连续空间的末尾。</p>
<p>有了这三个迭代器，便可以轻易实现很多其他功能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  iterator start;</span><br><span class="line">  iterator finish;</span><br><span class="line">  iterator end_of_storage;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end() - begin()); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> size_type(end_of_storage() - begin()); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> begin() == end(); &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以知道，一个vector的容量是大于等于其大小的，一般的vector实际配置的大小比我们声明的要大，以便应对将来可能的扩充。一旦vector的大小等于容量之后，再想要加入元素，就得要申请一块新的内存空间，新的容量大小是一般是原来的<strong>两倍</strong>，然后再将以前的元素全部移动到新的空间里，最后一步就是释放原来的内存空间。</p>
<h2 id="关于push-back"><a href="#关于push-back" class="headerlink" title="关于push_back"></a>关于push_back</h2><p>push_back(n)函数用于把新的元素加入到vector的尾端，具体的操作步骤如下：</p>
<ul>
<li>如果<code>finish != end_of_storage</code>，则说明备用空间还够用，就直接在备用空间上加入新元素,并调整迭代器<code>finish++</code>。</li>
<li>若无备用空间可以，就申请新的空间，新的空间大小为<code>len = (old_size  != 0) ? (2 * old_size) : 1</code>；若原大小为0，则新的空间大小为1；若不为0，则申请配置原来大小两倍的空间。（在书中是这么写的，但实际上STL不同的实现版本这里可能不一样）</li>
<li>将原vector中的元素拷贝到新的vector里，并调整新的<code>new_start</code>和<code>new_finish</code>指向的位置。</li>
<li>释放原vector，调整迭代器<code>start = new_start</code> 、<code>finish = new_finish</code> 、<code>end_of_storage = new_start + len</code>。</li>
</ul>
<p>这里要注意的一个问题就是，<strong>一旦引发了空间的重新配置，原有的迭代器都会失效</strong>，我们在编程中要多多留意。</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>下面说几个容易混淆的函数：</p>
<ul>
<li><strong>size()</strong>：返回改vector中元素的个数，就是实际vector中存放对象的个数。</li>
<li><strong>capacity()</strong>：返回当前分配给vector的存储空间，也用元素的个数来表示，一般大于等于size。额外的空间是为了适应将来vector可能的增加，在一定程度上可以避免申请新的内存空间的发生（是一个很浩大的工程）。</li>
<li><strong>max_size()</strong>：capacity并不能限制vector的大小，当达到capacity大小后vector可以申请新的内存空间。理论上限制vector大小的是max_size，它返回的就是vector可以存放元素的个数的最大值。（但是这个最大值并不能保证vector的大小可以达到这个值，它可能会在达到这个值之前就发生了内存分配失败）</li>
<li><strong>reserve(n)</strong>：更改vector容量的大小，使它至少可以容纳n个元素。若果当前vector的容量小雨n，则会导致vector重新申请新的内存空间使容量达到n或者更大。这个操作不会更改vector的大小（size）和已经存放的元素。</li>
</ul>
<p>其他的一些基本操作我写在代码中了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----init:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(<span class="number">2</span>,<span class="number">9</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----push_buck 1:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.push_back(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//3</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----push_buck 2:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.push_back(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//4</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----push_buck 3:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.push_back(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//5</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----push_buck 4:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.push_back(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//6</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----push_buck 5:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.push_back(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//7</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----now the vector:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iv.size(); i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">" "</span>;	<span class="comment">//9 9 1 2 3 4</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----do pop_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.pop_back();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//6</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----do pop_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.pop_back();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//5</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----do pop_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.pop_back();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//4</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----now the vector:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iv.size(); i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">" "</span>;	<span class="comment">//9 9 1 2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----erase 1:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ivite = find(iv.begin(), iv.end(), <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ivite != iv.end())</span><br><span class="line">	&#123;</span><br><span class="line">		iv.erase(ivite);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//3</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----now the vector:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iv.size(); i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">" "</span>;	<span class="comment">//9 9 2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----insert triple 7 before 2:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ivite = find(iv.begin(), iv.end(), <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ivite != iv.end())</span><br><span class="line">	&#123;</span><br><span class="line">		iv.insert(ivite, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//6</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----now the vector(use at):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iv.size(); i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; iv.at(i) &lt;&lt; <span class="string">" "</span>;	<span class="comment">//9 9 7 7 2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----whether the vector is empty:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iv.empty() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----get the front and back of vector:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iv.front() &lt;&lt; <span class="string">","</span> &lt;&lt; iv.back() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//9,2</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----use the reverse iterator:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit = iv.rbegin();</span><br><span class="line">	<span class="keyword">for</span> (; rit!= iv.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;    <span class="comment">//2 7 7 7 9 9</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----use reserve:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	iv.reserve(<span class="number">15</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//6</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//15</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"max size:"</span> &lt;&lt; iv.max_size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//1073741823</span></span><br><span class="line"></span><br><span class="line">	iv.clear();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; iv.size() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//0</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//15</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在实际运行中你可能得到的capacity和max_size的值和我不一样，这是正常现象。<br>代码在vs2012上运行，下载地址<a href="https://github.com/guansdu/Learning-STL/tree/master/vector" target="_blank" rel="noopener">learn-stl-vector</a>。<br>参考资料：</p>
<ol>
<li><a href="http://www.cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener">vector - C++ Reference</a></li>
</ol>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（三）:traits</title>
    <url>/2016/06/19/learn-stl3-traits/</url>
    <content><![CDATA[<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><p>迭代器（iterator）是一种行为类似于指针的对象<a id="more"></a>，通过它我们可以访问某个容器中所含的各个元素，而又无需暴露该容器的内部表述方式，在STL中要求迭代器至少必须实现前进（operator++）操作和取值（operator*）操作。</p>
<p>迭代器根据移动特性和施行操作可以分为五类：</p>
<ul>
<li>Input iterator：只写</li>
<li>Output iterator：只读</li>
<li>Forward iterator：读写操作</li>
<li>Bidirectional iterator：可双向移动</li>
<li>Random access iterator：（前四种支持operator++，第四种也支持operator–）涵盖所有指针操作，除了++和–还包括p+n,p-n,p[n],p1-p2,p1&lt;p2。</li>
</ul>
<p>迭代器的分类和从属关系如下所示：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/learn-stl3/1.png" alt="iterator从属关系"></p>
<p>STL的设计思想就是将数据容器和算法分开，再以一个粘合剂将它们撮合在一起，这就是迭代器，以算法find()为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(first != last &amp;&amp; * first != value)</span><br><span class="line">        ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><p>在算法中运用迭代器时我们很有可能会用到其相应型别（associated types）,书中指出迭代器相应型别有五种：</p>
<ul>
<li>value_type：是指迭代器所指对象的型别</li>
<li>different_type：用来表示两个迭代器之间的距离</li>
<li>pointer：T* operator*() {}</li>
<li>reference：T&amp; operator-&gt;() {}</li>
<li>iterator_category：前面所说的五种</li>
</ul>
<p>在SGI STL中，用以下的方式萃取迭代器相应型别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type        value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type   difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer           pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference         reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="traits实例"><a href="#traits实例" class="headerlink" title="traits实例"></a>traits实例</h3><p>一般的function template的参数推导机制只能推导参数，不能用于推导函数的返回值，我们需要有更好的方法，这就是用声明内嵌型别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyIter</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">I</span>:</span>:value_type    <span class="comment">//Func的返回值</span></span><br><span class="line">Func(I iter) &#123;</span><br><span class="line">    <span class="keyword">return</span> * iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意的是并不是所有的迭代器都是class type，如果不是class type，就无法为为它定义内嵌类型（比如原生指针就不是）。这时候就需要用到<code>template partial specialization</code>：针对class template中的某个或者数个template参数进行特化工作，也就是将泛化版本中某些参数赋予明确的指定。</p>
<p>对下面一个class template：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>    //可接受<span class="title">T</span>为任意类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们便很容易有以下形式的partial specialization:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;T*&gt;    //仅适用于<span class="title">T</span>为原生指针类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面这个class template专门用来萃取迭代器特性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把上面的Func改写为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:value_type    <span class="comment">//the return type of Func</span></span><br><span class="line">Func(I iter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> * iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的好处就是可以让iterator_traits拥有偏特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;    //<span class="title">native</span> <span class="title">pointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，不管是面对MyIter还是原生指针int*，我们都能traits出正确的value_type。看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span>* pt  = &amp;a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Func(pt) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//output:7</span></span><br><span class="line"></span><br><span class="line">MyIter&lt;<span class="keyword">int</span>&gt; iter(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Func(iter) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//output:8</span></span><br></pre></td></tr></table></figure>

<p>例子的代码在VS2012上编译，下载地址：<a href="https://github.com/guansdu/Learning-STL/tree/master/traits" target="_blank" rel="noopener">learn-stl</a></p>
<h3 id="advance"><a href="#advance" class="headerlink" title="advance()"></a>advance()</h3><p>advance函数是迭代器中常用的操作，它接受两个参数：迭代器p和数值n，功能是将p前进n次。下面看在SGI STL中它的源码，体会traits在实际中的应用：</p>
<p>首先定义五个最为标记的迭代器类别classes，它们只做标记用，不需要任何成员:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random__iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">BidirectionalIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">RandomAccessIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    i += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __advance(i, n, iterator_category(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，advance函数内部实现了三份定义，分别针对InputIterator，BidirectionalIterator和RandomAccessIterator，这样做的原因完全是为了程序执行的效率，针对不同的迭代器类型来调用不同的版本。（没有ForwardIterator是因为它和InputIterator设计的版本完全一致）</p>
<p>每个<code>_anvance()</code>最后的一个参数都只声明型别，并未指定参数名称，因为它纯粹是为了来激活重载机制，而函数之中根本不用这个参数。注意在advance()函数中的iterator_category(i)，在源码中有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt; :</span>: iterator_category</span><br><span class="line">iterator_category(<span class="keyword">const</span> I&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;I&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> category();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将产生一个暂时对象，其型别属于五种迭代器里的一种，然后根据这个型别，编译器才决定调用哪一个_advance()函数。</p>
<p>这样我们就成功在advance函数中利用traits机制来推导出迭代器的类型，从而调用不同版本的_anvance函数。</p>
<hr>
<p>2017.08.13更新</p>
<p>关于STL里面使用的iterator traits机制，还想多说几句，traits不仅可以萃取迭代器类型，也对一般类型有效，STL里面称为type traits，下面就以侯捷书中为原本，稍作修改，做一个简单的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型萃取机制</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板全特化，针对A和B单独的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;A&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;B&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">TestTraits</span>(<span class="title">T</span>&amp; <span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 声明is_POD是一个类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::is_POD_type is_POD;</span><br><span class="line">    <span class="comment">// is_POD()产生一个暂时对象，随后根据不同类型调用不同的函数</span></span><br><span class="line">    <span class="keyword">return</span> __TestTraits(x, is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">TestTraits</span>(<span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 如果T是__true_type，则会调用这个函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"is_POD(): true"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">TestTraits</span>(<span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 如果T是__false_type，则会调用这个函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"is_POD(): false"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    TestTraits(a); <span class="comment">// true</span></span><br><span class="line">    TestTraits(b); <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（七）:deque</title>
    <url>/2016/07/24/learn-stl7-deque/</url>
    <content><![CDATA[<p>vector是单向开口的连续线性空间，而deque则是一种双向开口的连续线性空间，<a id="more"></a>就是说它可以<strong>在常数时间内</strong>在头尾两端进行元素插入和删除操作，当然从技术手段来说，vector也可以在都为两端进行操作，但是效率很低。</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/learn-stl-deque/1.png" alt="deque"></p>
<p>deque没有容量（capacity）的概念，因为它是动态的以分段连续空间组合而成，随时可以增减一段新的空间并链接起来。不会发生像vector那样“旧空间而申请一块新的空间，并把所有的元素复制过去，再释放旧的空间”这样的情况。</p>
<p>deque由一段一段定量的连续空间构成，在实际代码中，用map来管理各个连续空间，map也是一小块连续空间，其中的每个元素都是指针，指向另一个连续空间，称为缓冲区。缓冲区才是deque存储元素的地方。如下图所示：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/learn-stl-deque/2.png" alt="deque的map和缓冲区结构"></p>
<p>deque的迭代器要能够指出分段连续空间在哪里，要能判断自己是否处于其缓冲区的边缘，如果是，一旦进行前进或者后退的时候就要跳跃至下一个或者上一个缓冲区，为了能正确跳跃，还要需要指向在map中的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class T, ...&gt;</span><br><span class="line">struct _deque_iterator</span><br><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">  typedef T** map_pointer;</span><br><span class="line">  //...</span><br><span class="line">  T* cur;    //指向缓冲区中current元素</span><br><span class="line">  T* first;    //指向缓冲区的头</span><br><span class="line">  T* last;    //指向缓冲区的尾（含备用空间）</span><br><span class="line">  map_pointer node;    //指向map中心</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的图可以清晰展现这三者的关系:</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/learn-stl-deque/3.png" alt="deque的map、迭代器和缓冲区的关系"></p>
<p>deque提供了很多操作，比如<code>push_back</code>，<code>push_front</code>，<code>pop_back</code>，<code>pop_front</code>。</p>
<p>值得注意的是，我们常用的stack（先进后出）和queue（先进先出）在实现的过程中直接使用了deque作为底层容器，都提供了<code>pop</code>和<code>push</code>操作。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（八）:hashtable</title>
    <url>/2016/08/08/learn-stl8-hashtable/</url>
    <content><![CDATA[<p>哈希表（或者叫散列表，hashtable）是一种数据结构，它在插入、删除、查找操作上具有“常数平均时间”的表现<a id="more"></a>，在查找操作上的平均时间可达到O(1)。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表也可视为一种字典结构（dictionary），是根据键（key）而直接访问在内存存储位置的值（value）的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数（hash function），存放记录的数组称做散列表(table)。（摘自wiki百科）</p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>举一个最简单的例子：假如所有的key都是整数的话，我们可以使用一个数组array来实现哈希表，将key直接作为索引（数组下标），这样我们就可以直接得到key所对应的值array[key]。</p>
<p>当key的值很大时（几百万，几千万），由于内存有限，我们不可能去建立一个如此大的数组，这个时候我们就需要修改我们的散列函数（hash function），将大数映射成小数。在SGI源码中用的是<strong>除数留余法</strong>，即用<code>key % length(array)</code>的值作为该key对应的索引，我们可以知道这个值必定在<code>0 ~ length(array)</code>之间。</p>
<p>在SGI源码中的&lt;stl_hash_fun.h&gt;文件中，对int，char，long等整型数据，都是直接返回其值，而针对字符串类型的数据（const char*）设计了一个转换函数来进行处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t __stl_hash_string(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned long h = 0;</span><br><span class="line">  for( ; *s; ++s)</span><br><span class="line">  &#123;</span><br><span class="line">    h = 5*h + *s;</span><br><span class="line">  &#125;</span><br><span class="line">  return size_t(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在SGI hashtable中没有为string，float，double类型的数据进行处理，所以也就无法处理这些类型，除非用户自己定义hash function。</p>
<h2 id="碰撞问题"><a href="#碰撞问题" class="headerlink" title="碰撞问题"></a>碰撞问题</h2><p>使用散列函数会带来一个问题：有可能不同元素的被映射到相同的位置（即经过散列函数计算后索引相同）。这是无法避免的，在元素个数大于array的容量时。这也就是发生了我们称之为碰撞（collision）的问题。</p>
<p>处理碰撞问题的方法有很多，常见的比如：线性探测，平方探测，单独链表等方法。</p>
<p><strong>线性探测</strong>：如果某个key用散列函数计算后发生碰撞，那就循环逐步往下一一探测，直到找到一个可用的位置为止。</p>
<p><strong>平方探测</strong>：如果通过散列函数计算出的新元素的位置时H，而且该位置已经被使用，那么就依照H+1²，H+2²，H+3²，···，H+i²进行尝试，而不是像线性探测那样依照H+1，H+2，H+3，···，H+i进行尝试。</p>
<p><strong>单独链表</strong>：也叫开链法（separate chaining），即将散列到同一位置的元素用链表来进行保存（SGI源码中就是用的这种方法）。</p>
<h2 id="hashtable的实现"><a href="#hashtable的实现" class="headerlink" title="hashtable的实现"></a>hashtable的实现</h2><p>SGI源代码中以开链法实现hashtable，可以看下图的表示：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/learn-stl-hashtable/1.png" alt="hashtable结构图"></p>
<p>整个buckets用vector完成，便于进行扩充。节点node的结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class Value&gt;</span><br><span class="line">class __hashtable_node</span><br><span class="line">&#123;</span><br><span class="line">  __hashtable_node* next;</span><br><span class="line">  Value val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并没有采用已有的list和slist，而是自行维护的一个链表；bucket list用于保存映射到同一位置的元素。</p>
<p>最终的实现的代码比较长，就不贴在博客里了，我已经放在github上了：<a href="https://github.com/guansdu/Learning-STL/tree/master/hashtable" target="_blank" rel="noopener">learn-stl-hashtable</a>。</p>
<h2 id="相关容器"><a href="#相关容器" class="headerlink" title="相关容器"></a>相关容器</h2><p>用hashtable作为底层实现的容器用下面几种：hash_set，hash_map，hash_multiset，hash_multimap。</p>
<p><code>hash_set&lt;Value&gt;</code>里的Value和<code>hash_map&lt;Key,Value&gt;</code>里Key不允许重复，而hash_multiset和hash_multimap则允许重复。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（六）:list</title>
    <url>/2016/07/21/learn-stl6-list/</url>
    <content><![CDATA[<p>不同于vector的连续线性空间，list就显得复杂的多，<a id="more"></a>它每次插入或者删除一个元素，就配置或者释放一个空间。对list来说，在任何位置进行插入或者删除元素的操作，都是在常数时间内完成。</p>
<p>当然对比其他序列式容器，比如vector和数组，list的缺点也很明显：缺乏元素的随机访问能力，要访问某个位置的元素，我们只有从已知的位置进行迭代（begin、end）；要消耗额外的内存来保持元素之间的链表信息。</p>
<h2 id="list节点"><a href="#list节点" class="headerlink" title="list节点"></a>list节点</h2><p>在STL中，list的节点被设计为如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然我们可以知道list是一个<strong>双向链表</strong>。（<code>void*</code>是无类型指针，可以指向任何类型的数据—-使用类型强制转换）<br><img src="http://7xv63n.com1.z0.glb.clouddn.com/learn-stl-list%2F1.png" alt="list的节点表示"></p>
<h2 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h2><p>list不保证其节点在存储空间中连续存在，所以不可用普通指针作为迭代器。而list又是双向链表，因此迭代器要具备前移和后移的功能，所以list的迭代器是<code>bidirectional iterator</code>。</p>
<p>list还有一个特点就是，就行插入（insert）和结合（splice）操作不会使原迭代器失效。进行删除（erase）操作时，也只有指向被删除元素的迭代器失效，并不会影响其他迭代器。</p>
<h2 id="list元素操作"><a href="#list元素操作" class="headerlink" title="list元素操作"></a>list元素操作</h2><p>先说几个比较重要的函数：</p>
<ul>
<li><code>insert(iterator position, const T&amp; x)</code>:在迭代器position所指位置之前插入一个值为x的节点</li>
<li><code>erase(iterator position)</code>:移除迭代器position所指的节点</li>
<li><code>remove(const T&amp; x)</code>:将data值为x的节点移除</li>
<li><code>unique()</code>:移除数值相同的连续元素，只有连续而且相同的元素节点，才会被移除一个</li>
</ul>
<h2 id="list实现"><a href="#list实现" class="headerlink" title="list实现"></a>list实现</h2><p>参考书中的list源码进行实现，在编写的过程中遇到了几个问题，在这里注明下：</p>
<p>一、关于<code>.</code>和<code>-&gt;</code>的区别：都是用于访问类的成员，<code>.</code>的左边必须是类的实例，而<code>-&gt;</code>的左边则是类的指针。</p>
<p>二、被const修饰的变量不允许进行修改。</p>
<p>三、值传递、引用传递和指针传递。</p>
<p>在实现的过程中我们要注意list的结构，它用了一个data域为空的头节点来赋值建立双链表，当我们建立一个空list时，它的结构如下：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/learn-stl-list/2.png" alt="空的list"></p>
<p>在源码中用<code>node</code>来表示头节点，因此我们可以知道<code>node-&gt;next</code>是首节点，<code>node-&gt;perv</code>是尾节点。</p>
<p>具体代码如下<code>stl_list.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _MY_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListIterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> ListIterator&lt;T, T&amp;, T*&gt; iter;</span><br><span class="line">	<span class="keyword">typedef</span> ListIterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> ListNode&lt;T&gt;* link_type;</span><br><span class="line">	link_type node;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	ListIterator() &#123; &#125;</span><br><span class="line">	ListIterator(link_type x) : node(x) &#123; &#125;    <span class="comment">//这里利用了ListNode默认的拷贝构造函数</span></span><br><span class="line">	ListIterator(<span class="keyword">const</span> iter&amp; x) : node(x.node) &#123; &#125;</span><br><span class="line">	<span class="comment">//操作符重载</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((*node).data); &#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		node = (link_type) ((*node).next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123;</span><br><span class="line">		node = (link_type) ((*node).prev);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> ListIterator&lt;T, T&amp;, T*&gt; iter;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> ListNode&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	List()</span><br><span class="line">	&#123;</span><br><span class="line">		node = (link_type)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode&lt;T&gt;));</span><br><span class="line">		node-&gt;next = node;</span><br><span class="line">		node-&gt;prev = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里在返回节点时不可照搬书中代码，因为返回的node的类型是link_type，并不是iter。</span></span><br><span class="line">	<span class="function">iter <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> iter( (link_type) ((*node).next) ); &#125;</span><br><span class="line">	<span class="function">iter <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> iter(node); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取首节点的元素值</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *begin(); &#125;</span><br><span class="line">	<span class="comment">//取尾节点的元素值</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--end()); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node-&gt;next == node; &#125;</span><br><span class="line">	<span class="comment">//返回当前list中元素的个数</span></span><br><span class="line">	<span class="keyword">size_t</span> size()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line">		iter first = begin();</span><br><span class="line">		iter last = end();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (first != last)</span><br><span class="line">		&#123;</span><br><span class="line">			++first;</span><br><span class="line">			result++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在迭代器position之前插入一个值为x的节点</span></span><br><span class="line">	<span class="function">iter <span class="title">insert</span><span class="params">(iter position, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type tmp = (link_type)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode&lt;T&gt;));</span><br><span class="line">		tmp-&gt;data = x;</span><br><span class="line"></span><br><span class="line">		tmp-&gt;next = position.node;</span><br><span class="line">		tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">		(link_type(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">		position.node-&gt;prev = tmp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> iter(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入一个节点，作为尾结点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		insert(end(), x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入一个结点，作为首节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		insert(begin(), x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除position所指向的结点</span></span><br><span class="line">	<span class="function">iter <span class="title">erase</span><span class="params">(iter position)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type next_node = link_type (position.node-&gt;next);</span><br><span class="line">		link_type prev_node = link_type (position.node-&gt;prev);</span><br><span class="line"></span><br><span class="line">		prev_node-&gt;next = next_node;</span><br><span class="line">		next_node-&gt;prev = prev_node;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(position.node);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> iter(next_node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		iter tmp = end();</span><br><span class="line">		erase(--tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		erase(begin());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移除值为x的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		iter first = begin();</span><br><span class="line">		iter last = end();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (first != last)</span><br><span class="line">		&#123;</span><br><span class="line">			iter tmp = first;</span><br><span class="line">			++first;</span><br><span class="line">			<span class="keyword">if</span> (*tmp == x)</span><br><span class="line">				erase(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移除连续相同的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		iter first = begin();</span><br><span class="line">		iter last = end();</span><br><span class="line">		<span class="keyword">if</span> (first == last)</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		iter tmp = first;</span><br><span class="line">		<span class="keyword">while</span> (++first != last)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*tmp == *first)</span><br><span class="line">			&#123;</span><br><span class="line">				erase(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			tmp = first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历并打印list</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		iter tmp = begin();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"list: "</span>;</span><br><span class="line">		<span class="keyword">while</span> (tmp != end())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; *tmp &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			++tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//将[first,last)范围的元素移动到position之前</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iter position, iter first, iter last)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (position != last)</span><br><span class="line">		&#123;</span><br><span class="line">			(link_type (last.node-&gt;prev))-&gt;next = position.node;</span><br><span class="line">			(link_type (first.node-&gt;prev))-&gt;next = last.node;</span><br><span class="line">			(link_type (position.node-&gt;prev))-&gt;next = first.node;</span><br><span class="line"></span><br><span class="line">			link_type tmp = link_type (position.node-&gt;prev);</span><br><span class="line"></span><br><span class="line">			position.node-&gt;prev = last.node-&gt;prev;</span><br><span class="line">			last.prev-&gt;prev = first.node-&gt;prev;</span><br><span class="line">			first.node-&gt;prev = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>一个测试程序<code>stl_list_test.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_list.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----init:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	List&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span>&lt;&lt; li.size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">	li.push_back(<span class="number">4</span>);</span><br><span class="line">	li.push_back(<span class="number">4</span>);</span><br><span class="line">	li.push_back(<span class="number">3</span>);</span><br><span class="line">	li.push_back(<span class="number">3</span>);</span><br><span class="line">	li.push_back(<span class="number">2</span>);</span><br><span class="line">	li.push_back(<span class="number">2</span>);</span><br><span class="line">	li.push_back(<span class="number">1</span>);</span><br><span class="line">	li.push_back(<span class="number">1</span>);</span><br><span class="line">	li.print();    <span class="comment">//4 4 3 3 2 2 1 1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span>&lt;&lt; li.size() &lt;&lt; <span class="string">", front:"</span>&lt;&lt;li.front() &lt;&lt; <span class="string">", back:"</span> &lt;&lt; li.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----use push_front:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	li.push_front(<span class="number">5</span>);</span><br><span class="line">	li.print();    <span class="comment">//5 4 4 3 3 2 2 1 1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span>&lt;&lt; li.size() &lt;&lt; <span class="string">", front:"</span>&lt;&lt;li.front() &lt;&lt; <span class="string">", back:"</span> &lt;&lt; li.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----use unique:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	li.unique();</span><br><span class="line">	li.print();    <span class="comment">//5 4 3 2 1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span>&lt;&lt; li.size() &lt;&lt; <span class="string">", front:"</span>&lt;&lt;li.front() &lt;&lt; <span class="string">", back:"</span> &lt;&lt; li.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----use remove:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	li.remove(<span class="number">1</span>);</span><br><span class="line">	li.print();    <span class="comment">//5 4 3 2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span>&lt;&lt; li.size() &lt;&lt; <span class="string">", front:"</span>&lt;&lt;li.front() &lt;&lt; <span class="string">", back:"</span> &lt;&lt; li.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----use pop_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	li.pop_back();</span><br><span class="line">	li.print();    <span class="comment">//5 4 3</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span>&lt;&lt; li.size() &lt;&lt; <span class="string">", front:"</span>&lt;&lt;li.front() &lt;&lt; <span class="string">", back:"</span> &lt;&lt; li.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----use pop_front:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	li.pop_front();</span><br><span class="line">	li.print();    <span class="comment">//4 3</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span>&lt;&lt; li.size() &lt;&lt; <span class="string">", front:"</span>&lt;&lt;li.front() &lt;&lt; <span class="string">", back:"</span> &lt;&lt; li.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码我放在github上了，下载地址：<a href="https://github.com/guansdu/Learning-STL/tree/master/list" target="_blank" rel="noopener">learn-stl-list</a>。</p>
<p>另外还有一份关于slist的版本（可参考<a href="https://github.com/guansdu/Learning-STL/tree/master/slist" target="_blank" rel="noopener">learn-stl-slist</a>。），slist和list不同之处在于slist是单链表，并不提供双向访问的迭代器，所以slist的迭代器是<code>forward iterator</code>。slist只提供了<code>push_front</code>和<code>pop_front</code>，所以实际上slist中元素的顺序会和插入的顺序相反。</p>
<p>参考资料：</p>
<ul>
<li><ol>
<li><a href="http://www.cplusplus.com/reference/list/list/" target="_blank" rel="noopener">list - C++ Reference</a></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 445. Add Two Numbers II</title>
    <url>/2017/09/03/leetcode-add-two-numbers-II/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Follow up:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
<p>Example:</p>
<p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</p>
</blockquote>

<p>Solution：</p>
<p>用两个栈分部保存两个链表的值，再进行相加操作即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">                </span><br><span class="line">        ListNode *p1 = l1;</span><br><span class="line">        ListNode *p2 = l2;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q1.push(p1-&gt;val);</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q2.push(p2-&gt;val);</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q1.empty() || !q2.empty() || carry &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = carry;</span><br><span class="line">            <span class="keyword">if</span> (!q1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                sum += q1.top();</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!q2.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                sum += q2.top();</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            p-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next = p;</span><br><span class="line">            </span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-学习笔记（九）:仿函数</title>
    <url>/2016/08/10/learn-stl9-functors/</url>
    <content><![CDATA[<p>什么是仿函数，顾名思义，就是和函数类似的东西，也被称为函数对象。<a id="more"></a>仿函数实际上是一个类，它通过重载了()运算符，使得我们可以像调用函数一样来创建类的对象。</p>
<p>看下面一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> x == y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x &lt; y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的binary_function是STL规定的每个二元仿函数都必须继承此类。</p>
<p>可以看到equal_to用于判断两个变量是否相等，在使用的时候我们可以这样调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">equal_to&lt;int&gt; equal_to_obj;</span><br><span class="line">equal_to_obj(3, 5);</span><br></pre></td></tr></table></figure>

<p>也可以直接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">equal_to&lt;int&gt;()(3, 5);</span><br></pre></td></tr></table></figure>

<p>在SGI STL源码中，仿函数的主要用途是为了搭配STL算法来使用，是的该算法具有更大的弹性空间，适用的范围更广。</p>
<p>比如用排序算法sort对vector进行递增排序：</p>
<p><code>sort(vector.begin(), vector.end(), greater&lt;int&gt;())</code>。</p>
<p>若按照递减规则进行排序，则是：</p>
<p><code>sort(vector.begin(), vector.end(), less&lt;int&gt;())</code> 。</p>
<hr>
<p>2016/10/8更新</p>
<p>对比C语言中的函数指针：</p>
<p>函数指针也是一种指针变量，指向该函数的入口地址，主要用途有两个：调用函数和做为函数的参数。</p>
<p>函数指针声明方法：返回值类型 (* 指针变量名) ([形参列表])</p>
<p>看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_num</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a)</span> <span class="comment">// 定义了一个函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*pFunc) (<span class="keyword">const</span> <span class="keyword">int</span>&amp; a); <span class="comment">// 声明函数指针</span></span><br><span class="line">pFunc = print_num; <span class="comment">// 使指向该函数的入口地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">(*pFunc)(a); <span class="comment">// 调用方式</span></span><br></pre></td></tr></table></figure>

<p>利用函数指针，我们可以实现和仿函数类似的功能，例如在C语言中的<code>qsort</code>函数（在头文件stdlib.h里面）</p>
<p><code>void qsort(void *base,int nelem,int width,int (*fcmp)(const void *,const void *));</code></p>
<p>我们可以看到第四个参数就是函数指针，我们可以写一个函数用来自己指定排序规则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp_greater</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*a,<span class="keyword">const</span> <span class="keyword">void</span>*b)</span> <span class="comment">// 递增排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这么说，函数对象是C++对C中的函数指针的一个改进。</p>
<p>函数对象的功能比函数指针要强大，函数对象拥有类的特性，（这里更多的是说面向对象编程的情况下，函数对象比函数指针要好一些），在STL算法中，函数指针无法与其进行适配，因而大量使用了函数对象。</p>
<p>函数对象在性能上也有优势，函数对象编译后就是函数的形式，编译器可以对其进行inline优化，而编译器极少对函数指针进行inline优化（有待考证）。</p>
<p>个人认为，强行区分函数对象和函数指针并没有意义，就像C++里的class和C里的struct关键字一样，二者在设计时的初衷是不一样的，使用的场景也不一样，所以要具体问题具体分析。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 72. Edit Distance</title>
    <url>/2017/09/02/leetcode-edit-distance/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
</blockquote>

<p>Solution:</p>
<p>最小编辑距离问题，也可以称为字符串相似度（编程之美3.3）。可用动态规划求解：用dp[i][j]表示字符串X[0..i-1]和Y[0..j-1]的最小编辑距离，那么可以知道：</p>
<ul>
<li>如果X[i-1]=Y[j-1]，那么dp[i][j] = dp[i-1][j-1];</li>
<li>否则dp[i][j]等于dp[i-1][j]、dp[i][j-1]和dp[i-1][j-1]这三个中最小的加上1。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; ++j)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = min(min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]), dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 392. Is Subsequence</title>
    <url>/2017/09/07/leetcode-is-subsequence/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>Given a string s and a string t, check if s is subsequence of t.</p>
<p>You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not).</p>
<p>Example 1:<br>s = “abc”, t = “ahbgdc”</p>
<p>Return true.</p>
<p>Example 2:<br>s = “axc”, t = “ahbgdc”</p>
<p>Return false.</p>
</blockquote>

<p>Solution:</p>
<p>水题了，判断子序列，还是用两个指针的办法来解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lens = s.size();</span><br><span class="line">        <span class="keyword">int</span> lent = t.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s_index = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; s_index &lt; lens &amp;&amp; j &lt; lent; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[j] == s[s_index])</span><br><span class="line">                ++s_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s_index == lens;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 84. Largest Rectangle in Histogram</title>
    <url>/2017/09/04/leetcode-largest-rectangle-in-histogram/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>For example,<br>Given heights = [2,1,5,6,2,3],<br>return 10.</p>
</blockquote>

<p>Solution:</p>
<p>很经典的一道题，面试中也常有问到，除了暴力解法以外，之前一直不太理解利用栈的O(n)的解法，今天仔细研究了一下，算是弄懂了这个问题。</p>
<p>基本思想就是，以直方图中每一个bar为最低点，来计算它能构造的最大矩形面积；当我们遍历完了每一个bar，也就找到了能组成的最大的矩形面积。如何计算以某个bar为最低点构造的最大矩形面积呢，我们要知道该bar左边第一个小于它的bar（左边界）和右边第一个小于它的bar（右边界）。</p>
<p>在具体的实现中，我们维护一个栈来保存一个递增序列，这样栈中的元素都比其左边的bar要高，这样左边就一直是有界的，我们只需要找到右边界即可。</p>
<p>我们遍历所有的bar，维护一个递增的栈序列。若当前的bar大于栈顶元素，我们就把它的下标放入栈中；若当前的bar小于等于栈顶元素，我们把栈顶元素出栈，并计算以该出栈的bar为最低点的最大矩形面积，那么如何计算该出栈的bar为最低点的最大矩形面积呢：我们有左边界，就是它出栈后现在的栈顶bar的位置，右边界，当前遍历到的bar。即可轻松算出面积。</p>
<p>以[2,1,5,6,2,3]为例：</p>
<ol>
<li>遍历到第一个，入栈{0}；（栈中存放的是下标）</li>
<li>遍历第二个，由于1小于2，我们把该bar出栈并计算它的最大矩形面积：2*1；把1入栈{1}；</li>
<li>第三个，由于5大于1，入栈{1,2}</li>
<li>第四个，同理6大于5，入栈{1,2,3}</li>
<li>第五个，由于2小于6，因此出栈并计算面积：6*1；继续判断，2还是小于5，出栈并计算面积：5*2；此时2大于1，入栈{1,4}；</li>
<li>第六个，入栈{1,4,5}；</li>
<li>注意此时我们已经遍历了所有的bar，但是栈中还有元素为计算，因此我们可以在bar数组末尾加入一个为0的bar，这样我们就可以一次循环计算出所有的bar对应的矩形面积。</li>
</ol>
<p>最终的代码如下，其中的<code>i - 1 - j</code>就是该矩形的宽度：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    heights.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; heights[i] &lt;= heights[s.top()])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> h = heights[s.top()];</span><br><span class="line">            s.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">            max_area = max(max_area, h * (i - <span class="number">1</span> - j));</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3. Longest Substring Without Repeating Characters</title>
    <url>/2017/09/07/leetcode-longest-substring-without-repeating-characters/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>
<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>
<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
</blockquote>

<p>Solution:</p>
<p>维护两个指针，遍历整个字符串，找到了一个包含重复的子串（利用hash table判断），就用第二个指针去尝试缩小区间，找到一个没有重复的子串，并在过程中记录下最长的子串即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, max_len = INT_MIN, counter = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; table(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// increase the counter if have repeating char.</span></span><br><span class="line">            <span class="keyword">if</span> (table[s[end]] &gt; <span class="number">0</span>)</span><br><span class="line">                ++counter;</span><br><span class="line"></span><br><span class="line">            ++table[s[end]];</span><br><span class="line">            ++end;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (counter &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// if s[start] occur more than once.</span></span><br><span class="line">                <span class="keyword">if</span> (table[s[start]] &gt; <span class="number">1</span>)</span><br><span class="line">                    --counter;</span><br><span class="line"></span><br><span class="line">                --table[s[start]];</span><br><span class="line">                ++start;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update the max length.</span></span><br><span class="line">            max_len = max(max_len, end - start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU Cache实现</title>
    <url>/2017/08/27/leetcode-lru-cache/</url>
    <content><![CDATA[<p>LRU算法，Least Recently Used指的是最近最久未使用<a id="more"></a>，常用于页面置换算法。</p>
<p>实现参考于<a href="https://leetcode.com/problems/lru-cache/description/" target="_blank" rel="noopener">Leet Code: 146. LRU Cache</a></p>
<p>刚开始自己写的时候发现把问题想简单了，直接只保存了key，测试用例只通过一部分，发现要保存(key,value)对才好。LRU算法的实现思路还是比较简单的：利用SLT里的list和unordered_map即可。</p>
<p>进行put操作时，如果容量未满且不在unordered_map中，直接放入list的首部，如果在unordered_map中，找到这个元素，并移到list头部。如果容量已满且不在unordered_map中，淘汰尾部的元素，把新的放入list头部，如果在unordered_map中，把它移到list头部。</p>
<p>进行get操作时，如果key在unordered_map中，返回对应的value并移到list头部，如果不在则返回-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) : nums(capacity)&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (my_mp.find(key) == my_mp.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            update_list_mp(my_mp[key]);</span><br><span class="line">            <span class="keyword">return</span> my_list.begin()-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (my_mp.find(key) != my_mp.end())</span><br><span class="line">        &#123;</span><br><span class="line">            update_list_mp(my_mp[key]);</span><br><span class="line">            my_list.begin()-&gt;second = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果cache满了，则需要淘汰尾部</span></span><br><span class="line">            <span class="keyword">if</span> (my_mp.size() == nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> lkey = my_list.back().first;</span><br><span class="line">                my_list.pop_back();</span><br><span class="line">                my_mp.erase(lkey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入新的到list头部</span></span><br><span class="line">            my_list.push_front(make_pair(key, value));</span><br><span class="line">            my_mp[key] = my_list.begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nums;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; MyList;</span><br><span class="line">    MyList my_list;</span><br><span class="line">    <span class="comment">// 实现技巧：存放key和其对应list中迭代器的位置</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, MyList::iterator&gt; my_mp;</span><br><span class="line">    <span class="comment">// 将iter对应的key移到list头部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_list_mp</span><span class="params">(MyList::iterator iter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = iter-&gt;first;</span><br><span class="line">        <span class="keyword">int</span> value = iter-&gt;second;</span><br><span class="line">        my_list.erase(iter);</span><br><span class="line">        my_list.push_front(make_pair(key, value));</span><br><span class="line">        my_mp[key] = my_list.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 295. Find Median from Data Stream</title>
    <url>/2017/08/31/leetcode-median-in-data-stream/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>Examples:<br>[2,3,4] , the median is 3<br>[2,3], the median is (2 + 3) / 2 = 2.5</p>
<p>Design a data structure that supports the following two operations:</p>
<ul>
<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>
<li>double findMedian() - Return the median of all elements so far.</li>
</ul>
<p>For example:<br>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p>
</blockquote>

<p>Solution:</p>
<p>考虑用两个堆：一个最大堆和一个最小堆来解决。当最元素为偶数是放入最小堆，反之放入最大堆。<strong>我们保证两个堆的元素个数之差不超过1，最大堆的元素都小于或等于最小堆的元素</strong>。这样的话当总元素个数为奇数时，中位数就是最小堆的第一个元素；当为偶数时，中位数就是两个堆顶元素的平均值。</p>
<p>注意特殊情况：当往最小堆放入一个元素时，若这个元素小于最大堆的堆顶元素，我们把它先放入最大堆，随后把最大堆的堆顶元素放入最小堆，这样就保证了最大堆的元素都不会大于最小堆里的元素。</p>
<p>往最大堆里放入元素情况类似。</p>
<p>还有一个实现技巧就是用了<code>priority_queue</code>，它默认是最大堆，可自定义参数，修改为最小堆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (((large.size() + small.size()) &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (large.size() &gt; <span class="number">0</span> &amp;&amp; large.top() &gt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                large.push(num);</span><br><span class="line">                num = large.top();</span><br><span class="line">                large.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            small.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (small.size() &gt; <span class="number">0</span> &amp;&amp; small.top() &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                small.push(num);</span><br><span class="line">                num = small.top();</span><br><span class="line">                small.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            large.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums = large.size() + small.size();</span><br><span class="line">        <span class="keyword">if</span> ((nums &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> small.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (large.top() + small.top()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; large; <span class="comment">// max-heap</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; small; <span class="comment">// min-heap</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 164. Maximum Gap</title>
    <url>/2017/09/09/leetcode-maximum-gap/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Try to solve it in linear time/space.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
</blockquote>

<p>Solution:</p>
<p>题目要求的是一个未排序数组求在排序后相邻元素的最大差值（gap）。如果直接用sort排序求解会超时，考虑更好的解法：</p>
<p>如果这个数字的最大值为A，最小值为B，那么我们最终要求出的最大gap肯定不会小于<code>ceil((A - B) / (N - 1))</code>，其中N为元素个数。由此我们可以想到桶排序，如果我们令桶的大小bucket_size小于<code>ceil((A-B)/(N-1))</code>，那么最大gap一定不会出现在同一个桶内的元素之间，只会在相邻的桶出现。所以对每一个桶，只保存它的最大值和最小值，而我们要求的gap就在当前桶的最大值和下一个桶的最小值的差值里面。</p>
<p>注意<code>ceil(double x)</code>返回的是大于x的最小整数，代码中我们取的bucket_size是<code>(A - B) / (N - 1)</code>（向下取整），它是小于<code>ceil((A - B) / (N - 1))</code>的，实际上你取为<code>ceil((A - B) / (2 * N)</code>也可以。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> lu = minmax_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> l = *lu.first, u = *lu.second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> bucket_size = max((u - l) / (n - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = (u - l) / bucket_size + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucketsMin(m, INT_MAX);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucketsMax(m, INT_MIN);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (num - l) / bucket_size;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; bucketsMin[k]) bucketsMin[k] = num;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; bucketsMax[k]) bucketsMax[k] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, pre_max = bucketsMax[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketsMin[i] != INT_MAX &amp;&amp; bucketsMax[i] != INT_MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = max(ret, bucketsMin[i] - pre_max);</span><br><span class="line">                pre_max = bucketsMax[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 4. Median of Two Sorted Arrays</title>
    <url>/2017/09/12/leetcode-median-of-two-sorted-array/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>Example 1:<br>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>The median is 2.0<br>Example 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>The median is (2 + 3)/2 = 2.5</p>
</blockquote>

<p>Solution:</p>
<p>这道题呢很早之前做过，当时直接用的排序，复杂度O(nlogn)，这样的方法大家都会，要是面试官问你有没有更优的解法，那就要懵了。。今天就来把这个更快的解法搞懂。</p>
<p>我们要求两个排序数组的中位数，转化为更一般的问题：就是求两个排序数组归并后的第k小的数（假设为非降序）。（以k为偶数来分析）我们假定两个数组的长度均大于k/2，我们比较两个数组中第k/2个数的大小，那么有可能：</p>
<ul>
<li>A[k/2 - 1] == B[k/2 - 1]</li>
<li>A[k/2 - 1] &gt; B[k/2 - 1]</li>
<li>A[k/2 - 1] &lt; B[k/2 - 1]</li>
</ul>
<p>如果A[k/2 - 1] &lt; B[k/2 - 1]的话，说明A[K/2 - 1]不可能大于合并后数组的第k小的数。简单证明：A[K/2 - 1]肯定是大于等于A前面(k/2 - 1)个数的，同理B[k/2 - 1]也是大于等于B前面(k/2 - 1)个数的，又有A[k/2 - 1] &lt; B[k/2 - 1]，那么B[k/2 - 1]肯定至少会大于合并后的前k/2个数，所以第k小怎么也轮不到A[0]到A[k/2 - 1]，故可以直接舍去。</p>
<p>同理A[k/2 - 1] &gt; B[k/2 - 1]。</p>
<p>对于A[k/2 - 1] == B[k/2 - 1]的情况，我们直接返回即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = m + n;</span><br><span class="line">        <span class="keyword">if</span> ((total &amp; <span class="number">0x1</span>) == <span class="number">1</span>) <span class="comment">// odd</span></span><br><span class="line">            <span class="keyword">return</span> findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// even</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(A, m, B, n, total / <span class="number">2</span>)</span><br><span class="line">                    + findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> b[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//always assume that m is equal or smaller than n</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> findKth(b, n, a, m, k);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> b[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> min(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//divide k into two parts</span></span><br><span class="line">        <span class="keyword">int</span> pa = min(k / <span class="number">2</span>, m), pb = k - pa;</span><br><span class="line">        <span class="keyword">if</span> (a[pa - <span class="number">1</span>] &lt; b[pb - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(a + pa, m - pa, b, n, k - pa);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[pa - <span class="number">1</span>] &gt; b[pb - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(a, m, b + pb, n - pb, k - pb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a[pa - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="http://blog.csdn.net/zxzxy1988/article/details/8587244" target="_blank" rel="noopener">http://blog.csdn.net/zxzxy1988/article/details/8587244</a></p>
<p><a href="https://discuss.leetcode.com/topic/11478/o-lg-m-n-c-solution-using-kth-smallest-number" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/11478/o-lg-m-n-c-solution-using-kth-smallest-number</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Trie树</title>
    <url>/2017/08/22/leetcode-trie-tree/</url>
    <content><![CDATA[<p>Trie树又称字典树，是一种树形结构（多叉树），典型应用是用于统计<a id="more"></a>，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<h2 id="Trie树性质"><a href="#Trie树性质" class="headerlink" title="Trie树性质"></a>Trie树性质</h2><p>来看一颗简单的Trie树：<br><img src="http://7xv63n.com1.z0.glb.clouddn.com/trie-tree.png" alt="trie tree"></p>
<p>从图上可以看出，Trie树满足以下性质为：</p>
<ol>
<li>根节点不包含字符，除根节点意外每个节点只包含一个字符。</li>
<li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 </li>
<li>每个节点的所有子节点包含的字符串不相同。</li>
</ol>
<p>Trie树的基本操作都比较好理解，插入，查找和删除（少用），用一个循环即可，找到树中最后和某个单词匹配的结点然后进行相应的操作即可。</p>
<h2 id="Trie树实现"><a href="#Trie树实现" class="headerlink" title="Trie树实现"></a>Trie树实现</h2><p>假定给定的字符串数组全都是小写字母a-z，下面给出一种Trie树的实现利用指针数组：</p>
<p>已放在github： <a href="https://github.com/guansdu/trie-tree" target="_blank" rel="noopener">trie-tree</a></p>
<p>时间复杂度分析，插入和查找都是<code>O(N)</code>，N为字符串长度；</p>
<p>空间复杂度分析，每个结点都需要26个指针和一个bool变量；</p>
<h2 id="Trie树的应用"><a href="#Trie树的应用" class="headerlink" title="Trie树的应用"></a>Trie树的应用</h2><h3 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h3><p>我们看到利用Trie树我们保存了许多字符串（字典）的公共前缀信息，因此我们可以快速判断出某个字符串是否某个字典里的字符串的前缀子串。</p>
<h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><p>我们可以在<code>TrieNode</code>中增设一个变量，用来统计每个单词的出现次数，然后只需要在每次插入时对这个路径上的TrieNode的这个变量进行加1。</p>
<h3 id="最长公共前缀（后缀）"><a href="#最长公共前缀（后缀）" class="headerlink" title="最长公共前缀（后缀）"></a>最长公共前缀（后缀）</h3><p>在<code>Trie</code>中增设一个count变量，然后在每层进行搜寻，判断是否该层的count值等于总的字符串个数。</p>
<p>参考资料：</p>
<p>LeetCode: <a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree)</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Trie Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 76. Minimum Window Substring</title>
    <url>/2017/09/05/leetcode-minimum-window-substring/</url>
    <content><![CDATA[<p>Description:<a id="more"></a></p>
<blockquote><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,<br>S = “ADOBECODEBANC”<br>T = “ABC”<br>Minimum window is “BANC”.</p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the empty string “”.</p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
</blockquote>

<p>Solution:</p>
<p>这道题的思路我自己没有想到，看了discuss大佬的解法，才明白了一些，这类题的解法和前面的Largest Rectangle in Histogram和Longest Substring Without Repeating Characters有一点类似，都是维护两个指针，找到一个解以后去尝试有没有更好的解，直到遍历完所有的数据。</p>
<p>具体的可以看代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">table_t</span>(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : t)</span><br><span class="line">        ++<span class="keyword">table_t</span>[c];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, min_start = <span class="number">0</span>, min_len = INT_MAX;</span><br><span class="line">    <span class="comment">// counter represents the number of chars of t to be found in s.</span></span><br><span class="line">    <span class="keyword">int</span> counter = t.size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (end &lt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If char in s exists in t, decrease counter</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">table_t</span>[s[end]] &gt; <span class="number">0</span>)</span><br><span class="line">            --counter;</span><br><span class="line">        <span class="comment">// if a char s[end] is not in t, table_t[s[end]] will be negative.</span></span><br><span class="line">        --<span class="keyword">table_t</span>[s[end]];</span><br><span class="line">        ++end;</span><br><span class="line">        <span class="comment">// When we found a valid window, move start to find smaller window.</span></span><br><span class="line">        <span class="keyword">while</span> (counter == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start &lt; min_len)</span><br><span class="line">            &#123;</span><br><span class="line">                min_start = start;</span><br><span class="line">                min_len = end - start;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ++<span class="keyword">table_t</span>[s[start]];</span><br><span class="line">            <span class="comment">// // When char exists in t, increase counter.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">table_t</span>[s[start]] &gt; <span class="number">0</span>)</span><br><span class="line">                ++counter;</span><br><span class="line">            </span><br><span class="line">            ++start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (min_len != INT_MAX)</span><br><span class="line">        <span class="keyword">return</span> s.substr(min_start, min_len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 316. Remove Duplicate Letters</title>
    <url>/2017/09/03/leetcode-remove-duplicate-letters/</url>
    <content><![CDATA[<p>Description：<a id="more"></a></p>
<blockquote><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example:<br>Given “bcabc”<br>Return “abc”</p>
<p>Given “cbacdcbc”<br>Return “acdb”</p>
</blockquote>

<p>Solution:</p>
<p>要注意的地方是返回的字符串必须是原字符串的子序列，比如第二个不能返回”abcd”，其次要是字典序最小的序列。由于题目保证了都是小写字母，所以我们可以直接用vector来保存每个字母出现的次数。</p>
<p>结合代码说下思路：<br>以”cbacdcbc”为例，统计出现次数：</p>
<p>‘a’-1; ‘b’-2; ‘c’-4; ‘d’-1.</p>
<p>然后遍历原字符串，如果该字符比当前结果末尾的字符要小，且末尾字符剩余次数大于0，那么我们把该字符放到前面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; table(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        table[c] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        table[c] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[c]) <span class="comment">// visited[c] == 1 denotes that c has been visited. </span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (!ret.empty() &amp;&amp; c &lt; ret.back() &amp;&amp; table[ret.back()] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            visited[ret.back()] = <span class="number">0</span>;</span><br><span class="line">            ret.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        ret += c;</span><br><span class="line">        visited[c] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的应用：优先级队列</title>
    <url>/2017/06/27/priority-queue/</url>
    <content><![CDATA[<p>优先级队列（priority queue）是用来维护一组元素构成的数据集S的数据结构<a id="more"></a>。数据集中每个元素都有一个关键字key，这里我们考虑由最大堆实现的<strong>最大优先级队列</strong>。</p>
<p>一个最大优先级队列支持以下操作：</p>
<ul>
<li>Insert(S, x) 把元素x插入到集合S。</li>
<li>Maximum(S) 返回S中具有最大关键字的元素。</li>
<li>ExtractMax(S) 去掉并返回S中具有最大关键字的元素。</li>
<li>IncreaseKey(S, x, k) 把元素x的关键字的值增加到k。</li>
</ul>
<p>我们可以看到优先级队列的特点就是：它可以在O(1)的时间内得到关键字最大的元素，所以在一些任务调度时，我们可以始终让优先级最高的优先完成。</p>
<p>在实现最大优先级这个数据结构时，我们需要用到堆的性质。下面列出堆的两个基本操作，在之前的博客里也多次提到过：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> pos = i; (<span class="number">2</span> * pos + <span class="number">1</span>) &lt; (nums.size() - <span class="number">1</span>); pos = largest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left_child = <span class="number">2</span> * pos + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[left_child] &gt; nums[pos])</span><br><span class="line">            largest = left_child;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            largest = pos;</span><br><span class="line">        <span class="keyword">if</span> (nums[left_child + <span class="number">1</span>] &gt; nums[largest])</span><br><span class="line">            largest = left_child + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != pos)</span><br><span class="line">            swap(nums[largest], nums[pos]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        MaxHeapify(nums, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到我这里<code>MaxHeapify</code>是非递归的版本。</p>
<p>对于<code>Maximum(S)</code>操作，当然是直接返回第一个元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaximum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>ExtractMax(S)</code>，有点类似Heap Sort的方式，把最大值移到尾部，最后调整集合，使其保持堆的性质：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HeapExtractMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//error</span></span><br><span class="line">    <span class="keyword">int</span> max_element = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    nums.erase(nums.begin());</span><br><span class="line"></span><br><span class="line">    MaxHeapify(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> max_element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>IncreaseKey(S, x, k)</code>，由于把该元素的值增加到k以后，可能会违反了堆的性质，这时候我们需要把该元素不断与父结点比较，（大于父结点就交换）直到找到合适的位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapIncreaseKey</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; key)</span><br><span class="line">    <span class="keyword">return</span> ; <span class="comment">//error</span></span><br><span class="line">    nums[i] = key;</span><br><span class="line">    <span class="comment">// percolate up</span></span><br><span class="line">    <span class="keyword">while</span> ((i &gt; <span class="number">0</span>) &amp;&amp; (nums[(i<span class="number">-1</span>) / <span class="number">2</span>] &lt; nums[i]))</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[(i<span class="number">-1</span>) / <span class="number">2</span>], nums[i]);</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>Insert(S, x)</code>，相当于在集合尾部插入一个值为无穷小的元素，最后执行<code>IncreaseKey(S, x, k)</code>操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nums.push_back(INT_MIN);</span><br><span class="line">    HeapIncreaseKey(nums, nums.size()<span class="number">-1</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考文献：</p>
<ol>
<li>Introduction to Algorithms (2ed edition).</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>内存池的一些技术要点</title>
    <url>/2020/06/17/memory-pool-keypoints/</url>
    <content><![CDATA[<p>先占坑，后面补上；<a id="more"></a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串（子序列）</title>
    <url>/2017/08/14/longest-palindromic-substring-or-subsequence/</url>
    <content><![CDATA[<p>今天在牛客网上做编程题时碰到了这个题目<a id="more"></a>，记得之前刷LeetCode做过这道题的，竟然一时之间没有想到好的思路，所以写下来再回顾一遍吧。</p>
<p>有兴趣的可以先不看博文，移步LeetCode看看自己会不会：</p>
<p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">5. Longest Palindromic Substring</a></p>
<p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="noopener">516. Longest Palindromic Subsequence</a></p>
<h2 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h2><p>先分析第一题，给定一个字符串，要求找到它的最长回文子串，比如<code>&quot;babab&quot;</code>的最长回文子串为<code>&quot;bab&quot;</code>，注意<code>&quot;aba&quot;</code>也是，返回其中一个就行；<code>&quot;cbbd&quot;</code>则返回<code>&quot;bb&quot;</code>。</p>
<p>一个比较好的思路就是类似中心扩展法，就是遍历每个字符，并以它为中心开始探索，找到它能达到的最大回文子串长度，要注意的是区分最长回文子串长度为奇偶数的情况。代码如下所示，时间复杂度为<code>O(n*n)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution() : start(<span class="number">0</span>), max_len(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LongestPalindromeSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Expand(s, i, i); <span class="comment">// 假设为奇数长度</span></span><br><span class="line">            Expand(s, i, i + <span class="number">1</span>); <span class="comment">// 假设为偶数长度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Expand</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k])</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max_len &lt; (k - j - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            start = j + <span class="number">1</span>;</span><br><span class="line">            max_len = k - j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> max_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的解法还能再优化一下，能保证最好的情况下是<code>O(n)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len_s = s.size();</span><br><span class="line">        <span class="keyword">int</span> min_start = <span class="number">0</span>, max_len = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_s; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (max_len / <span class="number">2</span>) &gt;= (len_s - i) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i;</span><br><span class="line">            <span class="comment">// 跳过重复字符</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; len_s - <span class="number">1</span> &amp;&amp; s[right] == s[right + <span class="number">1</span>])</span><br><span class="line">                ++right;</span><br><span class="line">            i = right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; len_s - <span class="number">1</span> &amp;&amp; left &gt; <span class="number">0</span> &amp;&amp; s[left - <span class="number">1</span>] == s[right + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                --left;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max_len &lt; (right - left + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                max_len = right - left + <span class="number">1</span>;</span><br><span class="line">                min_start = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(min_start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Longest-Palindromic-Subsequence"><a href="#Longest-Palindromic-Subsequence" class="headerlink" title="Longest Palindromic Subsequence"></a>Longest Palindromic Subsequence</h2><p>第二题数求最长回文子序列，比如<code>&quot;bbbcb&quot;</code>的最长回文子序列为<code>&quot;bbbb&quot;</code>，则返回4，而<code>&quot;cbba&quot;</code>的最长回文子序列为<code>&quot;bb&quot;</code>，则返回2。</p>
<p>比较直接的方法就是转化为最长公共子序列的问题，就是求原字符串和翻转后的字符串的最长公共子序列，比如就是求<code>&quot;bbbcb&quot;</code>和<code>&quot;bcbbb&quot;</code>的最长公共子序列，时间复杂度为<code>O(n*n)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LongestPalindromeSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">rs</span><span class="params">(s)</span></span>;</span><br><span class="line">        reverse(rs.begin(), rs.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == rs[j])</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[len][len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面考虑直接用动态规划来求解：</p>
<p>如果字符串为X[0…n-1]，用L[i][j]表示子串L[i..j]的最长回文子串，0 &lt;= i &lt;= j &lt;= n-1；那么我们有如果<code>X[i] = X[j]</code>，那么<code>L[i][j] = L[i+1][j-1]+2</code>；否则<code>L[i][j] = max(L[i+1][j], L[i][j-1])</code>。初始化<code>L[i][i] = 1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LongestPalindromeSub</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.size();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>PS：要注意的是第一题最长回文子串不能转化为两个字符串的最长公共子串的，考虑字符串<code>&quot;abcdecba&quot;</code>，翻转后字符串为<code>&quot;abcedcba&quot;</code>，它们的最长公共子串为<code>&quot;abc&quot;</code>，这个显然不对，甚至都不是回文串。</p>
<blockquote>
<p>解题思路来自LeetCode的discuss，膜拜大佬(#^.^#)……</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DP</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>兔子繁衍问题</title>
    <url>/2017/08/21/rabbit-number/</url>
    <content><![CDATA[<p>今天做了下阿里的秋招的编程测验题目，一下子没做出来，<a id="more"></a>只通过了40%的用例，后来结束后我又自己思考了一下，发现是自己题目没看清，每年都是取走两只兔子，我看成了只拿走一只，也是醉了。。。还是要仔细啊！</p>
<p>问题:</p>
<p>猎人把一对兔子婴儿(一公一母称为一对)放到一个荒岛上，两年之后，它们生下一对小兔，之后开始每年都会生下一对小兔。生下的小兔又会以同样的方式继续繁殖。 </p>
<p>兔子的寿命都是x(x&gt;=3)年，并且生命的最后一年不繁殖。 </p>
<p>如果岛上的兔子多于10对，那么猎人会每年在兔子们完成繁殖或者仙逝之后，从岛上带走两对最老的兔子。请问y年(y&gt;=3)后荒岛上所有的兔子加起来多少岁?(注意, 在条件3执行完之后)。</p>
<p>输入: 从命令行输入两行整数，第一行是x，第二行是y；</p>
<p>输出: y年后荒岛上所有的兔子岁数的总和。</p>
<p>下面贴下代码，由于不能再运行了o(╥﹏╥)o，所以也不一定对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_total_age</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total_age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rabbit;</span><br><span class="line">    rabbit.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=y; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// every rabbit's age plus one</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rabbit.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rabbit[j] != <span class="number">-1</span>)</span><br><span class="line">                rabbit[j] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if it's greater than x, then die -1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rabbit.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rabbit[j] &gt;= x)</span><br><span class="line">                rabbit[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tmp is the number of new rabbits baby</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rabbit.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rabbit[j] &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the new rabbits put into the vector "rabbit"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tmp; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            rabbit.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rabbit.size() &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// take away two pair oldest rabbits</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rabbit.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (rabbit[j] != <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    rabbit[j] = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rabbit.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (rabbit[j] != <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    rabbit[j] = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rabbit.size(); ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rabbit[j] != <span class="number">-1</span>)</span><br><span class="line">            total_age += rabbit[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*total_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基础复习</title>
    <url>/2019/07/23/os-review/</url>
    <content><![CDATA[<p><strong>Operating System Review</strong><a id="more"></a></p>
<h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h2><ul>
<li>一个程序至少有一个进程，一个进程至少有一个（主）线程。</li>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</li>
<li>线程是进程的一个实体，运行在进程上下文中的一个逻辑流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li>
<li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如线程ID，程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源（代码，全局内存，堆和打开文件）。</li>
<li>进程有独立的虚拟地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的栈和局部变量，但线程之间没有单独的地址空间。</li>
<li>线程上下文切换比进程上下文切换要快得多，线程执行开销小，但不利于资源的管理和保护。</li>
</ul>
<h2 id="多进程-多线程"><a href="#多进程-多线程" class="headerlink" title="多进程 多线程"></a>多进程 多线程</h2><p>多进程分析：对于父子进程间共享状态信息，进程有一个很清晰的模型：共享文件表，但是不共享用户地址空间。这既是优点也是缺点，这样一来，一个进程不可能不小心覆盖另一个进程的虚拟存储空间；另一方面，独立的虚拟地址空间也使得进程直接共享状态信息变得更加困难，为了共享信息，它们必须使用显示的IPC机制。基于进程的设计另一个缺点是：它们往往比较慢，因为进程控制和IPC开销很高。</p>
<p>多线程：往反方向思考。。。</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>父进程通过调用fork()函数创建一个新的运行子进程，子进程几乎但不是完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括文本、数据和bss段（用来存放程序中未初始化的全局变量和静态变量的一块内存区域）、堆以及用户栈。它们之间最大的区别就是有不同的PID。</p>
<p>fork函数被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID；在子进程中，fork返回0。</p>
<p>父进程和子进程都是并发运行的独立进程，不能对它们的执行顺序做任何假设。</p>
<h2 id="逻辑地址-线性地址-物理地址"><a href="#逻辑地址-线性地址-物理地址" class="headerlink" title="逻辑地址 线性地址 物理地址"></a>逻辑地址 线性地址 物理地址</h2><ul>
<li>逻辑地址（Logical Address）：把用户程序中使用的地址称为相对地址即逻辑地址。一个逻辑地址由两部份组成，段标识符和段内偏移量。例如，你在进行C语言指针编程中，能读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址。</li>
<li>线性地址（Linear Address） 是逻辑地址到物理地址变换之间的中间层。程式代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。</li>
<li>物理地址（Physical Address） 是指出目前CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>
<p>死锁的发生必须具备以下四个必要条件：</p>
<ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，···，Pn正在等待已被P0占用的资源。</li>
</ul>
<p>避免死锁：</p>
<ul>
<li>资源一次性分配：（破坏请求和保持条件）</li>
<li>可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<p>常用的银行家算法</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>（Java版本）</p>
<ul>
<li>新建状态：线程对象已经创建，还没有在其上调用start()方法;</li>
<li>就绪状态：在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获；</li>
<li>运行状态：就绪状态的线程获取了CPU，执行程序代码；</li>
<li>阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权（等待用户输入、调用sleep()进入睡眠状态、试图得到一个同步锁，而该锁正被其他线程持有），暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态；</li>
<li>死亡状态：线程执行完了或者因异常退出了run()方法，该线程结束生命周期；</li>
</ul>
<h3 id="堆-栈"><a href="#堆-栈" class="headerlink" title="堆 栈"></a>堆 栈</h3><p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。栈空间比较小，windows下一般是2M。<br>堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收（不保证）。堆是向高地址扩展的数据结构，是不连续的内存区域。堆的大小受限于计算机系统中有效的虚拟内存<br>全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域。</p>
<h3 id="Linux线程同步"><a href="#Linux线程同步" class="headerlink" title="Linux线程同步"></a>Linux线程同步</h3><p>互斥锁：也被称为二元信号量，因为它的值总为1或者0。在一个互斥锁上执行P操作称为加锁，执行V操作称为解锁。对一个互斥锁加了锁但是还没有解锁的线程称为占用这个互斥锁。</p>
<p>读写锁：可以有3种状态，读模式下加锁，写模式下加锁，不加锁状态，一次只可以有一个线程占有写模式下的读写锁，但是可以有多个线程占有读模式下的读写锁。</p>
<p>条件变量：件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。</p>
<p>信号量：记录型信号量（record semaphore)：每个信号量s除一个整数值s.value（计数）外，还有一个进程等待队列s.L，其中是阻塞在该信号量的各个进程的标识。</p>
<p>自旋锁：自旋锁与互斥量类似，但它不是通过休眠使线程阻塞，而是在获取锁之前一直处于忙等阻塞状态，自旋锁可用于以下情况：锁被持有的时间短，而线程并不希望在重新调度上花费太多成本。</p>
<h3 id="进程空间分布"><a href="#进程空间分布" class="headerlink" title="进程空间分布"></a>进程空间分布</h3><p>由低地址到高地址分别是：</p>
<ul>
<li>text：已编译程序的机器代码（二进制文件）</li>
<li>data：已经初始化的静态变量</li>
<li>bss：未初始化的静态变量</li>
<li>堆空间</li>
<li>内存映射区</li>
<li>栈空间</li>
<li>环境变量和命令行参数</li>
<li>最后是内核空间（32位机器上是1G）</li>
</ul>
<h3 id="main-c文件编译过程"><a href="#main-c文件编译过程" class="headerlink" title="main.c文件编译过程"></a>main.c文件编译过程</h3><p>预编译：（生成一个ASCII码的中间文件main.i）</p>
<ul>
<li>将所有的#define删除，并且展开所有的宏定义</li>
<li>处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等</li>
<li>处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置。</li>
<li>删除所有注释 “//”和”/* */”.</li>
</ul>
<p>编译：编译过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。生成一个ASCII汇编语言文件main.s。</p>
<p>汇编：将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。生成一个可重定位目标文件main.o</p>
<p>链接：运行链接程序，将main.o文件和一些必须的系统目标文件组合起来，生成一个可执行文件。链接器主要有两个任务：</p>
<ul>
<li>符号解析symbol resolution：将每个符号引用刚好和一个符号定义连接起来。</li>
<li>重定位relocation：把每个符号定义和一个存储器位置联系起来。</li>
</ul>
<h2 id="静态链接-动态链接"><a href="#静态链接-动态链接" class="headerlink" title="静态链接 动态链接"></a>静态链接 动态链接</h2><p>静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。优点是代码的装载速度快，执行速度也比较快，因为编译时它只会把你需要的那部分链接进去，应用程序相对比较大。但是如果多个应用程序使用的话，会被装载多次，浪费内存。（Linux下是.a文件）</p>
<p>动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。（Linux下是.so文件）</p>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><p>统计当前文件夹下文件的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l |grep &quot;^-&quot;|wc -l</span><br></pre></td></tr></table></figure>

<p>统计当前文件夹下目录的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l |grep &quot;^d&quot;|wc -l</span><br></pre></td></tr></table></figure>

<p>查看某个端口是否被占用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anp|grep 80</span><br></pre></td></tr></table></figure>

<p>查找文件中某个字符行数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;error&quot; a.log|wc -l</span><br></pre></td></tr></table></figure>

<p>wc -l统计行数 wc -m统计字符数</p>
<p>查看所有进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -A</span><br></pre></td></tr></table></figure>

<p>查找大于100M的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -size +100M</span><br></pre></td></tr></table></figure>

<p>在/etc目录下查找所有的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /etc -type d</span><br></pre></td></tr></table></figure>

<p>网络分析工具命令：<a href="http://blog.csdn.net/xiaoquantouer/article/details/77132241#3netstat" target="_blank" rel="noopener">http://blog.csdn.net/xiaoquantouer/article/details/77132241#3netstat</a></p>
<h2 id="符号链接-硬链接"><a href="#符号链接-硬链接" class="headerlink" title="符号链接 硬链接"></a>符号链接 硬链接</h2><p>符号链接又称软链接，路径可以是任意文件或目录，可以链接不同文件系统的文件。（链接文件可以链接不存在的文件，这就产生一般称之为”断链”的现象），链接文件甚至可以循环链接自己（类似于编程中的递归）。一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。这种情况被有时被称为被遗弃。</p>
<p>硬连接是不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。相反都是软连接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除。</p>
<p>硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件。可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。</p>
<p>软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 239. Sliding Window Maximum</title>
    <url>/2017/08/31/leetcode-sliding-window-maximun/</url>
    <content><![CDATA[<p>Description:<a id="more"></a></p>
<blockquote><p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<p>Window position                Max</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p>
</blockquote>

<p>Solution:</p>
<p>考虑用<code>deque</code>来做，deque中保存数组元素的下标，每次循环将可能是后面滑动窗口最大值的元素下标保存的尾部，当前滑动窗口的最大值下标保存为头部元素；若下一个元素大于deque中的元素，则将它们删除；若此时最大值元素下标已经滑出了窗口，也要将其删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// number out of window.</span></span><br><span class="line">            <span class="keyword">while</span> (!index.empty() &amp;&amp; index.front() &lt;= (i - k))</span><br><span class="line">                index.pop_front();</span><br><span class="line">            <span class="comment">// delete the small number.</span></span><br><span class="line">            <span class="keyword">while</span> (!index.empty() &amp;&amp; nums[i] &gt;= nums[index.back()])</span><br><span class="line">                index.pop_back();</span><br><span class="line">            </span><br><span class="line">            index.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= (k - <span class="number">1</span>))</span><br><span class="line">                ret. push_back(nums[index.front()]);</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>关于单链表的逆置</title>
    <url>/2017/03/13/single-list-reverse/</url>
    <content><![CDATA[<p>刚刚在搜资料时意外的看到了一个关于单链表逆置的问题<a id="more"></a>（带头结点的），可以说是一个很经典的算法了，就顺手做了做，用了两种方法来实现：</p>
<h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2><p>思路：依次将每个结点插入到第一个结点之前。如图所示：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/singly-list-reverse/list_reverse1.png" alt="头插法"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带头结点的单链表逆置 方法一</span></span><br><span class="line"><span class="function">ListNode* <span class="title">list_reverse</span><span class="params">(ListNode* l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span> || l.next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    ListNode* p = l-&gt;next;</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;    <span class="comment">// 保存结点p的后继</span></span><br><span class="line">        p-&gt;next = l-&gt;next;</span><br><span class="line">        l-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三指针法"><a href="#三指针法" class="headerlink" title="三指针法"></a>三指针法</h2><p>思路：用三个指针分别表示当前节点、其前置和后置，然后依次将指针反转；注意循环结束后头节点要指向最后一个节点，而最后一个节点要指向空。如图所示：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/singly-list-reverse/list_reverse2.png" alt="三指针法"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带头结点的单链表逆置 方法二</span></span><br><span class="line"><span class="function">ListNode* <span class="title">list_reverse2</span><span class="params">(ListNode* l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span> || l.next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 三指针</span></span><br><span class="line">    ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* cur = l-&gt;next;</span><br><span class="line">    ListNode* p = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">    cur-&gt;next = <span class="literal">NULL</span>;    <span class="comment">// 第一个结点指向NULL</span></span><br><span class="line">    <span class="keyword">while</span> (p !=  <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    l-&gt;next = cur;    <span class="comment">// 头结点指向最后一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>几个重要的套接字选项</title>
    <url>/2017/08/27/socket-options/</url>
    <content><![CDATA[<p>介绍几个常用的socket套接字选项：<a id="more"></a></p>
<h2 id="SO-SNDBUF-SO-RCVBUF"><a href="#SO-SNDBUF-SO-RCVBUF" class="headerlink" title="SO_SNDBUF SO_RCVBUF"></a>SO_SNDBUF SO_RCVBUF</h2><p>每个套接字都有一个发送缓冲区和接收缓冲区。可分别使用SO_SNDBUF SO_RCVBUF来修改其大小。</p>
<p>比如：每个TCP套接字都有一个发送缓冲区，可以用SO_SNDBUF来更改该缓冲区大小，当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字缓冲区容不下该应用进程的所有数据，该进程会被投入睡眠（默认该套接字是阻塞的）。此时，内核将不会从write调用返回，知道所有数据都可以被复制到套接字发送缓冲区。因此，从写一个TCP套接字的write调用返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不代表对端TCP或应用进程已收到数据。</p>
<p>对于TCP来说，套接字接收缓冲区大小限定了TCP通告对端的窗口大小。TCP缓存区不可能溢出，因为不允许对端发送超过本端所通告的窗口大小。这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。</p>
<p>对于客户，SO_RCVBUF必须在调用connect之前设置，对于服务器，必须在调用listen之前设置给监听套接字。</p>
<p>TCP套接字缓冲区大小至少应该是相应连接的MSS值的四倍（依据是TCP快速恢复算法）。为了避免潜在的空间狼给，还应该是相应连接的MSS值的偶数倍。</p>
<h2 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h2><p>SO_REUSEADDR提供以下四个功能：</p>
<ol>
<li>当你要重chong用处于TIME_WAIT状态的socket所占有的的端口和IP地址时，设置这个选项，你的新socket就可以bind成功。（在调用bind之前设置SO_REUSEADDR选项）</li>
<li>SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。</li>
<li>SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。 </li>
<li>SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。</li>
</ol>
<h2 id="SO-NODELAY"><a href="#SO-NODELAY" class="headerlink" title="SO_NODELAY"></a>SO_NODELAY</h2><p>开启本选项将禁止TCP的Nagle算法。默认该算法是开启的。</p>
<p>Nagle算法的目的在于减少广域网上小分组的数目：如果某个给定连接上有待确认数据，那么原本应该作为用户写操作之响应的在该连接上立即发送的相应小分组的行为就不会发生，直到现有数据被确认为止。这里的“小分组”就是任何小于MSS的分组。</p>
<h2 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h2><p>给一个TCP设置保活选项后，如果2小时内该套接字没有任一方向的数据交换，TCP就自动给对端发送一个保活探测分节，这个时候对端必须响应相应的TCP分节，它可能有以下三种情况：</p>
<ol>
<li>对端以期望的ACK相应。一切正常</li>
<li>对端发出RST响应，它通告本端TCP：对端已经崩溃且重新启动。</li>
<li>对端对保活探测分节没有任何响应。此时本端会继续发送几个保活探测分节，若一直没有响应则放弃。</li>
</ol>
<p>此选项常常由服务器端使用，用来检测半打开连接并关闭它们。</p>
<p>参考资料</p>
<ol>
<li>UNP v1 第7章</li>
</ol>
]]></content>
      <categories>
        <category>Networks</category>
      </categories>
      <tags>
        <tag>Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>关于螺旋打印数组的一些启发</title>
    <url>/2017/07/30/print-spiral-matrix/</url>
    <content><![CDATA[<p>用非常规的次序来打印二维数组，相信这对于习惯了使用顺序输出的我们来<a id="more"></a>说，刚遇到这类问题的时候多少有点懵，无从下手的感觉。正好看到LeetCode上有这么一道题目，就和大家来分享一下。</p>
<p>题目要求：给定一个4*4的数组如下</p>
<blockquote>
<pre><code>2  3  4  5
6  7  8  9
10 11 12 13
14 15 16 17</code></pre></blockquote>
<p>按照螺旋式的方式来输出（也可以认为是顺时针）：<code>[2,3,4,5,9,13,17,16,15,14,10,6,7,8,12,16,15,11]</code>。</p>
<p>分析题目，我们打印的方式为先水平向右，竖直向下，水平向左，竖直向上。具体的，我们以上面的例子来分析，先水平向左打印4个元素，在竖直向下打印3个元素，水平向左打印3个元素，竖直向上打印2个元素，水平向右打印2个元素，竖直向下1一个元素，水平向左打印1个元素，至此，元素全部被打印。</p>
<p>你是否发现了一点规律呢？我们再仔细来看，水平方向打印：<code>4,3,2,1</code>；竖直方向打印<code>3,2,1</code>。结合数组大小<code>4*4</code>我们发现了规律：对<code>m*n</code>的矩阵初始打印次数为水平方向<code>n</code>（列数），竖直方向次数为<code>m-1</code>，每个方向打印完后次数减1，直到为0结束。</p>
<p>现在我们知道了每次每个方向要打印的元素个数，假如从[0,0]点开始遍历的话，我们该如何位移呢？下面重点来了，为了打印方便，我们假定起始点为<code>(0,-1)</code>，每次水平打印就对x坐标进行加1或者减1，每次竖直打印就对y坐标加1减1。为了方便，我们用数字来表示<code>direction[4][2] = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } }</code>，比如水平向右就和direction[0]里对应的<code>(0, 1)</code>相加，然后切换到下一个方向（竖直向下）direction[1]，以此类推。</p>
<p>最后给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (matrix.empty())</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(); <span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size(); <span class="comment">// 列数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125; &#125;; <span class="comment">//方向偏移</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pos[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 初始坐标</span></span><br><span class="line">    <span class="keyword">int</span> steps[<span class="number">2</span>] = &#123;n, m - <span class="number">1</span>&#125;; <span class="comment">// 初始化每个方向（水平方向和垂直方向）走的步数</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (steps[c] != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps[c]; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            pos[<span class="number">0</span>] += direction[d][<span class="number">0</span>];</span><br><span class="line">            pos[<span class="number">1</span>] += direction[d][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            ret.push_back(matrix[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        steps[c]--; <span class="comment">//每个方向走完后减去1</span></span><br><span class="line">        c = c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 改变方向</span></span><br><span class="line">        d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果有游戏编程经验的同学肯定多少会有点相似的感觉，就类似一个小人在方格里面走，切换方向就是对其坐标进行修改。这样写起来代码是不是即优雅又精炼呢？希望能对大家有所启发咯。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>在旋转数组上的搜索</title>
    <url>/2017/07/30/problems-in-rotate-array/</url>
    <content><![CDATA[<p>我们知道对于有序数组来说，使用二分搜索威力巨大，只需要<code>O(lgn)</code>的时间<a id="more"></a>就可以找到相应的元素。但是现在条件变了，一个排序数组在某个地方旋转了，比如<code>12345</code>变成了<code>45123</code>，那么我们还能继续使用二分搜索来高效搜索吗？答案是肯定的，但是我们要把各种情况都考虑到，否则很容易出错。</p>
<p>我们先从简单的开始，假设这个旋转的有序数组A没有重复元素。对数组<code>0,2,4,6,8</code>而言，考虑下面几种旋转：</p>
<ul>
<li><code>2,4,6,8,0</code></li>
<li><code>4,6,8,0,2</code></li>
<li><code>6,8,0,2,4</code></li>
<li><code>8,0,2,4,6</code></li>
</ul>
<p>初始状态下，l=0，r=4，那么m=2。如果要搜索元素T，现在思考什么情况下T可能在右半段？</p>
<p>首先我们要知道，划分后的两段必然至少有一段是有序的（本题为升序），否则它不可能是有序数组的旋转。懂了这个前提，我们就好分析了，如果左半段有序，即A[m]&gt;A[l]，那么T在右半段的情况只能是<code>T&gt;A[m]</code>或者<code>T&lt;A[l]</code>；如果右半段有序，即A[m]&gt;A[l]，说明左半段存在旋转，那么T在右半段的情况只能是<code>T&gt;A[m]</code>并且<code>T&lt;A[r]</code>。</p>
<p>给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        middle = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] == target)</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((nums[middle] &gt;= nums[l] &amp;&amp; (target &gt; nums[middle] || target &lt; nums[l]))</span><br><span class="line">        || (nums[middle] &lt; nums[l] &amp;&amp; target &gt; nums[middle] &amp;&amp; target &lt;= nums[r]))</span><br><span class="line">            l = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在题目解除没有重复的约束条件，又该如何求解呢？</p>
<p>思路还是和上面类似，先判断哪一段是有序的，随后给出T在有序段内的条件；但是对于有重复的元素，我们要处理A[l]=A[m]的情况，考虑这种序列<code>1,5,1,1,1</code>和<code>1,1,1,5,1</code>，左半段有可能有序，右半段也有可能有序，这个时候我们就做特殊处理，缩小区间，l++和r–。</p>
<p>给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    in left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// case [1,5,1,1,1] or [1,1,1,5,1]</span></span><br><span class="line">        <span class="keyword">if</span>( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) &#123; ++left; --right; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] &lt;= nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[mid] &lt; target) &amp;&amp;  (nums[right] &gt;= target) ) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法（一）：基于比较的排序</title>
    <url>/2017/06/27/sorting/</url>
    <content><![CDATA[<p>排序算法算是很基础的内容了，也是我们都要掌握的算法，最近有时间复习了一下<a id="more"></a>，在这里做个总结吧。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的最坏运行时间是<code>O(n*n)</code>，但是它的平均性能相当好，为<code>O(nlgn)</code>，是一种不稳定的排序方法。其主要思想可以描述为：</p>
<ul>
<li>数组S的长度为0或者1是，直接return；</li>
<li>在S里面选取一个元素v，做为pivot值；</li>
<li>然后对剩下的元素<code>S-{v}</code>划分为两部分：<code>S1={x &gt; v | x ∈ S-{v}}</code>，<code>S2={x &lt;= v | x ∈ S-{v}}</code>，就是一个部分大于v，另一部分小于等于v。</li>
<li>最后对<code>S1</code>和<code>S2</code>进行划分，以此类推。<br>最后代码如下所示：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最初调用的是QucickSort(nums, 0, nums.size() - 1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QucickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = Partition(nums, p, r);</span><br><span class="line">        QucickSort(nums, p, q - <span class="number">1</span>);</span><br><span class="line">        QucickSort(nums, q + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[last];</span><br><span class="line">    <span class="keyword">int</span> i = first - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = first; j &lt; last; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot)</span><br><span class="line">            swap(nums[++i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[i + <span class="number">1</span>], nums[last]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码中选取的是<code>last</code>最为pivot元素。</p>
<p> （<em>2017.07.28更新</em>）</p>
<p> 考虑一种极端的情况，若待排序的数组每个元素都相同，那么我们使用上面的方法会达到最差的运行时间<code>O(n*n)</code>，因为每次划分都需要<code>O(n)</code>的时间来去掉一个元素。但是对于这种输入，插入排序的性能却相当好。</p>
<p> 使用双向划分可以避免这个问题，看下面的代码：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &gt;= u)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">int</span> t = nums[l];</span><br><span class="line">   <span class="keyword">int</span> i = l;</span><br><span class="line">   <span class="keyword">int</span> j = u + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">do</span></span><br><span class="line">       &#123;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125; <span class="keyword">while</span> (i &lt;= u &amp;&amp; nums[i] &lt; t);</span><br><span class="line">       <span class="keyword">do</span></span><br><span class="line">       &#123;</span><br><span class="line">           --j;</span><br><span class="line">       &#125; <span class="keyword">while</span> (j &gt;= l &amp;&amp; nums[j] &gt; t);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ( i &gt; j)</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       swap(nums[i], nums[j]);</span><br><span class="line">   &#125;</span><br><span class="line">   swap(nums[l], nums[j]);</span><br><span class="line">   QSort(nums, l, j - <span class="number">1</span>);</span><br><span class="line">   QSort(nums, j + <span class="number">1</span>, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们用i和j分别从两端开始扫描，第一个循环将i右移过小元素，第一个循环将j左移过大元素，为了处理上面的极端情况，我们设计为当遇到相同元素是停止扫描，交换i和j对应的值，这样做虽然交换次数增加了，但是对于所有元素都相同的情况下，运行时间为<code>O(nlgn)</code>。</p>
<p>其实为了改善平均运行时间，我们还可以修改选取枢轴元素的方法（三数取中法或者随机法），使得每一次划分尽可能均匀。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序算是最早接触的简单的一种排序方式，和冒泡排序（太简单，不再介绍）类似，其主要思想就是每次将一个元素插入到前面合适的位置。平均运行时间为<code>O(n*n)</code>，是一种稳定的排序方式。<br>由于比较简单，就不在过多分析，只贴出代码（升序）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.size(); ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key = nums[j];</span><br><span class="line">        <span class="keyword">int</span> i = j<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; key)</span><br><span class="line">                nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p>合并排序（也叫归并排序），也是一种平均性能很好<code>O(nlgn)</code>的排序方法，其最坏情况下的运行时间也是<code>O(nlgn)</code>，是一种稳定的排序方式。主要思想如下所示（divide and conquer）:</p>
<ul>
<li>divide：把n个元素分成含有n/2个元素的子序列；</li>
<li>conquer：用合并排序对两个子序列递归进行排序；</li>
<li>merge：合并两个已排序的子序列。</li>
</ul>
<p>注意：合并排序需要<code>O(n)</code>的额外空间。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最初调用的是MergeSort(nums, 0 nums.size() - 1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = right - mid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; n1(len1);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; n2(len2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组的原来的值保存下来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i)</span><br><span class="line">        n1[i] = nums[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; ++i)</span><br><span class="line">        n2[i] = nums[mid + i + <span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 开始合并</span></span><br><span class="line">    <span class="keyword">int</span> f = left;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len1 &amp;&amp; k &lt; len2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n1[j] &lt; n2[k])</span><br><span class="line">            nums[f++] = n1[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[f++] = n2[k++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余的部分</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; len1)</span><br><span class="line">        nums[f++] = n1[j++];</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len2)</span><br><span class="line">        nums[f++] = n2[k++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(nums, left, mid);</span><br><span class="line">        MergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        MergeRange(nums, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序也是一种很优秀的排序算法，关键的地方在于如何建堆，其平均运行时间是<code>O(nlgn)</code>，是一种不稳定的排序方式。堆的性质不仅可用于排序，可以用于其他的很多场景下（比如优先级队列）。</p>
<p>（二叉）堆可以被视为一颗完全二叉树，一般用顺序存储的数组来表示，对某个结点的下标为i，（从零开始）那么我们有左子树下标为<code>left(i) = 2 * i + 1</code>，右子树下标<code>right(i) = 2 * i - 2</code>，父结点下标<code>parent(i) = (i - 1) / 2</code>。根据排序的方式：升序或者降序，我们要建立相应的堆：最大堆和最小堆。对于最大堆而言，它的性质就是除了根结点以外的每个结点i，都满足<code>parent[i]</code>对应的值大于等于<code>i</code>对应的值。</p>
<p>因此我们写下第一个函数<code>MaxHeapify</code>，它的作用是使下标为i的元素满足最大堆的性质，如果i和左子树或者右子树进行了交换，那么我们要对左子结点或者右子结点进行调整，last表示的是区间范围<code>[i, last)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> largest = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; last &amp;&amp; nums[i] &lt; nums[left])</span><br><span class="line">        largest = left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        largest = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; last &amp;&amp; nums[largest] &lt; nums[right])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[i], nums[largest]);</span><br><span class="line">        MaxHeapify(nums, largest, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是建堆（时间复杂度为<code>O(n)</code>），只需对每个非叶子节点调用<code>MaxHeapify</code>即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        MaxHeapify(nums, i, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后利用堆来排序，由于执行<code>BuildMaxHeap</code>后，数组最大值在nums[0]处，我们把它与第<code>nums.size()</code>个元素交换，随后调用<code>MaxHeapify</code>使下标为0的元素满足堆的性质，然后nums[0]与nums[nums.size()-2]交换，以此类推，直到<code>i = 1</code>为止，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    BuildMaxHeap(nums);</span><br><span class="line">    <span class="comment">// 每次循环将当前最大值移动到nums[i]处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[j]);</span><br><span class="line">        MaxHeapify(nums, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并排序和堆排序在最坏的情况下时间复杂度也是<code>O(nlgn)</code>。</p>
<p>引申：</p>
<p>最佳归并树：对k路归并树而言，如果u=(m-1)mod(k-1)=0，那么不需要添加虚段；否则要添加k-u-1个虚段。</p>
<p>参考文献：</p>
<ol>
<li>Introduction to Algorithms (2ed edition).</li>
<li>Data Structures and Algorithm Analysis in C++ (4th edition).</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法（二）：线性时间内排序</title>
    <url>/2017/06/28/sorting-linear/</url>
    <content><![CDATA[<p>接下来要介绍的三种排序算法，都不是基于比较的排序方法（基于比较排序的算法<a id="more"></a>时间下界是<code>O(nlgn)</code>），它们的平均运行时间都是<code>O(n)</code>。</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计算排序（count sort）对数据分布做了一个假设：所有待排序的元素都分布在0到M之间。它的基本思想就是对每个元素x，统计出小于x的元素个数，有了这个信息以后，我们就可以直接把x放到合适的位置上，比如有5个元素小于x，那么x就在第六个位置。</p>
<p>代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve_count(M + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        ve_count[nums[i]]++;</span><br><span class="line">    <span class="comment">// 这里使得ve_count[i]指的是小于等于i的元素的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        ve_count[i] += ve_count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(nums); <span class="comment">//辅助数组，保存原数组的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="comment">//从后往前：为了保持“稳定”</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums[ve_count[tmp[i]] - <span class="number">1</span>] = tmp[i];</span><br><span class="line">        --ve_count[tmp[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了处理元素值相等的情况，每次将<code>tmp[i]</code>放入合适的位置后，都要减小<code>ve_vount[tmp[i]]</code>的值，也就是把下一个相等的元素放到前一个位置上。</p>
<p>注意：有<code>ve_count[tmp[i]]</code>个元素小于等于<code>tmp[i]</code>，我们就把它放到下标为<code>ve_count[tmp[i]] - 1</code>的位置上（下标从0开始）。</p>
<p>举例：</p>
<p>假设我们有</p>
<blockquote>
<p>数组nums为<code>[2, 5, 0, 3, 2]</code>，假定<code>M = 5</code>。</p>
</blockquote>
<p>那么我们可以计算出</p>
<blockquote>
<p><code>ve_count = [1, 1, 3, 4, 4, 5]</code></p>
</blockquote>
<p>对于<code>i = 4</code>时，有<code>nums[4] = 2</code>，<code>ve_count[2] = 3</code>，说明有3个数小于等于2，那么我们就把2放在下标为2的位置上，即有<code>nums[2] = 2</code>；剩下的以此类推。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序（radix sort）就是从最低有效位开始进行排序，如果每个数有d位，那么只需要进行d次排序，就可以把整个数据变为有序。伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">radix_sort:</span><br><span class="line"><span class="keyword">for</span> i  = <span class="number">1</span> to d</span><br><span class="line">    sort <span class="built_in">array</span> on digit i;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，基数排序的时间复杂度取决于用哪一种稳定的中间排序方法，当每一位数字都分布在0到M之间时（而且M的值不是很大），我们可以对每一位都是使用计数排序的方式，所以我们可以知道其时间复杂度为<code>O(d*n)</code>，d为常数，我们可以认为基数排序也是线性运行时间。</p>
<p>代码如下所示，这里稍微的扩展了一下，256个ASCII字符，假定每个字符长度一样（都是str_len)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort_fixed_len</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; arr, <span class="keyword">int</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> BucketNum = <span class="number">256</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; buc(BucketNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str_len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="comment">//从最低位开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//arr[j][i]指的是字符串arr[j]上第i位的字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.size(); ++j)</span><br><span class="line">        buc[ arr[j][i] ].push_back(arr[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按照当前第i位开始排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; BucketNum; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!buc[k].empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; buc[k].size(); ++l)</span><br><span class="line">                arr[index++] = buc[k][l];</span><br><span class="line">                buc[k].clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>最简单的桶排序（bucket sort）和计数排序有点类似，我们统计每个数出现的次数以后，可以直接进行输出，也假设数据分布在0到M之间，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort_easy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(M + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        tmp[nums[i]]++; <span class="comment">//这里的tmp[i]指的是数组中值为i出现的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tmp[i]; ++j)</span><br><span class="line">            nums[k++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面这三种线性时间排序算法都需要至少<code>O(n)</code>的额外空间，所以在实际应用过程中，如果内存比较宝贵，我们还是应该选择基于比较的渐进时间复杂度为<code>O(nlgn)</code>的就地排序（in-place）。</p>
<p>参考文献：</p>
<ol>
<li>Introduction to Algorithms (2ed edition).</li>
<li>Data Structures and Algorithm Analysis in C++ (4th edition).</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基本指令</title>
    <url>/2017/08/24/starting-git/</url>
    <content><![CDATA[<p><strong>Starting Git - fast version control</strong><a id="more"></a></p>
<h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>初始化Git版本库</p>
<h2 id="git-clone-url"><a href="#git-clone-url" class="headerlink" title="git clone [url]"></a>git clone [url]</h2><p>远程仓库克隆到本地</p>
<h2 id="git-add-file"><a href="#git-add-file" class="headerlink" title="git add [file]"></a>git add [file]</h2><p>将修改提交到暂存区</p>
<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>查看当前状态</p>
<h2 id="git-commit-m"><a href="#git-commit-m" class="headerlink" title="git commit -m []"></a>git commit -m []</h2><p>将修改提交到工作区</p>
<h2 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD^"></a>git reset HEAD^</h2><p>回退到上一个版本</p>
<h2 id="git-checkout-–-file"><a href="#git-checkout-–-file" class="headerlink" title="git checkout – [file]"></a>git checkout – [file]</h2><p>撤销修改</p>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch []"></a>git branch []</h2><p>创建分支</p>
<h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout []"></a>git checkout []</h2><p>切换分支</p>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge []"></a>git merge []</h2><p>把分支合并到master主分支</p>
<h2 id="git-branch-d"><a href="#git-branch-d" class="headerlink" title="git branch -d []"></a>git branch -d []</h2><p>删除分支</p>
<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>查看提交历史</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT支持LaTeX公式</title>
    <url>/2017/09/14/starting-latex-with-next/</url>
    <content><![CDATA[<p>NexT主题中集成了MathJax公式渲染插件，我们不再需要额外的用<code>nmp install</code>去安装了<a id="more"></a>，找到主题配置文件<code>...\hexo\themes\next\_config.yml</code>，修改下面一行即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p>具体公式使用方法可看这里：<a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">https://github.com/hexojs/hexo-math</a></p>
<p>使用visual studio code的同学请安装<strong>Markdown+Math</strong>插件，支持LaTeX实时预览。写几个Block看看：</p>
<p>平方<code>$$e = m c^2$$</code></p>
<p>$$e = m c^2$$</p>
<p>上下标<code>$$x^2_1 + x^2_2$$</code></p>
<p>$$x^2_1 + x^2_2$$</p>
<p>分数根号<code>$$\sqrt[2]{x+\frac{y}{x+y}}$$</code></p>
<p>$$\sqrt[2]{x+\frac{y}{x+y}}$$</p>
<p>求和<code>$$\sum_{k=1}^{n}\frac{1}{k}$$</code></p>
<p>$$\sum_{k=1}^{n}\frac{1}{k}$$</p>
<p>积分<code>$$\int_a^b f(x)dx$$</code></p>
<p>$$\int_a^b f(x)dx$$</p>
<p>对于行公式$\sqrt[2]{a+b}$可这样写：<code>$\sqrt[2]{a+b}$</code>。LaTeX公式语法学习请看：<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/LaTeX/Mathematics</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表single linked list的一些总结</title>
    <url>/2017/07/25/summary-of-linkedlist/</url>
    <content><![CDATA[<p>如果我们需要对数据集合进行频繁的插入删除操作的话，那么<a id="more"></a>单链表可能是一种更好的选择。</p>
<p>定义单链表结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是一些常见的单链表操作总结（均没有头结点）：</p>
<h2 id="Add-Numbers"><a href="#Add-Numbers" class="headerlink" title="Add Numbers"></a>Add Numbers</h2><p>用链表模拟两个非负整数的加法，比如<code>1-&gt;6-&gt;2</code>和<code>2-&gt;4-&gt;1</code>相加等于<code>3-&gt;0-&gt;4</code>，链表的开头代表数字最低位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    ListNode *p = &amp;head;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;cal : <span class="number">0</span>) + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">        l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Delete-Nth-Node-from-End-of-List"><a href="#Delete-Nth-Node-from-End-of-List" class="headerlink" title="Delete Nth Node from End of List"></a>Delete Nth Node from End of List</h2><p>用两个指针，第一个先走n步，随和和第二个一起走，直到先走的指针到达最后一个结点，此时后走的指针的后继就是倒数第n个结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">pre_head</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    pre_head.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode *p1 = &amp;pre_head, *p2 = &amp;pre_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p1-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *tmp = p2-&gt;next;</span><br><span class="line">    p2-&gt;next = p2-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">    tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h2><p>把两个有序的链表合并成一个有序的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    ListNode *p = &amp;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p -&gt;next = (l1 == <span class="literal">NULL</span>) ? l2 : l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h2><p>交换链表的两个相邻结点，比如<code>1-&gt;2-&gt;3-&gt;4</code>交换后为<code>2-&gt;1-&gt;4-&gt;3</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">pre_head</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    pre_head.next = head;</span><br><span class="line">    ListNode *p = &amp;pre_head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head &amp;&amp; head-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *q = head-&gt;next;</span><br><span class="line">        head-&gt;next = q-&gt;next;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        q-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        p = head;</span><br><span class="line">        head = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Remove-Duplicates-I"><a href="#Remove-Duplicates-I" class="headerlink" title="Remove Duplicates I"></a>Remove Duplicates I</h2><p>每个值只出现一次，比如<code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>删除后为<code>1-&gt;2-&gt;3</code>（给的链表已经有序）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *p1 = head;</span><br><span class="line">    ListNode *p2 = head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val == p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p1-&gt;next = p2-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Remove-Duplicates-II"><a href="#Remove-Duplicates-II" class="headerlink" title="Remove Duplicates II"></a>Remove Duplicates II</h2><p>去除所有有重复元素的结点，比如<code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>删除后为<code>2</code>（给的链表已经有序）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode <span class="title">pre_head</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    pre_head.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode *p1 = &amp;pre_head;</span><br><span class="line">    ListNode *p2 = head;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p2-&gt;next != <span class="literal">NULL</span> &amp;&amp; p2-&gt;next-&gt;val == p2-&gt;val)</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;next == p2)</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p1-&gt;next = p2-&gt;next;</span><br><span class="line">        </span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rotate-List"><a href="#Rotate-List" class="headerlink" title="Rotate List"></a>Rotate List</h2><p>把链表循环右移k位，比如给定链表<code>1-&gt;4-&gt;3-&gt;2-&gt;5</code>循环右移2位变为<code>2-&gt;5-&gt;1-&gt;4-&gt;3</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    ListNode *p1 = head, *p2 = head;</span><br><span class="line">    <span class="comment">// n为链表长度</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// p1到达原最后一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p1-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++n;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p1-&gt;next = head;</span><br><span class="line">    <span class="comment">// p2为新链表的最后一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (len - k % len); ++i)</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    </span><br><span class="line">    head = p2-&gt;next;</span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h2><p>把链表根据其元素值的大小分为两部分，小于x的在前面，不小于x的在后面，比如给定<code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code>和<code>x = 3</code>，那么我们得到<code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>，注意保持元素相对位置不变。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把原来的链表拆分为两个</span></span><br><span class="line">    <span class="comment">// 值小于x在pa</span></span><br><span class="line">    <span class="comment">// 值大于等于x在pb</span></span><br><span class="line">    <span class="function">ListNode <span class="title">pa</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">pb</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ListNode *p1 = &amp;pa;</span><br><span class="line">    ListNode *p2 = &amp;pb;</span><br><span class="line">    ListNode *p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            p1-&gt;next = p;</span><br><span class="line">            p1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;next = p;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p1-&gt;next = pb.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pa.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linked-List-Cycle-I"><a href="#Linked-List-Cycle-I" class="headerlink" title="Linked List Cycle I"></a>Linked List Cycle I</h2><p>判断单链表是否有环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> &amp;&amp; head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 利用快慢指针</span></span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a>Linked List Cycle II</h2><p>如果单链表有环，求出换开始的地方，如果没有换，返回NULL。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *begin = head;</span><br><span class="line">            <span class="comment">// 存在环，那么slow和fast相遇的地方离环开始的结点的距离</span></span><br><span class="line">            <span class="comment">// 与head（链表第一个结点）离环开始的结点的距离是相等的。</span></span><br><span class="line">            <span class="keyword">while</span> (slow != begin)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                begin = begin-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Intersection-of-Two-Linked-Lists"><a href="#Intersection-of-Two-Linked-Lists" class="headerlink" title="Intersection of Two Linked Lists"></a>Intersection of Two Linked Lists</h2><p>求两个单链表相交的起始结点。</p>
<p>常规的思路是求出两个链表的长度m和n，然后在长的链表上先走m-n步，随后和短的链表一起走，直至相遇。</p>
<p>下面介绍另一种更巧妙的解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *cur1 = headA, *cur2 = headB;</span><br><span class="line">    <span class="comment">// 如果没有相交的话，将会返回NULL</span></span><br><span class="line">    <span class="comment">// 如果有交点的话，那么cur1和cur2会相遇在第一个交点</span></span><br><span class="line">    <span class="keyword">while</span>(cur1 != cur2)</span><br><span class="line">    &#123;</span><br><span class="line">        cur1 = cur1 ? cur1-&gt;next : headB;</span><br><span class="line">        cur2 = cur2 ? cur2-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Remove-Elements"><a href="#Remove-Elements" class="headerlink" title="Remove Elements"></a>Remove Elements</h2><p>移除链表中所有值为T的结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">pre_head</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    pre_head = head;</span><br><span class="line">    </span><br><span class="line">    ListNode *p1 = &amp;pre_head;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == val)</span><br><span class="line">            p1-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>Reference: LeetCode</em></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>模板全特化和偏特化</title>
    <url>/2017/08/27/template-specialization/</url>
    <content><![CDATA[<p>第一次接触模板特化的概念还是在看《STL源码剖析》那会儿<a id="more"></a>，今天看《Effective C++》又碰到了这个问题，所以就简单复习下。</p>
<p>之前写的关于类型萃取的博文：<a href="http://klausguan.com/2016/06/19/learn-stl3-traits/" target="_blank" rel="noopener">STL源码剖析-学习笔记（三）:traits</a>里面就涉及到了模板特化。</p>
<h2 id="模板全特化"><a href="#模板全特化" class="headerlink" title="模板全特化"></a>模板全特化</h2><p>用于类模板和函数模板，看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// total template specialization</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> f&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"int"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个是函数模板，第二个是针对int型变量的全特化模板，如果传入int类型会自动调用第二个f函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'c'</span>;</span><br><span class="line">f&lt;<span class="keyword">char</span>&gt;(c); <span class="comment">// print "T"</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">f&lt;<span class="keyword">int</span>&gt;(x); <span class="comment">// print "int"</span></span><br></pre></td></tr></table></figure>

<h2 id="模板偏特化"><a href="#模板偏特化" class="headerlink" title="模板偏特化"></a>模板偏特化</h2><p>只能用于类模板中，看例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial template specialization</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"T*"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二个类中，针对指针类型进行了偏特化处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">A&lt;<span class="keyword">int</span>*&gt; b;</span><br><span class="line">a.p(); <span class="comment">// print "T"</span></span><br><span class="line">b.p(); <span class="comment">// print "T*"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP连接的建立与终止</title>
    <url>/2017/08/19/tcp-connection-and-termination/</url>
    <content><![CDATA[<p>TCP是一个面向连接的协议，无论哪个方向像另一个方向发送数据之前<a id="more"></a>，都必须先在双方之间建立一条连接。</p>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>TCP连接的建立需要“三次握手”，看下图：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/networks/tcp-connection.png" alt="tcp-connecion"></p>
<p>过程阐述：</p>
<ul>
<li><p>第一次握手：Client将标志位SYN置为1，产生一个初始序号seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1以对Client发送的报文段进行确认，随机产生一个序号seq=K，并将该数据包发送给Client，Server进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1对Server发送的报文段进行确认，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ul>
<h2 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h2><p>终止一个TCP连接要进行“四次挥手”，这是由于TCP的半关闭造成的，既然TCP连接是一个全双工（数据在两个方向上能同时传递），因此每一个方向都必须单独的进行关闭。</p>
<p>看下图：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/networks/tcp-termination.png" alt="tcp-termination"></p>
<p>过程阐述：</p>
<ul>
<li><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
</li>
<li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态，Client收到这个ACK后进入FIN_WAIT_2状态。</p>
</li>
<li><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
</li>
</ul>
<p>需要我们注意的是：收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。</p>
<p>服务器端可能会同时发送ACK和FIN，因此Client可能不会进入FIN_WAIT_2状态。（又称三次挥手）</p>
<h3 id="TCP的半关闭"><a href="#TCP的半关闭" class="headerlink" title="TCP的半关闭"></a>TCP的半关闭</h3><p>TCP的连接提供了连接的一段在结束它的发送后还能收到接收来自另一端数据的能力，这就是所谓的半关闭。</p>
<h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p><code>TIME_WAIT</code>状态也称为2MSL等待状态。MSL指的是最大报文段生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p>
<p>假设最终的ACK丢失，Server会超时并重发最后的FIN，Client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果Server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，Client必须进入<code>TIME_WAIT</code>状态，因为Client可能面临重发最终ACK的情形。</p>
<p>如果<code>TIME_WAIT</code>状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。</p>
]]></content>
      <categories>
        <category>Networks</category>
      </categories>
      <tags>
        <tag>Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>用队列来实现栈的操作</title>
    <url>/2017/07/30/two-queues-implement-stack/</url>
    <content><![CDATA[<p>相信大家对这个问题多少也有所耳闻，他还有一个对称的问题就是<a id="more"></a>用栈来实现队列操作，栈实现队列方法相对简单，我这里就不再赘述，今天这篇博客主要的任务总结一下用队列完成栈操作的两种方式。</p>
<h3 id="用两个队列"><a href="#用两个队列" class="headerlink" title="用两个队列"></a>用两个队列</h3><p>最常见的思路，用两个队列来完成：</p>
<ul>
<li>压入操作：把元素放入任意一个空的队列（假如为q1），再把另一个队列（q2）的所有元素入队到q1。始终保证压入操作完成后，只有一个队列里面存有元素，这样，我们最后入队的元素就会始终在某个队列的第一个元素的位置。</li>
<li>出栈操作：弹出非空队列的队头元素。<br>看一个示意图：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压入1：</span><br><span class="line">q1      q2          </span><br><span class="line">——————  ———————</span><br><span class="line">1</span><br><span class="line">——————  ———————</span><br><span class="line"></span><br><span class="line">压入2：</span><br><span class="line">q1      q2          </span><br><span class="line">——————  ———————</span><br><span class="line">        2 1</span><br><span class="line">——————  ———————</span><br><span class="line"></span><br><span class="line">压入3：</span><br><span class="line">q1      q2          </span><br><span class="line">——————  ———————</span><br><span class="line">3 2 1</span><br><span class="line">——————  ———————</span><br><span class="line"></span><br><span class="line">出栈：</span><br><span class="line">q1      q2          </span><br><span class="line">——————  ———————</span><br><span class="line">2 1</span><br><span class="line">——————  ———————</span><br><span class="line"></span><br><span class="line">压入4：</span><br><span class="line">q1      q2          </span><br><span class="line">——————  ———————</span><br><span class="line">        4 2 1</span><br><span class="line">——————  ———————</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>相信现在都一目了然了。</p>
<p>下面给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q1.push(x);</span><br><span class="line">            <span class="keyword">while</span> (!q2.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.front());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q2.push(x);</span><br><span class="line">            <span class="keyword">while</span> (!q1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.front());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = q2.front();</span><br><span class="line">            q2.pop();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q1.empty())</span><br><span class="line">            <span class="keyword">return</span> q1.front();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> q2.front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.empty() &amp;&amp; q2.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="用一个队列"><a href="#用一个队列" class="headerlink" title="用一个队列"></a>用一个队列</h3><p>比较新奇的思路，关键点就是：入栈操作时把队列里面之前的元素出队后重新入队。</p>
<p>看个示意图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压入1：</span><br><span class="line">q1       </span><br><span class="line">—————— </span><br><span class="line">1</span><br><span class="line">—————— </span><br><span class="line"></span><br><span class="line">压入2：</span><br><span class="line">q1       </span><br><span class="line">—————— </span><br><span class="line">2 1</span><br><span class="line">—————— </span><br><span class="line"></span><br><span class="line">压入3：</span><br><span class="line"></span><br><span class="line">q1       </span><br><span class="line">—————— </span><br><span class="line">3 2 1</span><br><span class="line">—————— </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅给出入队操作，别的操作很简单了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mystack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        q1.push(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; q1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            q1.push(q1.front());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Queue</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4的LineTraceSingle实现原理</title>
    <url>/2020/06/17/ue4-line-trace/</url>
    <content><![CDATA[<p>先占坑，后面补上；<a id="more"></a></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 Delegate源码分析</title>
    <url>/2020/05/10/ue4-delegate/</url>
    <content><![CDATA[<p>Unreal里面Delegate机制还是挺有意思的，看下源码学习学习。<a id="more"></a></p>
<p>其实委托机制的本质并不复杂，就是我们之前学过的观察者模式，也可以说是订阅-发布模式。常常可用于模块之间的解耦，在整个Unreal的源码里面应用是非常广泛的。</p>
<p>UE4里面的的Delegate常用的几种宏：</p>
<ul>
<li>DECLARE_DELEGATE( DelegateName ) …</li>
<li>DECLARE_MULTICAST_DELEGATE( DelegateName ) …</li>
<li>DECLARE_EVENT( OwningType, EventName ) …</li>
<li>DECLARE_DYNAMIC_DELEGATE( DelegateName ) …</li>
<li>DECLARE_DYNAMIC_MULTICAST_DELEGATE( DelegateName ) …</li>
</ul>
<p>带Dynamic的实现比较复杂，它可以被序列化、暴露给蓝图使用，走的是UObject那一套。</p>
<p>在<code>DelegateCombinations.h</code>里面还定义了很多带参数的Delegate，方便我们直接使用。</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中SceneCapture和SceneView分析</title>
    <url>/2020/06/17/ue4-scene-view-and-capture/</url>
    <content><![CDATA[<p>先占坑，后面补上；<a id="more"></a></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟存储器</title>
    <url>/2017/08/26/virtual-memory/</url>
    <content><![CDATA[<p><strong>Virtual Memory</strong><a id="more"></a></p>
<p>虚拟存储器为操作系统提供了三个重要的能力：</p>
<ol>
<li>它将主存看成是一个存储在硬盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在主存和硬盘之间来回传送数据。</li>
<li>为每个进程提供了一致的地址空间，从而简化了存储管理；</li>
<li>它保护了每个进程的地址空间不被其他进程破坏。</li>
</ol>
<p>在使用虚拟存储器的机器上，CPU使用的是虚拟寻址形式，CPU不直接使用物理地址，而是先通过生成一个虚拟地址，然后由MMU进行地址翻译转换成物理地址。</p>
<p>虚拟存储器被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组。每个地址都有一个虚拟地址，这个唯一的虚拟地址是作为到数组的索引，磁盘上数组的内容被缓存到主存中。</p>
<p>虚拟存储器被分割为虚拟页（磁盘上），物理存储器被分割为物理页（DRAM上）。</p>
<p>页表：</p>
<p>页表将虚拟页映射到物理页。每次地址翻译时都会读取页表来把一个虚拟地址转换为物理地址。看下图实例：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/virtual-memory/page-table.png" alt="page-table"></p>
<p>图中有8个虚拟页和8个物理页。四个虚拟页（VP1 VP2 VP7 VP4）当前被缓存到了DRAM里。两个页（VP0 VP5）还未分配。而剩下的VP3和VP6已经分配了，但是还未被缓存。</p>
<p>图中的PTE指的是页表条目，由一个有效位valid和n为的地址字段组成，有效位valid为1，那么该物理字段就表示DRAM中相应的物理页的起始位置，这个物理页缓存了虚拟页。</p>
<p>地址翻译：</p>
<p>看一个使用页表的地址翻译过程：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/virtual-memory/address-translation.png" alt="address-translation"></p>
<p>CPU中的一个控制寄存器，PTBR（页表基址寄存器）指向当前页表。n位虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。MMU利用VPN来选择合适的PTE。例如VPN 0选择PTE 0，VPN 1选择PTE 1，等等。将页表条目中的物理页号PPN和虚拟地址中的VPO串联起来，就得到了相应的物理地址。</p>
<p>如果有效位valid等于0，那么该页不在主存DRAM中，产生一个缺页异常。为了处理缺页异常，系统会按照一定的方式来进行页面调度，把该页从磁盘拷贝回主存。</p>
<p>参考资料：</p>
<ol>
<li>CSAPP 第九章</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的超时与重传</title>
    <url>/2017/08/16/tcp-timeout-and-retransmission/</url>
    <content><![CDATA[<p>TCP提供可靠地运输层，它使用的方法之一就是每次都要确认从另一端收到的数据。<a id="more"></a>但是数据和确认都有可能会丢失，因此TCP通过在发送时设置一个定时器来解决这个问题，如果定时器溢出时还没有收到确认，它就重传该数据。</p>
<p>我们知道TCP使用的是滑动窗口协议来进行流量控制，该协议允许发送方在停止等待确认前可以连续发送多个分组，而不必每发送一个分组就停下来等待确认。</p>
<p>拥塞：当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时变会发生拥塞。当多个数据流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。（类似于公路堵车，交通拥挤，无法前行，网络吞吐量下降，甚至陷入停顿）</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>先看一些概念：</p>
<p><strong>拥塞窗口</strong>：发送端根据网络的拥塞程度所预设的一个大小值，而这个值就是拥塞窗口，指发送方在拥塞控制情况下一次最多能发送的数据包的数量。</p>
<p><strong>通告窗口</strong>：接收方提供的窗口大小，该大小通常可以由接收进程控制，影响TCP的性能。</p>
<p>拥塞避免是发送方使用的流量控制，而通告窗口是接收方使用的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接受方在该连接上可用的缓存大小有关。</p>
<p>慢启动：为发送方的TCP增加了一个拥塞窗口，记为cwnd，当与另一个网络的主机建立TCP连接时，拥塞窗口就被初始化为1个报文段（即另一端通过的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段。发送方去拥塞窗口与通告窗口中的最小值做为发送上限。</p>
<ul>
<li>发送方开始时发送一个报文段，然后等待ACK。</li>
<li>当收到该ACK时，拥塞窗口由1变为2，即可用发送两个报文段。</li>
<li>当收到就两个报文段的ACK时，拥塞窗口变为4。</li>
<li>以此类推…</li>
</ul>
<p>这是一种指数增加的关系。</p>
<h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><p>我们可以看到慢启动算法是在一个连接上发起数据流的方法，但是我们有时候会达到中间路由的极限，此时分组将会被丢弃。</p>
<p>拥塞避免算法就是用来处理丢失分组的。一般而言，丢失分组就意味着源主机和目的主机之间的某处网络发生了拥塞，丢失分组有两种指示：<strong>发生超时</strong>和<strong>接受到重复的确认</strong>。</p>
<p>拥塞避免算法要求每次收到一个确认时将cwnd增加1，与慢启动相比，这是一个加性增长。我们希望在一个RTT内最多为cwnd增加一个报文段（不管这个RTT中收到了多少个ACK）。</p>
<p>实际情况中，当发生拥塞时，我们用着两种算法协同工作，它们需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。</p>
<p>工作过程如下：</p>
<ul>
<li>对一个给定的连接，初始化cwmd为1个报文段，ssthresh为65535个字节；</li>
<li>TCP的输出例程不能超过cwnd的大小和接收方通告窗口的大小；</li>
<li>当拥塞发生时（超时或收到重复确认），ssthresh设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起的拥塞，则cwnd被设置为1个报文段（这就是慢启动）。</li>
<li>当新的数据被对方确认时，就增加cwnd，但是增加的方法依赖于我们是否正在进行慢启动或者拥塞避免。如果<code>cwnd &lt;= ssthresh</code>，则正在进行慢启动，否则正在进行拥塞避免。</li>
</ul>
<h2 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h2><p>如果发送方一连串收到3个或者3个以上的重复ACK，就非常可能是一个报文段丢失了，于是我们就重传丢失的数据报文段，而无需等待超时定时器的溢出，这就是快速重传算法。接下来执行的不是慢启动而是拥塞避免算法，这就是快速恢复算法。</p>
<p>在这种情况下没有执行慢启动的原因是由于收到重复的ACK不仅告诉我们一个分组丢失了，由于接收方只有在收到另一个报文段时才会产生重复的ACK，而该报文段已经离开了网络并进入了接收方的缓存，也就是说收发两端仍有流动的数据，因此我们并不希望执行慢启动来突然减少数据流。</p>
<p>因此由于此时不执行慢开始算法，并不会将拥塞窗口cwnd的值置为1，而是将它置为慢开始门限ssthresh的一半。然后再实行拥塞避免算法，每次收到确认之后把cwnd加1。</p>
<p>这里借用<a href="https://baike.baidu.com/item/%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3/4399307?fr=aladdin" target="_blank" rel="noopener">百度百科</a>的一张图来总结一下快重传和快恢复过程：</p>
<p><img src="http://7xv63n.com1.z0.glb.clouddn.com/networks/fast-retransmit.jpg" alt="fast-retransmit"></p>
<p>参考资料：</p>
<ol>
<li>UNP v1 第21章</li>
</ol>
]]></content>
      <categories>
        <category>Networks</category>
      </categories>
      <tags>
        <tag>Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>(译)What does explicit keyword mean?</title>
    <url>/2017/09/16/what-does-explicit-keyword-mean/</url>
    <content><![CDATA[<p>原答案摘自Stack Overflow：<a href="https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean?rq=1" target="_blank" rel="noopener">What does the explicit keyword mean?</a> <a id="more"></a></p>
<p>在把参数传递给函数时，如果变量类型不匹配的话，C++编译器会即尽可能的做一次隐式的类型转换来满足函数的参数要求。隐式的类型转换就会涉及到调用转换对象的单参数构造函数，下面是一个隐式转换的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// single parameter constructor, can be used as an implicit conversion</span></span><br><span class="line">  Foo (<span class="keyword">int</span> foo) : m_foo (foo) </span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetFoo</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_foo; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_foo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个函数用了<code>Foo</code>对象作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoBar</span> <span class="params">(Foo foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = foo.GetFoo ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们如下调用<code>DoBar</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DoBar (<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，实参类型不是<code>Foo</code>，而是<code>int</code>，但是在<code>Foo</code>对象里面有一个单参数的构造器接受了一个int类型来构造对象，因此编译器就会隐式的调用这个构造函数来把<code>int</code>转换成一个<code>Foo</code>。</p>
<p>给这个构造器显示的指定为<code>explicit</code>就是告知编译器我们不想要这种隐式的类型转换，所以编译器就会禁止这种转换，如果我们再次使用<code>DoBar(42)</code>就会报错。</p>
<p>之所以提出这个关键字的原因是因为编译器的这种隐式转换可能会给我们的程序带来一些难以察觉的bug。比如：现在有个一类的构造函数：<code>MyString(int size)</code> 表示初始化这个字符长度为3。你调用了这个函数 <code>print(const MyString&amp;)</code>希望打印出这个字符， 但是马虎的你把代码写成了 <code>print(3)</code> 。你希望的是打印出字符”3”，但是实际返回的是一个空的字符串并且长度为3。</p>
<p>编程建议：一般都要给单参数构造器（包括多参数构造器带有默认参数的）加上<code>explicit</code>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树binary tree的一些总结</title>
    <url>/2017/07/26/summary-of-binary-tree/</url>
    <content><![CDATA[<p>二叉树是一种重要的数据结构，根据其引申出来的二叉查找树（BST）<a id="more"></a>，平衡二叉树（AVL Tree）和红黑树（RB Tree）都有很广泛的应用。AVL tree和RB tree都有着很好的查找性能O(logN)，STL中的map和set就是用红黑树实现的。</p>
<p>我们定义二叉树的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面列出一些二叉树的常见的操作：</p>
<p><strong>完全二叉树 叶子节点</strong>：就是 n0=n/2，其中n为奇数时（n1=0）向上取整；n为偶数时（n1=1），直接计算。</p>
<p><strong>二叉树深度和节点数</strong>：第i层节点数不超过<code>pow(2, i-1)</code>；深度为h的二叉树最多有<code>pow(2, h) - 1</code>个节点；</p>
<h2 id="Maximum-Depth"><a href="#Maximum-Depth" class="headerlink" title="Maximum Depth"></a>Maximum Depth</h2><p>求二叉树的最大高度（深度）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span> : max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：如果要求用非递归的方式，可借用层次遍历的方式。</p>
<h2 id="Minimum-Depth"><a href="#Minimum-Depth" class="headerlink" title="Minimum Depth"></a>Minimum Depth</h2><p>求二叉树的最小高度（深度），定义为到叶子节点的最短路径上的结点数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里给出一个非递归的解法 BFS</span></span><br><span class="line">    <span class="comment">// 主要的思路是利用层次遍历，找到最先的叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ++deep;</span><br><span class="line">        <span class="keyword">int</span> n = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> deep;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left)</span><br><span class="line">                q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right)</span><br><span class="line">                q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a>Same Tree</h2><p>判断两颗二叉树是否相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (p-&gt;val == q-&gt;val &amp;&amp;</span><br><span class="line">            isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;</span><br><span class="line">            isSameTree(p-&gt;right, q-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Symmetric-Tree"><a href="#Symmetric-Tree" class="headerlink" title="Symmetric Tree"></a>Symmetric Tree</h2><p>判断某个二叉树是否为对称二叉树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 对称二叉树的一个例子：</span><br><span class="line">    1</span><br><span class="line"> 2     2</span><br><span class="line">3 4   4 3</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root-&gt;left);</span><br><span class="line">    q.push(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t1 = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        TreeNode *t2 = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> || t2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1-&gt;val != t2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        q.push(t1-&gt;left);</span><br><span class="line">        q.push(t2-&gt;right);</span><br><span class="line">        q.push(t1-&gt;right);</span><br><span class="line">        q.push(t2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h2><p>判断二叉树是否为平衡二叉树，子树的高度相差不差过1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 用到了前面求最大高度的函数</span></span><br><span class="line">    <span class="keyword">int</span> l = maxDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> r = maxDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(l-r) &lt; <span class="number">2</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a>Invert Binary Tree</h2><p>二叉树翻转示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1                 1</span><br><span class="line"> 2     3   -----&gt;  3     2</span><br><span class="line">4 5   6 7         7 6   5 4</span><br></pre></td></tr></table></figure>

<p>下面给出一个递归的解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    swap(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归的解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        swap(t-&gt;left, t-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left)</span><br><span class="line">            s.push(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right)</span><br><span class="line">            s.push(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Traversal"><a href="#Traversal" class="headerlink" title="Traversal"></a>Traversal</h2><p>二叉树的各种遍历（非递归版本）</p>
<h3 id="level-order"><a href="#level-order" class="headerlink" title="level order"></a>level order</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">        <span class="keyword">int</span> n = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode * tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            level.push_back(tmp-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;left)</span><br><span class="line">                q.push(tmp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;right)</span><br><span class="line">                q.push(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.push_back(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inorder"><a href="#inorder" class="headerlink" title="inorder"></a>inorder</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur || !s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *t = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            ret.push_back(t-&gt;val);</span><br><span class="line">            cur = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preorder"><a href="#preorder" class="headerlink" title="preorder"></a>preorder</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        ret.push_back(t-&gt;val);</span><br><span class="line">        <span class="comment">// 注意顺序</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right)</span><br><span class="line">            s.push(t-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left)</span><br><span class="line">            s.push(t-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="postorder"><a href="#postorder" class="headerlink" title="postorder"></a>postorder</h3><p>后序遍历稍微复杂些，因为访问左右结点后要回到根结点进行访问，这里我们设置一个指针指向当前最后访问的结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="comment">// 保存上一个访问的结点</span></span><br><span class="line">    TreeNode* last = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur || !s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(cur;)</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *t = s.top();</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right != <span class="literal">NULL</span> &amp;&amp; t-&gt;right != last)</span><br><span class="line">                cur = t-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(t-&gt;val);</span><br><span class="line">                last = t;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lowest-Common-Ancestor"><a href="#Lowest-Common-Ancestor" class="headerlink" title="Lowest Common Ancestor"></a>Lowest Common Ancestor</h2><h3 id="二叉查找树的最低公共祖先（LCA）"><a href="#二叉查找树的最低公共祖先（LCA）" class="headerlink" title="二叉查找树的最低公共祖先（LCA）"></a>二叉查找树的最低公共祖先（LCA）</h3><p>根据二叉查找树（BST）的特点，父结点的值大于左子树，小于右子树（假定没有重复元素），两个结点的LCA肯定是大于p且小于q的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestorBST</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestorBST(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestorBST(root-&gt;right, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通二叉树的最低公共祖先（LCA）"><a href="#普通二叉树的最低公共祖先（LCA）" class="headerlink" title="普通二叉树的最低公共祖先（LCA）"></a>普通二叉树的最低公共祖先（LCA）</h3><p>这里的思路是，找到从根结点到达p，q的路径，然后转换为类似“求链表的第一个公共结点的问题”。</p>
<p>方法1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; path_p;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; path_q;</span><br><span class="line">    findNodePath(root, p, path_p);</span><br><span class="line">    findNodePath(root, q, path_q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (path_p[i] != path_q[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> path_p[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回溯法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNodePath</span><span class="params">(TreeNode *root, TreeNode *node, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    path.push_back(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left &amp;&amp; findNodePath(root-&gt;left, node, path) ||</span><br><span class="line">        root-&gt;right &amp;&amp; findNodePath(root-&gt;right, node, path))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    path.pop_back();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left == <span class="literal">NULL</span> ? right : left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rebuild-Binary-Tree"><a href="#Rebuild-Binary-Tree" class="headerlink" title="Rebuild Binary Tree"></a>Rebuild Binary Tree</h2><p>根据<strong>前序遍历和中序遍历</strong>来构造二叉树</p>
<p>前序遍历中第一个结点为根结点，然后我们在中序遍历中找到该结点，那么在根结点之前的都是左子树，之后的都是右子树，很容易想到用递归来解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> help(preorder, inorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> prestart, <span class="keyword">int</span> preend, <span class="keyword">int</span> instart, <span class="keyword">int</span> inend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prestart &gt; preend || instart &gt; inend)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[prestart]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = instart;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= inend; ++x)</span><br><span class="line">        <span class="keyword">if</span> (inorder[x] == preorder[prestart])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = help(preorder, inorder, prestart + <span class="number">1</span>, prestart + x - instart, instart, x - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = help(preorder, inorder, prestart + x - instart + <span class="number">1</span>, preend, x + <span class="number">1</span>, inend);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<strong>后序遍历和中序遍历</strong>来构造二叉树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> help(inorder, postorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> instart, <span class="keyword">int</span> inend, <span class="keyword">int</span> poststart, <span class="keyword">int</span> postend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instart &gt; inend || poststart &gt; postend)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(postorder[poststart]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = instart;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= inend; ++x)</span><br><span class="line">        <span class="keyword">if</span> (inorder[x] == preorder[prestart])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = help(inorder, postorder, instart, x - <span class="number">1</span>, poststart, x - instart + poststart - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = help(inorder, postorder, x + <span class="number">1</span>, inend, x - instart + poststart, postend - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Complete-Tree-Nodes"><a href="#Complete-Tree-Nodes" class="headerlink" title="Complete Tree Nodes"></a>Complete Tree Nodes</h2><p>求出一个完全二叉树的结点个数。</p>
<p>根据完全二叉树的定义，除去最后一层是完美二叉树，最后一层的结点都尽可能在左边；也可以理解去完美二叉树去掉了最后一层最右边（一个或多个）的结点。如果完全二叉树的高度为h，那么从1到h-1层的结点数都达到最大。</p>
<p>二叉树第i层最大有<code>pow(2, i-1)</code>个结点，高度为h的二叉树最多有<code>pow(2, h) - 1</code>个结点（注意这里高度的定义：根结点到叶子节点的最大结点数目）。</p>
<p>这里的思路是：分别找出以当前节点为根节点的左子树和右子树的高度并对比，如果相等，则说明是满二叉树，直接返回节点个数；如果不相等，则节点个数为左子树的节点个数加上右子树的节点个数再加1（根节点）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = leftHeight(root);</span><br><span class="line">    <span class="keyword">int</span> r = rightHeight(root);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, l) - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">(TreeNode* l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftHeight(l-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">(TreeNode* r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + rightHeight(r-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binary-Tree-Paths"><a href="#Binary-Tree-Paths" class="headerlink" title="Binary Tree Paths"></a>Binary Tree Paths</h2><p>下面是一些关于二叉树路径的问题：</p>
<h3 id="print-path"><a href="#print-path" class="headerlink" title="print path"></a>print path</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 输出格式如下</span><br><span class="line">     1</span><br><span class="line">    / \</span><br><span class="line">   2   3 ----&gt;[1-&gt;2-&gt;4],[1-&gt;3]</span><br><span class="line">   \</span><br><span class="line">    4</span><br></pre></td></tr></table></figure>

<p>一般用递归来解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; binaryTreePaths(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    getPaths(ret, root, to_string(root-&gt;val));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPaths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret, TreeNode* root, <span class="built_in">string</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        ret.push_back(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) </span><br><span class="line">        getPaths(ret, root-&gt;left, t + <span class="string">"-&gt;"</span> + to_string(root-&gt;left-&gt;val));</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        getPaths(ret, root-&gt;right, t + <span class="string">"-&gt;"</span> + to_string(root-&gt;right-&gt;val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="path-sum-I"><a href="#path-sum-I" class="headerlink" title="path sum I"></a>path sum I</h3><p>判断二叉树是否存在某一条路径其总和为sum：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> (sum == root-&gt;val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) &amp;&amp;</span><br><span class="line">           hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="path-sum-II"><a href="#path-sum-II" class="headerlink" title="path sum II"></a>path sum II</h3><p>现在要求找到并输出路径：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    dfs(ret, vec, root, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, TreeNode *t, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    vec.push_back(t-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right &amp;&amp; sum == t-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        ret.push_back(vec);</span><br><span class="line">        vec.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(ret, vec, t-&gt;left, sum - t-&gt;val);</span><br><span class="line">    dfs(ret, vec, t-&gt;right, sum - t-&gt;val);</span><br><span class="line"></span><br><span class="line">    vec.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kth-Smallest-Node-in-BST"><a href="#Kth-Smallest-Node-in-BST" class="headerlink" title="Kth Smallest Node in BST"></a>Kth Smallest Node in BST</h2><p>求二叉搜索树中第k小的结点。由于二叉搜索树中序遍历是有序的，所以可以按照中序遍历的思路来求解，访问到第k个结点就停止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push(root);</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *t = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        --k;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> t-&gt;val;</span><br><span class="line">        TreeNode *p = t-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>Reference: LeetCode</em></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
</search>
